https://www.sqlite.org/src/timeline?c=98357d8c1263920b
--- a/sqlite3.c	2019-10-17 22:28:36.570479181 +0000
+++ b/sqlite3.c	2019-10-17 22:29:38.802353523 +0000
@@ -105227,6 +105227,8 @@
       if( sqlite3_strglob("unordered*", z)==0 ){
         pIndex->bUnordered = 1;
       }else if( sqlite3_strglob("sz=[0-9]*", z)==0 ){
+        int sz = sqlite3Atoi(z+3);
+        if( sz<2 ) sz = 2;
         pIndex->szIdxRow = sqlite3LogEst(sqlite3Atoi(z+3));
       }else if( sqlite3_strglob("noskipscan*", z)==0 ){
         pIndex->noSkipScan = 1;
@@ -142345,6 +142347,7 @@
     ** it to pNew->rRun, which is currently set to the cost of the index
     ** seek only. Then, if this is a non-covering index, add the cost of
     ** visiting the rows in the main table.  */
+    assert( pSrc->pTab->szTabRow>0 );
     rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)/pSrc->pTab->szTabRow;
     pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);
     if( (pNew->wsFlags & (WHERE_IDX_ONLY|WHERE_IPK))==0 ){
