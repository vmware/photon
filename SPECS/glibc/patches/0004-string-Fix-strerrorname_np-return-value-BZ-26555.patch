From 69beb5cbf85cae1c61fe7432500ac10880dc7b07 Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Mon, 31 Aug 2020 11:53:51 -0300
Subject: [PATCH 004/124] string: Fix strerrorname_np return value [BZ #26555]

It returns the string of the error constant, not its description (as
strerrordesc_np).  To handle the Hurd error mapping, the ERR_MAP was
removed from errlist.h to errlist.c.

Also, the testcase test-strerr (added on 325081b9eb2) was not added
on the check build neither it builds correctly.  This patch also
changed it to decouple from errlist.h, the expected return values
are added explicitly for both both strerrorname_np and strerrordesc_np
directly.

Checked on x86_64-linux-gnu and i686-linux-gnu.  I also run a make
check for i686-gnu.

(cherry picked from commit cef95fdc2e4002ee6357d8d40ef73c8d875720e3)
---
 NEWS                       |   1 +
 stdio-common/Makefile      |   3 +-
 stdio-common/errlist.c     |  13 +-
 stdio-common/test-strerr.c | 690 +++++++++++++++++++++++++++++++++++--
 sysdeps/gnu/errlist.h      | 301 ++++++++--------
 5 files changed, 819 insertions(+), 189 deletions(-)

diff --git a/NEWS b/NEWS
index a141de93dd0ad5892fa81e865df25e5a190f9abc..3aad30baee635a798d18ccee8b8b7da1dc86b798 100644
--- a/NEWS
+++ b/NEWS
@@ -9,6 +9,7 @@ The following bugs are resolved with this release:
 
   [26534] libm.so 2.32 SIGILL in pow() due to FMA4 instruction on non-FMA4
     system
+  [26555] string: strerrorname_np does not return the documented value
 
 Version 2.32
 
diff --git a/stdio-common/Makefile b/stdio-common/Makefile
index 8475fd1f09d5391c07aaf96e37269107b364d749..eff0c98d821a50cc48635b63df0b1a71179c517c 100644
--- a/stdio-common/Makefile
+++ b/stdio-common/Makefile
@@ -69,7 +69,8 @@ tests := tstscanf test_rdwr test-popen tstgetln test-fseek \
 	 tst-printf-bz25691 \
 	 tst-vfprintf-width-prec-alloc \
 	 tst-printf-fp-free \
-	 tst-printf-fp-leak
+	 tst-printf-fp-leak \
+	 test-strerr
 
 
 test-srcs = tst-unbputc tst-printf tst-printfsz-islongdouble
diff --git a/stdio-common/errlist.c b/stdio-common/errlist.c
index d15f13a22a91cc326d53417da75f27a0f1c5739a..2ecf12167402cd26047c38e045e485fc320bb84c 100644
--- a/stdio-common/errlist.c
+++ b/stdio-common/errlist.c
@@ -20,9 +20,13 @@
 #include <libintl.h>
 #include <array_length.h>
 
+#ifndef ERR_MAP
+# define ERR_MAP(n) n
+#endif
+
 const char *const _sys_errlist_internal[] =
   {
-#define _S(n, str)         [n] = str,
+#define _S(n, str)         [ERR_MAP(n)] = str,
 #include <errlist.h>
 #undef _S
   };
@@ -41,20 +45,21 @@ static const union sys_errname_t
   {
 #define MSGSTRFIELD1(line) str##line
 #define MSGSTRFIELD(line)  MSGSTRFIELD1(line)
-#define _S(n, str)         char MSGSTRFIELD(__LINE__)[sizeof(str)];
+#define _S(n, str)         char MSGSTRFIELD(__LINE__)[sizeof(#n)];
 #include <errlist.h>
 #undef _S
   };
   char str[0];
 } _sys_errname = { {
-#define _S(n, s) s,
+#define _S(n, s) #n,
 #include <errlist.h>
 #undef _S
 } };
 
 static const unsigned short _sys_errnameidx[] =
 {
-#define _S(n, s) [n] = offsetof(union sys_errname_t, MSGSTRFIELD(__LINE__)),
+#define _S(n, s) \
+  [ERR_MAP(n)] = offsetof(union sys_errname_t, MSGSTRFIELD(__LINE__)),
 #include <errlist.h>
 #undef _S
 };
diff --git a/stdio-common/test-strerr.c b/stdio-common/test-strerr.c
index fded2081187e9daaa806b1687c150a328582e02c..d77b81d50712bfab218a3c14556498227b93b3a0 100644
--- a/stdio-common/test-strerr.c
+++ b/stdio-common/test-strerr.c
@@ -18,46 +18,672 @@
 
 #include <string.h>
 #include <errno.h>
-#include <array_length.h>
 
 #include <support/support.h>
 #include <support/check.h>
 
-#define N_(name)      name
-
-static const char *const errlist[] =
-  {
-/* This file is auto-generated from errlist.def.  */
-#include <errlist.h>
-  };
-
-#define MSGSTR_T errname_t
-#define MSGSTR   errname
-#define MSGIDX   errnameidx
-#include <errlist-name.h>
-#undef MSGSTR
-#undef MSGIDX
-
 static int
 do_test (void)
 {
-  TEST_VERIFY (strerrordesc_np (-1) == NULL);
-  TEST_VERIFY (strerrordesc_np (array_length (errlist)) == NULL);
-  for (size_t i = 0; i < array_length (errlist); i++)
-    {
-      if (errlist[i] == NULL)
-        continue;
-      TEST_COMPARE_STRING (strerrordesc_np (i), errlist[i]);
-    }
+  TEST_COMPARE_STRING (strerrordesc_np (0), "Success");
+  TEST_COMPARE_STRING (strerrorname_np (0), "0");
 
-  TEST_VERIFY (strerrorname_np (-1) == NULL);
-  TEST_VERIFY (strerrorname_np (array_length (errlist)) == NULL);
-  for (size_t i = 0; i < array_length (errlist); i++)
-    {
-      if (errlist[i] == NULL)
-        continue;
-      TEST_COMPARE_STRING (strerrorname_np (i), errname.str + errnameidx[i]);
-    }
+#ifdef EPERM
+  TEST_COMPARE_STRING (strerrordesc_np (EPERM), "Operation not permitted");
+  TEST_COMPARE_STRING (strerrorname_np (EPERM), "EPERM");
+#endif
+#ifdef ENOENT
+  TEST_COMPARE_STRING (strerrordesc_np (ENOENT),
+		       "No such file or directory");
+  TEST_COMPARE_STRING (strerrorname_np (ENOENT), "ENOENT");
+#endif
+#ifdef ESRCH
+  TEST_COMPARE_STRING (strerrordesc_np (ESRCH), "No such process");
+  TEST_COMPARE_STRING (strerrorname_np (ESRCH), "ESRCH");
+#endif
+#ifdef EINTR
+  TEST_COMPARE_STRING (strerrordesc_np (EINTR), "Interrupted system call");
+  TEST_COMPARE_STRING (strerrorname_np (EINTR), "EINTR");
+#endif
+#ifdef EIO
+  TEST_COMPARE_STRING (strerrordesc_np (EIO), "Input/output error");
+  TEST_COMPARE_STRING (strerrorname_np (EIO), "EIO");
+#endif
+#ifdef ENXIO
+  TEST_COMPARE_STRING (strerrordesc_np (ENXIO), "No such device or address");
+  TEST_COMPARE_STRING (strerrorname_np (ENXIO), "ENXIO");
+#endif
+#ifdef E2BIG
+  TEST_COMPARE_STRING (strerrordesc_np (E2BIG), "Argument list too long");
+  TEST_COMPARE_STRING (strerrorname_np (E2BIG), "E2BIG");
+#endif
+#ifdef ENOEXEC
+  TEST_COMPARE_STRING (strerrordesc_np (ENOEXEC), "Exec format error");
+  TEST_COMPARE_STRING (strerrorname_np (ENOEXEC), "ENOEXEC");
+#endif
+#ifdef EBADF
+  TEST_COMPARE_STRING (strerrordesc_np (EBADF), "Bad file descriptor");
+  TEST_COMPARE_STRING (strerrorname_np (EBADF), "EBADF");
+#endif
+#ifdef ECHILD
+  TEST_COMPARE_STRING (strerrordesc_np (ECHILD), "No child processes");
+  TEST_COMPARE_STRING (strerrorname_np (ECHILD), "ECHILD");
+#endif
+#ifdef EDEADLK
+  TEST_COMPARE_STRING (strerrordesc_np (EDEADLK),
+		       "Resource deadlock avoided");
+  TEST_COMPARE_STRING (strerrorname_np (EDEADLK), "EDEADLK");
+#endif
+#ifdef ENOMEM
+  TEST_COMPARE_STRING (strerrordesc_np (ENOMEM), "Cannot allocate memory");
+  TEST_COMPARE_STRING (strerrorname_np (ENOMEM), "ENOMEM");
+#endif
+#ifdef EACCES
+  TEST_COMPARE_STRING (strerrordesc_np (EACCES), "Permission denied");
+  TEST_COMPARE_STRING (strerrorname_np (EACCES), "EACCES");
+#endif
+#ifdef EFAULT
+  TEST_COMPARE_STRING (strerrordesc_np (EFAULT), "Bad address");
+  TEST_COMPARE_STRING (strerrorname_np (EFAULT), "EFAULT");
+#endif
+#ifdef ENOTBLK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTBLK), "Block device required");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTBLK), "ENOTBLK");
+#endif
+#ifdef EBUSY
+  TEST_COMPARE_STRING (strerrordesc_np (EBUSY), "Device or resource busy");
+  TEST_COMPARE_STRING (strerrorname_np (EBUSY), "EBUSY");
+#endif
+#ifdef EEXIST
+  TEST_COMPARE_STRING (strerrordesc_np (EEXIST), "File exists");
+  TEST_COMPARE_STRING (strerrorname_np (EEXIST), "EEXIST");
+#endif
+#ifdef EXDEV
+  TEST_COMPARE_STRING (strerrordesc_np (EXDEV), "Invalid cross-device link");
+  TEST_COMPARE_STRING (strerrorname_np (EXDEV), "EXDEV");
+#endif
+#ifdef ENODEV
+  TEST_COMPARE_STRING (strerrordesc_np (ENODEV), "No such device");
+  TEST_COMPARE_STRING (strerrorname_np (ENODEV), "ENODEV");
+#endif
+#ifdef ENOTDIR
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTDIR), "Not a directory");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTDIR), "ENOTDIR");
+#endif
+#ifdef EISDIR
+  TEST_COMPARE_STRING (strerrordesc_np (EISDIR), "Is a directory");
+  TEST_COMPARE_STRING (strerrorname_np (EISDIR), "EISDIR");
+#endif
+#ifdef EINVAL
+  TEST_COMPARE_STRING (strerrordesc_np (EINVAL), "Invalid argument");
+  TEST_COMPARE_STRING (strerrorname_np (EINVAL), "EINVAL");
+#endif
+#ifdef EMFILE
+  TEST_COMPARE_STRING (strerrordesc_np (EMFILE), "Too many open files");
+  TEST_COMPARE_STRING (strerrorname_np (EMFILE), "EMFILE");
+#endif
+#ifdef ENFILE
+  TEST_COMPARE_STRING (strerrordesc_np (ENFILE),
+		       "Too many open files in system");
+  TEST_COMPARE_STRING (strerrorname_np (ENFILE), "ENFILE");
+#endif
+#ifdef ENOTTY
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTTY),
+		       "Inappropriate ioctl for device");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTTY), "ENOTTY");
+#endif
+#ifdef ETXTBSY
+  TEST_COMPARE_STRING (strerrordesc_np (ETXTBSY), "Text file busy");
+  TEST_COMPARE_STRING (strerrorname_np (ETXTBSY), "ETXTBSY");
+#endif
+#ifdef EFBIG
+  TEST_COMPARE_STRING (strerrordesc_np (EFBIG), "File too large");
+  TEST_COMPARE_STRING (strerrorname_np (EFBIG), "EFBIG");
+#endif
+#ifdef ENOSPC
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSPC), "No space left on device");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSPC), "ENOSPC");
+#endif
+#ifdef ESPIPE
+  TEST_COMPARE_STRING (strerrordesc_np (ESPIPE), "Illegal seek");
+  TEST_COMPARE_STRING (strerrorname_np (ESPIPE), "ESPIPE");
+#endif
+#ifdef EROFS
+  TEST_COMPARE_STRING (strerrordesc_np (EROFS), "Read-only file system");
+  TEST_COMPARE_STRING (strerrorname_np (EROFS), "EROFS");
+#endif
+#ifdef EMLINK
+  TEST_COMPARE_STRING (strerrordesc_np (EMLINK), "Too many links");
+  TEST_COMPARE_STRING (strerrorname_np (EMLINK), "EMLINK");
+#endif
+#ifdef EPIPE
+  TEST_COMPARE_STRING (strerrordesc_np (EPIPE), "Broken pipe");
+  TEST_COMPARE_STRING (strerrorname_np (EPIPE), "EPIPE");
+#endif
+#ifdef EDOM
+  TEST_COMPARE_STRING (strerrordesc_np (EDOM),
+		       "Numerical argument out of domain");
+  TEST_COMPARE_STRING (strerrorname_np (EDOM), "EDOM");
+#endif
+#ifdef ERANGE
+  TEST_COMPARE_STRING (strerrordesc_np (ERANGE),
+		       "Numerical result out of range");
+  TEST_COMPARE_STRING (strerrorname_np (ERANGE), "ERANGE");
+#endif
+#ifdef EAGAIN
+  TEST_COMPARE_STRING (strerrordesc_np (EAGAIN),
+		       "Resource temporarily unavailable");
+  TEST_COMPARE_STRING (strerrorname_np (EAGAIN), "EAGAIN");
+#endif
+#ifdef EINPROGRESS
+  TEST_COMPARE_STRING (strerrordesc_np (EINPROGRESS),
+		       "Operation now in progress");
+  TEST_COMPARE_STRING (strerrorname_np (EINPROGRESS), "EINPROGRESS");
+#endif
+#ifdef EALREADY
+  TEST_COMPARE_STRING (strerrordesc_np (EALREADY),
+		       "Operation already in progress");
+  TEST_COMPARE_STRING (strerrorname_np (EALREADY), "EALREADY");
+#endif
+#ifdef ENOTSOCK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTSOCK),
+		       "Socket operation on non-socket");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTSOCK), "ENOTSOCK");
+#endif
+#ifdef EMSGSIZE
+  TEST_COMPARE_STRING (strerrordesc_np (EMSGSIZE), "Message too long");
+  TEST_COMPARE_STRING (strerrorname_np (EMSGSIZE), "EMSGSIZE");
+#endif
+#ifdef EPROTOTYPE
+  TEST_COMPARE_STRING (strerrordesc_np (EPROTOTYPE),
+		       "Protocol wrong type for socket");
+  TEST_COMPARE_STRING (strerrorname_np (EPROTOTYPE), "EPROTOTYPE");
+#endif
+#ifdef ENOPROTOOPT
+  TEST_COMPARE_STRING (strerrordesc_np (ENOPROTOOPT),
+		       "Protocol not available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOPROTOOPT), "ENOPROTOOPT");
+#endif
+#ifdef EPROTONOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (EPROTONOSUPPORT),
+		       "Protocol not supported");
+  TEST_COMPARE_STRING (strerrorname_np (EPROTONOSUPPORT), "EPROTONOSUPPORT");
+#endif
+#ifdef ESOCKTNOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (ESOCKTNOSUPPORT),
+		       "Socket type not supported");
+  TEST_COMPARE_STRING (strerrorname_np (ESOCKTNOSUPPORT), "ESOCKTNOSUPPORT");
+#endif
+#ifdef EOPNOTSUPP
+  TEST_COMPARE_STRING (strerrordesc_np (EOPNOTSUPP),
+		       "Operation not supported");
+  TEST_COMPARE_STRING (strerrorname_np (EOPNOTSUPP), "EOPNOTSUPP");
+#endif
+#ifdef EPFNOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (EPFNOSUPPORT),
+		       "Protocol family not supported");
+  TEST_COMPARE_STRING (strerrorname_np (EPFNOSUPPORT), "EPFNOSUPPORT");
+#endif
+#ifdef EAFNOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (EAFNOSUPPORT),
+		       "Address family not supported by protocol");
+  TEST_COMPARE_STRING (strerrorname_np (EAFNOSUPPORT), "EAFNOSUPPORT");
+#endif
+#ifdef EADDRINUSE
+  TEST_COMPARE_STRING (strerrordesc_np (EADDRINUSE),
+		       "Address already in use");
+  TEST_COMPARE_STRING (strerrorname_np (EADDRINUSE), "EADDRINUSE");
+#endif
+#ifdef EADDRNOTAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (EADDRNOTAVAIL),
+		       "Cannot assign requested address");
+  TEST_COMPARE_STRING (strerrorname_np (EADDRNOTAVAIL), "EADDRNOTAVAIL");
+#endif
+#ifdef ENETDOWN
+  TEST_COMPARE_STRING (strerrordesc_np (ENETDOWN), "Network is down");
+  TEST_COMPARE_STRING (strerrorname_np (ENETDOWN), "ENETDOWN");
+#endif
+#ifdef ENETUNREACH
+  TEST_COMPARE_STRING (strerrordesc_np (ENETUNREACH),
+		       "Network is unreachable");
+  TEST_COMPARE_STRING (strerrorname_np (ENETUNREACH), "ENETUNREACH");
+#endif
+#ifdef ENETRESET
+  TEST_COMPARE_STRING (strerrordesc_np (ENETRESET),
+		       "Network dropped connection on reset");
+  TEST_COMPARE_STRING (strerrorname_np (ENETRESET), "ENETRESET");
+#endif
+#ifdef ECONNABORTED
+  TEST_COMPARE_STRING (strerrordesc_np (ECONNABORTED),
+		       "Software caused connection abort");
+  TEST_COMPARE_STRING (strerrorname_np (ECONNABORTED), "ECONNABORTED");
+#endif
+#ifdef ECONNRESET
+  TEST_COMPARE_STRING (strerrordesc_np (ECONNRESET),
+		       "Connection reset by peer");
+  TEST_COMPARE_STRING (strerrorname_np (ECONNRESET), "ECONNRESET");
+#endif
+#ifdef ENOBUFS
+  TEST_COMPARE_STRING (strerrordesc_np (ENOBUFS),
+		       "No buffer space available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOBUFS), "ENOBUFS");
+#endif
+#ifdef EISCONN
+  TEST_COMPARE_STRING (strerrordesc_np (EISCONN),
+		       "Transport endpoint is already connected");
+  TEST_COMPARE_STRING (strerrorname_np (EISCONN), "EISCONN");
+#endif
+#ifdef ENOTCONN
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTCONN),
+		       "Transport endpoint is not connected");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTCONN), "ENOTCONN");
+#endif
+#ifdef EDESTADDRREQ
+  TEST_COMPARE_STRING (strerrordesc_np (EDESTADDRREQ),
+		       "Destination address required");
+  TEST_COMPARE_STRING (strerrorname_np (EDESTADDRREQ), "EDESTADDRREQ");
+#endif
+#ifdef ESHUTDOWN
+  TEST_COMPARE_STRING (strerrordesc_np (ESHUTDOWN),
+		       "Cannot send after transport endpoint shutdown");
+  TEST_COMPARE_STRING (strerrorname_np (ESHUTDOWN), "ESHUTDOWN");
+#endif
+#ifdef ETOOMANYREFS
+  TEST_COMPARE_STRING (strerrordesc_np (ETOOMANYREFS),
+		       "Too many references: cannot splice");
+  TEST_COMPARE_STRING (strerrorname_np (ETOOMANYREFS), "ETOOMANYREFS");
+#endif
+#ifdef ETIMEDOUT
+  TEST_COMPARE_STRING (strerrordesc_np (ETIMEDOUT), "Connection timed out");
+  TEST_COMPARE_STRING (strerrorname_np (ETIMEDOUT), "ETIMEDOUT");
+#endif
+#ifdef ECONNREFUSED
+  TEST_COMPARE_STRING (strerrordesc_np (ECONNREFUSED), "Connection refused");
+  TEST_COMPARE_STRING (strerrorname_np (ECONNREFUSED), "ECONNREFUSED");
+#endif
+#ifdef ELOOP
+  TEST_COMPARE_STRING (strerrordesc_np (ELOOP),
+		       "Too many levels of symbolic links");
+  TEST_COMPARE_STRING (strerrorname_np (ELOOP), "ELOOP");
+#endif
+#ifdef ENAMETOOLONG
+  TEST_COMPARE_STRING (strerrordesc_np (ENAMETOOLONG), "File name too long");
+  TEST_COMPARE_STRING (strerrorname_np (ENAMETOOLONG), "ENAMETOOLONG");
+#endif
+#ifdef EHOSTDOWN
+  TEST_COMPARE_STRING (strerrordesc_np (EHOSTDOWN), "Host is down");
+  TEST_COMPARE_STRING (strerrorname_np (EHOSTDOWN), "EHOSTDOWN");
+#endif
+#ifdef EHOSTUNREACH
+  TEST_COMPARE_STRING (strerrordesc_np (EHOSTUNREACH), "No route to host");
+  TEST_COMPARE_STRING (strerrorname_np (EHOSTUNREACH), "EHOSTUNREACH");
+#endif
+#ifdef ENOTEMPTY
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTEMPTY), "Directory not empty");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTEMPTY), "ENOTEMPTY");
+#endif
+#ifdef EUSERS
+  TEST_COMPARE_STRING (strerrordesc_np (EUSERS), "Too many users");
+  TEST_COMPARE_STRING (strerrorname_np (EUSERS), "EUSERS");
+#endif
+#ifdef EDQUOT
+  TEST_COMPARE_STRING (strerrordesc_np (EDQUOT), "Disk quota exceeded");
+  TEST_COMPARE_STRING (strerrorname_np (EDQUOT), "EDQUOT");
+#endif
+#ifdef ESTALE
+  TEST_COMPARE_STRING (strerrordesc_np (ESTALE), "Stale file handle");
+  TEST_COMPARE_STRING (strerrorname_np (ESTALE), "ESTALE");
+#endif
+#ifdef EREMOTE
+  TEST_COMPARE_STRING (strerrordesc_np (EREMOTE), "Object is remote");
+  TEST_COMPARE_STRING (strerrorname_np (EREMOTE), "EREMOTE");
+#endif
+#ifdef ENOLCK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOLCK), "No locks available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOLCK), "ENOLCK");
+#endif
+#ifdef ENOSYS
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSYS), "Function not implemented");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSYS), "ENOSYS");
+#endif
+#ifdef EILSEQ
+  TEST_COMPARE_STRING (strerrordesc_np (EILSEQ),
+		       "Invalid or incomplete multibyte or wide character");
+  TEST_COMPARE_STRING (strerrorname_np (EILSEQ), "EILSEQ");
+#endif
+#ifdef EBADMSG
+  TEST_COMPARE_STRING (strerrordesc_np (EBADMSG), "Bad message");
+  TEST_COMPARE_STRING (strerrorname_np (EBADMSG), "EBADMSG");
+#endif
+#ifdef EIDRM
+  TEST_COMPARE_STRING (strerrordesc_np (EIDRM), "Identifier removed");
+  TEST_COMPARE_STRING (strerrorname_np (EIDRM), "EIDRM");
+#endif
+#ifdef EMULTIHOP
+  TEST_COMPARE_STRING (strerrordesc_np (EMULTIHOP), "Multihop attempted");
+  TEST_COMPARE_STRING (strerrorname_np (EMULTIHOP), "EMULTIHOP");
+#endif
+#ifdef ENODATA
+  TEST_COMPARE_STRING (strerrordesc_np (ENODATA), "No data available");
+  TEST_COMPARE_STRING (strerrorname_np (ENODATA), "ENODATA");
+#endif
+#ifdef ENOLINK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOLINK), "Link has been severed");
+  TEST_COMPARE_STRING (strerrorname_np (ENOLINK), "ENOLINK");
+#endif
+#ifdef ENOMSG
+  TEST_COMPARE_STRING (strerrordesc_np (ENOMSG),
+		       "No message of desired type");
+  TEST_COMPARE_STRING (strerrorname_np (ENOMSG), "ENOMSG");
+#endif
+#ifdef ENOSR
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSR), "Out of streams resources");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSR), "ENOSR");
+#endif
+#ifdef ENOSTR
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSTR), "Device not a stream");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSTR), "ENOSTR");
+#endif
+#ifdef EOVERFLOW
+  TEST_COMPARE_STRING (strerrordesc_np (EOVERFLOW),
+		       "Value too large for defined data type");
+  TEST_COMPARE_STRING (strerrorname_np (EOVERFLOW), "EOVERFLOW");
+#endif
+#ifdef EPROTO
+  TEST_COMPARE_STRING (strerrordesc_np (EPROTO), "Protocol error");
+  TEST_COMPARE_STRING (strerrorname_np (EPROTO), "EPROTO");
+#endif
+#ifdef ETIME
+  TEST_COMPARE_STRING (strerrordesc_np (ETIME), "Timer expired");
+  TEST_COMPARE_STRING (strerrorname_np (ETIME), "ETIME");
+#endif
+#ifdef ECANCELED
+  TEST_COMPARE_STRING (strerrordesc_np (ECANCELED), "Operation canceled");
+  TEST_COMPARE_STRING (strerrorname_np (ECANCELED), "ECANCELED");
+#endif
+#ifdef EOWNERDEAD
+  TEST_COMPARE_STRING (strerrordesc_np (EOWNERDEAD), "Owner died");
+  TEST_COMPARE_STRING (strerrorname_np (EOWNERDEAD), "EOWNERDEAD");
+#endif
+#ifdef ENOTRECOVERABLE
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTRECOVERABLE),
+		       "State not recoverable");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTRECOVERABLE), "ENOTRECOVERABLE");
+#endif
+#ifdef ERESTART
+  TEST_COMPARE_STRING (strerrordesc_np (ERESTART),
+		       "Interrupted system call should be restarted");
+  TEST_COMPARE_STRING (strerrorname_np (ERESTART), "ERESTART");
+#endif
+#ifdef ECHRNG
+  TEST_COMPARE_STRING (strerrordesc_np (ECHRNG),
+		       "Channel number out of range");
+  TEST_COMPARE_STRING (strerrorname_np (ECHRNG), "ECHRNG");
+#endif
+#ifdef EL2NSYNC
+  TEST_COMPARE_STRING (strerrordesc_np (EL2NSYNC),
+		       "Level 2 not synchronized");
+  TEST_COMPARE_STRING (strerrorname_np (EL2NSYNC), "EL2NSYNC");
+#endif
+#ifdef EL3HLT
+  TEST_COMPARE_STRING (strerrordesc_np (EL3HLT), "Level 3 halted");
+  TEST_COMPARE_STRING (strerrorname_np (EL3HLT), "EL3HLT");
+#endif
+#ifdef EL3RST
+  TEST_COMPARE_STRING (strerrordesc_np (EL3RST), "Level 3 reset");
+  TEST_COMPARE_STRING (strerrorname_np (EL3RST), "EL3RST");
+#endif
+#ifdef ELNRNG
+  TEST_COMPARE_STRING (strerrordesc_np (ELNRNG), "Link number out of range");
+  TEST_COMPARE_STRING (strerrorname_np (ELNRNG), "ELNRNG");
+#endif
+#ifdef EUNATCH
+  TEST_COMPARE_STRING (strerrordesc_np (EUNATCH),
+		       "Protocol driver not attached");
+  TEST_COMPARE_STRING (strerrorname_np (EUNATCH), "EUNATCH");
+#endif
+#ifdef ENOCSI
+  TEST_COMPARE_STRING (strerrordesc_np (ENOCSI),
+		       "No CSI structure available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOCSI), "ENOCSI");
+#endif
+#ifdef EL2HLT
+  TEST_COMPARE_STRING (strerrordesc_np (EL2HLT), "Level 2 halted");
+  TEST_COMPARE_STRING (strerrorname_np (EL2HLT), "EL2HLT");
+#endif
+#ifdef EBADE
+  TEST_COMPARE_STRING (strerrordesc_np (EBADE), "Invalid exchange");
+  TEST_COMPARE_STRING (strerrorname_np (EBADE), "EBADE");
+#endif
+#ifdef EBADR
+  TEST_COMPARE_STRING (strerrordesc_np (EBADR),
+		       "Invalid request descriptor");
+  TEST_COMPARE_STRING (strerrorname_np (EBADR), "EBADR");
+#endif
+#ifdef EXFULL
+  TEST_COMPARE_STRING (strerrordesc_np (EXFULL), "Exchange full");
+  TEST_COMPARE_STRING (strerrorname_np (EXFULL), "EXFULL");
+#endif
+#ifdef ENOANO
+  TEST_COMPARE_STRING (strerrordesc_np (ENOANO), "No anode");
+  TEST_COMPARE_STRING (strerrorname_np (ENOANO), "ENOANO");
+#endif
+#ifdef EBADRQC
+  TEST_COMPARE_STRING (strerrordesc_np (EBADRQC), "Invalid request code");
+  TEST_COMPARE_STRING (strerrorname_np (EBADRQC), "EBADRQC");
+#endif
+#ifdef EBADSLT
+  TEST_COMPARE_STRING (strerrordesc_np (EBADSLT), "Invalid slot");
+  TEST_COMPARE_STRING (strerrorname_np (EBADSLT), "EBADSLT");
+#endif
+#ifdef EBFONT
+  TEST_COMPARE_STRING (strerrordesc_np (EBFONT), "Bad font file format");
+  TEST_COMPARE_STRING (strerrorname_np (EBFONT), "EBFONT");
+#endif
+#ifdef ENONET
+  TEST_COMPARE_STRING (strerrordesc_np (ENONET),
+		       "Machine is not on the network");
+  TEST_COMPARE_STRING (strerrorname_np (ENONET), "ENONET");
+#endif
+#ifdef ENOPKG
+  TEST_COMPARE_STRING (strerrordesc_np (ENOPKG), "Package not installed");
+  TEST_COMPARE_STRING (strerrorname_np (ENOPKG), "ENOPKG");
+#endif
+#ifdef EADV
+  TEST_COMPARE_STRING (strerrordesc_np (EADV), "Advertise error");
+  TEST_COMPARE_STRING (strerrorname_np (EADV), "EADV");
+#endif
+#ifdef ESRMNT
+  TEST_COMPARE_STRING (strerrordesc_np (ESRMNT), "Srmount error");
+  TEST_COMPARE_STRING (strerrorname_np (ESRMNT), "ESRMNT");
+#endif
+#ifdef ECOMM
+  TEST_COMPARE_STRING (strerrordesc_np (ECOMM),
+		       "Communication error on send");
+  TEST_COMPARE_STRING (strerrorname_np (ECOMM), "ECOMM");
+#endif
+#ifdef EDOTDOT
+  TEST_COMPARE_STRING (strerrordesc_np (EDOTDOT), "RFS specific error");
+  TEST_COMPARE_STRING (strerrorname_np (EDOTDOT), "EDOTDOT");
+#endif
+#ifdef ENOTUNIQ
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTUNIQ),
+		       "Name not unique on network");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTUNIQ), "ENOTUNIQ");
+#endif
+#ifdef EBADFD
+  TEST_COMPARE_STRING (strerrordesc_np (EBADFD),
+		       "File descriptor in bad state");
+  TEST_COMPARE_STRING (strerrorname_np (EBADFD), "EBADFD");
+#endif
+#ifdef EREMCHG
+  TEST_COMPARE_STRING (strerrordesc_np (EREMCHG), "Remote address changed");
+  TEST_COMPARE_STRING (strerrorname_np (EREMCHG), "EREMCHG");
+#endif
+#ifdef ELIBACC
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBACC),
+		       "Can not access a needed shared library");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBACC), "ELIBACC");
+#endif
+#ifdef ELIBBAD
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBBAD),
+		       "Accessing a corrupted shared library");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBBAD), "ELIBBAD");
+#endif
+#ifdef ELIBSCN
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBSCN),
+		       ".lib section in a.out corrupted");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBSCN), "ELIBSCN");
+#endif
+#ifdef ELIBMAX
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBMAX),
+		       "Attempting to link in too many shared libraries");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBMAX), "ELIBMAX");
+#endif
+#ifdef ELIBEXEC
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBEXEC),
+		       "Cannot exec a shared library directly");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBEXEC), "ELIBEXEC");
+#endif
+#ifdef ESTRPIPE
+  TEST_COMPARE_STRING (strerrordesc_np (ESTRPIPE), "Streams pipe error");
+  TEST_COMPARE_STRING (strerrorname_np (ESTRPIPE), "ESTRPIPE");
+#endif
+#ifdef EUCLEAN
+  TEST_COMPARE_STRING (strerrordesc_np (EUCLEAN),
+		       "Structure needs cleaning");
+  TEST_COMPARE_STRING (strerrorname_np (EUCLEAN), "EUCLEAN");
+#endif
+#ifdef ENOTNAM
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTNAM),
+		       "Not a XENIX named type file");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTNAM), "ENOTNAM");
+#endif
+#ifdef ENAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (ENAVAIL),
+		       "No XENIX semaphores available");
+  TEST_COMPARE_STRING (strerrorname_np (ENAVAIL), "ENAVAIL");
+#endif
+#ifdef EISNAM
+  TEST_COMPARE_STRING (strerrordesc_np (EISNAM), "Is a named type file");
+  TEST_COMPARE_STRING (strerrorname_np (EISNAM), "EISNAM");
+#endif
+#ifdef EREMOTEIO
+  TEST_COMPARE_STRING (strerrordesc_np (EREMOTEIO), "Remote I/O error");
+  TEST_COMPARE_STRING (strerrorname_np (EREMOTEIO), "EREMOTEIO");
+#endif
+#ifdef ENOMEDIUM
+  TEST_COMPARE_STRING (strerrordesc_np (ENOMEDIUM), "No medium found");
+  TEST_COMPARE_STRING (strerrorname_np (ENOMEDIUM), "ENOMEDIUM");
+#endif
+#ifdef EMEDIUMTYPE
+  TEST_COMPARE_STRING (strerrordesc_np (EMEDIUMTYPE), "Wrong medium type");
+  TEST_COMPARE_STRING (strerrorname_np (EMEDIUMTYPE), "EMEDIUMTYPE");
+#endif
+#ifdef ENOKEY
+  TEST_COMPARE_STRING (strerrordesc_np (ENOKEY),
+		       "Required key not available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOKEY), "ENOKEY");
+#endif
+#ifdef EKEYEXPIRED
+  TEST_COMPARE_STRING (strerrordesc_np (EKEYEXPIRED), "Key has expired");
+  TEST_COMPARE_STRING (strerrorname_np (EKEYEXPIRED), "EKEYEXPIRED");
+#endif
+#ifdef EKEYREVOKED
+  TEST_COMPARE_STRING (strerrordesc_np (EKEYREVOKED),
+		       "Key has been revoked");
+  TEST_COMPARE_STRING (strerrorname_np (EKEYREVOKED), "EKEYREVOKED");
+#endif
+#ifdef EKEYREJECTED
+  TEST_COMPARE_STRING (strerrordesc_np (EKEYREJECTED),
+		       "Key was rejected by service");
+  TEST_COMPARE_STRING (strerrorname_np (EKEYREJECTED), "EKEYREJECTED");
+#endif
+#ifdef ERFKILL
+  TEST_COMPARE_STRING (strerrordesc_np (ERFKILL),
+		       "Operation not possible due to RF-kill");
+  TEST_COMPARE_STRING (strerrorname_np (ERFKILL), "ERFKILL");
+#endif
+#ifdef EHWPOISON
+  TEST_COMPARE_STRING (strerrordesc_np (EHWPOISON),
+		       "Memory page has hardware error");
+  TEST_COMPARE_STRING (strerrorname_np (EHWPOISON), "EHWPOISON");
+#endif
+#ifdef EBADRPC
+  TEST_COMPARE_STRING (strerrordesc_np (EBADRPC), "RPC struct is bad");
+  TEST_COMPARE_STRING (strerrorname_np (EBADRPC), "EBADRPC");
+#endif
+#ifdef EFTYPE
+  TEST_COMPARE_STRING (strerrordesc_np (EFTYPE),
+		       "Inappropriate file type or format");
+  TEST_COMPARE_STRING (strerrorname_np (EFTYPE), "EFTYPE");
+#endif
+#ifdef EPROCUNAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (EPROCUNAVAIL),
+		       "RPC bad procedure for program");
+  TEST_COMPARE_STRING (strerrorname_np (EPROCUNAVAIL), "EPROCUNAVAIL");
+#endif
+#ifdef EAUTH
+  TEST_COMPARE_STRING (strerrordesc_np (EAUTH), "Authentication error");
+  TEST_COMPARE_STRING (strerrorname_np (EAUTH), "EAUTH");
+#endif
+#ifdef EDIED
+  TEST_COMPARE_STRING (strerrordesc_np (EDIED), "Translator died");
+  TEST_COMPARE_STRING (strerrorname_np (EDIED), "EDIED");
+#endif
+#ifdef ERPCMISMATCH
+  TEST_COMPARE_STRING (strerrordesc_np (ERPCMISMATCH), "RPC version wrong");
+  TEST_COMPARE_STRING (strerrorname_np (ERPCMISMATCH), "ERPCMISMATCH");
+#endif
+#ifdef EGREGIOUS
+  TEST_COMPARE_STRING (strerrordesc_np (EGREGIOUS),
+		       "You really blew it this time");
+  TEST_COMPARE_STRING (strerrorname_np (EGREGIOUS), "EGREGIOUS");
+#endif
+#ifdef EPROCLIM
+  TEST_COMPARE_STRING (strerrordesc_np (EPROCLIM), "Too many processes");
+  TEST_COMPARE_STRING (strerrorname_np (EPROCLIM), "EPROCLIM");
+#endif
+#ifdef EGRATUITOUS
+  TEST_COMPARE_STRING (strerrordesc_np (EGRATUITOUS), "Gratuitous error");
+  TEST_COMPARE_STRING (strerrorname_np (EGRATUITOUS), "EGRATUITOUS");
+#endif
+#if defined (ENOTSUP) && ENOTSUP != EOPNOTSUPP
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTSUP), "Not supported");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTSUP), "ENOTSUP");
+#endif
+#ifdef EPROGMISMATCH
+  TEST_COMPARE_STRING (strerrordesc_np (EPROGMISMATCH),
+		       "RPC program version wrong");
+  TEST_COMPARE_STRING (strerrorname_np (EPROGMISMATCH), "EPROGMISMATCH");
+#endif
+#ifdef EBACKGROUND
+  TEST_COMPARE_STRING (strerrordesc_np (EBACKGROUND),
+		       "Inappropriate operation for background process");
+  TEST_COMPARE_STRING (strerrorname_np (EBACKGROUND), "EBACKGROUND");
+#endif
+#ifdef EIEIO
+  TEST_COMPARE_STRING (strerrordesc_np (EIEIO), "Computer bought the farm");
+  TEST_COMPARE_STRING (strerrorname_np (EIEIO), "EIEIO");
+#endif
+#if defined (EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
+  TEST_COMPARE_STRING (strerrordesc_np (EWOULDBLOCK),
+		       "Operation would block");
+  TEST_COMPARE_STRING (strerrorname_np (EWOULDBLOCK), "EWOULDBLOCK");
+#endif
+#ifdef ENEEDAUTH
+  TEST_COMPARE_STRING (strerrordesc_np (ENEEDAUTH), "Need authenticator");
+  TEST_COMPARE_STRING (strerrorname_np (ENEEDAUTH), "ENEEDAUTH");
+#endif
+#ifdef ED
+  TEST_COMPARE_STRING (strerrordesc_np (ED), "?");
+  TEST_COMPARE_STRING (strerrorname_np (ED), "ED");
+#endif
+#ifdef EPROGUNAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (EPROGUNAVAIL),
+		       "RPC program not available");
+  TEST_COMPARE_STRING (strerrorname_np (EPROGUNAVAIL), "EPROGUNAVAIL");
+#endif
 
   return 0;
 }
diff --git a/sysdeps/gnu/errlist.h b/sysdeps/gnu/errlist.h
index 5d11ed723d1b0b8e056855906d1aa0d5e0e9cb0e..6329e5f393edac2689e7304f04cfa81ce080242c 100644
--- a/sysdeps/gnu/errlist.h
+++ b/sysdeps/gnu/errlist.h
@@ -1,24 +1,21 @@
-#ifndef ERR_MAP
-#define ERR_MAP(value) value
-#endif
-_S(ERR_MAP(0), N_("Success"))
+_S(0, N_("Success"))
 #ifdef EPERM
 /*
 TRANS Only the owner of the file (or other resource)
 TRANS or processes with special privileges can perform the operation. */
-_S(ERR_MAP(EPERM), N_("Operation not permitted"))
+_S(EPERM, N_("Operation not permitted"))
 #endif
 #ifdef ENOENT
 /*
 TRANS This is a ``file doesn't exist'' error
 TRANS for ordinary files that are referenced in contexts where they are
 TRANS expected to already exist. */
-_S(ERR_MAP(ENOENT), N_("No such file or directory"))
+_S(ENOENT, N_("No such file or directory"))
 #endif
 #ifdef ESRCH
 /*
 TRANS No process matches the specified process ID. */
-_S(ERR_MAP(ESRCH), N_("No such process"))
+_S(ESRCH, N_("No such process"))
 #endif
 #ifdef EINTR
 /*
@@ -29,12 +26,12 @@ TRANS
 TRANS You can choose to have functions resume after a signal that is handled,
 TRANS rather than failing with @code{EINTR}; see @ref{Interrupted
 TRANS Primitives}. */
-_S(ERR_MAP(EINTR), N_("Interrupted system call"))
+_S(EINTR, N_("Interrupted system call"))
 #endif
 #ifdef EIO
 /*
 TRANS Usually used for physical read or write errors. */
-_S(ERR_MAP(EIO), N_("Input/output error"))
+_S(EIO, N_("Input/output error"))
 #endif
 #ifdef ENXIO
 /*
@@ -43,7 +40,7 @@ TRANS represented by a file you specified, and it couldn't find the device.
 TRANS This can mean that the device file was installed incorrectly, or that
 TRANS the physical device is missing or not correctly attached to the
 TRANS computer. */
-_S(ERR_MAP(ENXIO), N_("No such device or address"))
+_S(ENXIO, N_("No such device or address"))
 #endif
 #ifdef E2BIG
 /*
@@ -51,27 +48,27 @@ TRANS Used when the arguments passed to a new program
 TRANS being executed with one of the @code{exec} functions (@pxref{Executing a
 TRANS File}) occupy too much memory space.  This condition never arises on
 TRANS @gnuhurdsystems{}. */
-_S(ERR_MAP(E2BIG), N_("Argument list too long"))
+_S(E2BIG, N_("Argument list too long"))
 #endif
 #ifdef ENOEXEC
 /*
 TRANS Invalid executable file format.  This condition is detected by the
 TRANS @code{exec} functions; see @ref{Executing a File}. */
-_S(ERR_MAP(ENOEXEC), N_("Exec format error"))
+_S(ENOEXEC, N_("Exec format error"))
 #endif
 #ifdef EBADF
 /*
 TRANS For example, I/O on a descriptor that has been
 TRANS closed or reading from a descriptor open only for writing (or vice
 TRANS versa). */
-_S(ERR_MAP(EBADF), N_("Bad file descriptor"))
+_S(EBADF, N_("Bad file descriptor"))
 #endif
 #ifdef ECHILD
 /*
 TRANS This error happens on operations that are
 TRANS supposed to manipulate child processes, when there aren't any processes
 TRANS to manipulate. */
-_S(ERR_MAP(ECHILD), N_("No child processes"))
+_S(ECHILD, N_("No child processes"))
 #endif
 #ifdef EDEADLK
 /*
@@ -79,74 +76,74 @@ TRANS Allocating a system resource would have resulted in a
 TRANS deadlock situation.  The system does not guarantee that it will notice
 TRANS all such situations.  This error means you got lucky and the system
 TRANS noticed; it might just hang.  @xref{File Locks}, for an example. */
-_S(ERR_MAP(EDEADLK), N_("Resource deadlock avoided"))
+_S(EDEADLK, N_("Resource deadlock avoided"))
 #endif
 #ifdef ENOMEM
 /*
 TRANS The system cannot allocate more virtual memory
 TRANS because its capacity is full. */
-_S(ERR_MAP(ENOMEM), N_("Cannot allocate memory"))
+_S(ENOMEM, N_("Cannot allocate memory"))
 #endif
 #ifdef EACCES
 /*
 TRANS The file permissions do not allow the attempted operation. */
-_S(ERR_MAP(EACCES), N_("Permission denied"))
+_S(EACCES, N_("Permission denied"))
 #endif
 #ifdef EFAULT
 /*
 TRANS An invalid pointer was detected.
 TRANS On @gnuhurdsystems{}, this error never happens; you get a signal instead. */
-_S(ERR_MAP(EFAULT), N_("Bad address"))
+_S(EFAULT, N_("Bad address"))
 #endif
 #ifdef ENOTBLK
 /*
 TRANS A file that isn't a block special file was given in a situation that
 TRANS requires one.  For example, trying to mount an ordinary file as a file
 TRANS system in Unix gives this error. */
-_S(ERR_MAP(ENOTBLK), N_("Block device required"))
+_S(ENOTBLK, N_("Block device required"))
 #endif
 #ifdef EBUSY
 /*
 TRANS A system resource that can't be shared is already in use.
 TRANS For example, if you try to delete a file that is the root of a currently
 TRANS mounted filesystem, you get this error. */
-_S(ERR_MAP(EBUSY), N_("Device or resource busy"))
+_S(EBUSY, N_("Device or resource busy"))
 #endif
 #ifdef EEXIST
 /*
 TRANS An existing file was specified in a context where it only
 TRANS makes sense to specify a new file. */
-_S(ERR_MAP(EEXIST), N_("File exists"))
+_S(EEXIST, N_("File exists"))
 #endif
 #ifdef EXDEV
 /*
 TRANS An attempt to make an improper link across file systems was detected.
 TRANS This happens not only when you use @code{link} (@pxref{Hard Links}) but
 TRANS also when you rename a file with @code{rename} (@pxref{Renaming Files}). */
-_S(ERR_MAP(EXDEV), N_("Invalid cross-device link"))
+_S(EXDEV, N_("Invalid cross-device link"))
 #endif
 #ifdef ENODEV
 /*
 TRANS The wrong type of device was given to a function that expects a
 TRANS particular sort of device. */
-_S(ERR_MAP(ENODEV), N_("No such device"))
+_S(ENODEV, N_("No such device"))
 #endif
 #ifdef ENOTDIR
 /*
 TRANS A file that isn't a directory was specified when a directory is required. */
-_S(ERR_MAP(ENOTDIR), N_("Not a directory"))
+_S(ENOTDIR, N_("Not a directory"))
 #endif
 #ifdef EISDIR
 /*
 TRANS You cannot open a directory for writing,
 TRANS or create or remove hard links to it. */
-_S(ERR_MAP(EISDIR), N_("Is a directory"))
+_S(EISDIR, N_("Is a directory"))
 #endif
 #ifdef EINVAL
 /*
 TRANS This is used to indicate various kinds of problems
 TRANS with passing the wrong argument to a library function. */
-_S(ERR_MAP(EINVAL), N_("Invalid argument"))
+_S(EINVAL, N_("Invalid argument"))
 #endif
 #ifdef EMFILE
 /*
@@ -157,20 +154,20 @@ TRANS In BSD and GNU, the number of open files is controlled by a resource
 TRANS limit that can usually be increased.  If you get this error, you might
 TRANS want to increase the @code{RLIMIT_NOFILE} limit or make it unlimited;
 TRANS @pxref{Limits on Resources}. */
-_S(ERR_MAP(EMFILE), N_("Too many open files"))
+_S(EMFILE, N_("Too many open files"))
 #endif
 #ifdef ENFILE
 /*
 TRANS There are too many distinct file openings in the entire system.  Note
 TRANS that any number of linked channels count as just one file opening; see
 TRANS @ref{Linked Channels}.  This error never occurs on @gnuhurdsystems{}. */
-_S(ERR_MAP(ENFILE), N_("Too many open files in system"))
+_S(ENFILE, N_("Too many open files in system"))
 #endif
 #ifdef ENOTTY
 /*
 TRANS Inappropriate I/O control operation, such as trying to set terminal
 TRANS modes on an ordinary file. */
-_S(ERR_MAP(ENOTTY), N_("Inappropriate ioctl for device"))
+_S(ENOTTY, N_("Inappropriate ioctl for device"))
 #endif
 #ifdef ETXTBSY
 /*
@@ -179,35 +176,35 @@ TRANS write to a file that is currently being executed.  Often using a
 TRANS debugger to run a program is considered having it open for writing and
 TRANS will cause this error.  (The name stands for ``text file busy''.)  This
 TRANS is not an error on @gnuhurdsystems{}; the text is copied as necessary. */
-_S(ERR_MAP(ETXTBSY), N_("Text file busy"))
+_S(ETXTBSY, N_("Text file busy"))
 #endif
 #ifdef EFBIG
 /*
 TRANS The size of a file would be larger than allowed by the system. */
-_S(ERR_MAP(EFBIG), N_("File too large"))
+_S(EFBIG, N_("File too large"))
 #endif
 #ifdef ENOSPC
 /*
 TRANS Write operation on a file failed because the
 TRANS disk is full. */
-_S(ERR_MAP(ENOSPC), N_("No space left on device"))
+_S(ENOSPC, N_("No space left on device"))
 #endif
 #ifdef ESPIPE
 /*
 TRANS Invalid seek operation (such as on a pipe). */
-_S(ERR_MAP(ESPIPE), N_("Illegal seek"))
+_S(ESPIPE, N_("Illegal seek"))
 #endif
 #ifdef EROFS
 /*
 TRANS An attempt was made to modify something on a read-only file system. */
-_S(ERR_MAP(EROFS), N_("Read-only file system"))
+_S(EROFS, N_("Read-only file system"))
 #endif
 #ifdef EMLINK
 /*
 TRANS The link count of a single file would become too large.
 TRANS @code{rename} can cause this error if the file being renamed already has
 TRANS as many links as it can take (@pxref{Renaming Files}). */
-_S(ERR_MAP(EMLINK), N_("Too many links"))
+_S(EMLINK, N_("Too many links"))
 #endif
 #ifdef EPIPE
 /*
@@ -216,19 +213,19 @@ TRANS Every library function that returns this error code also generates a
 TRANS @code{SIGPIPE} signal; this signal terminates the program if not handled
 TRANS or blocked.  Thus, your program will never actually see @code{EPIPE}
 TRANS unless it has handled or blocked @code{SIGPIPE}. */
-_S(ERR_MAP(EPIPE), N_("Broken pipe"))
+_S(EPIPE, N_("Broken pipe"))
 #endif
 #ifdef EDOM
 /*
 TRANS Used by mathematical functions when an argument value does
 TRANS not fall into the domain over which the function is defined. */
-_S(ERR_MAP(EDOM), N_("Numerical argument out of domain"))
+_S(EDOM, N_("Numerical argument out of domain"))
 #endif
 #ifdef ERANGE
 /*
 TRANS Used by mathematical functions when the result value is
 TRANS not representable because of overflow or underflow. */
-_S(ERR_MAP(ERANGE), N_("Numerical result out of range"))
+_S(ERANGE, N_("Numerical result out of range"))
 #endif
 #ifdef EAGAIN
 /*
@@ -261,7 +258,7 @@ TRANS Such shortages are usually fairly serious and affect the whole system,
 TRANS so usually an interactive program should report the error to the user
 TRANS and return to its command loop.
 TRANS @end itemize */
-_S(ERR_MAP(EAGAIN), N_("Resource temporarily unavailable"))
+_S(EAGAIN, N_("Resource temporarily unavailable"))
 #endif
 #ifdef EINPROGRESS
 /*
@@ -273,47 +270,47 @@ TRANS the operation has begun and will take some time.  Attempts to manipulate
 TRANS the object before the call completes return @code{EALREADY}.  You can
 TRANS use the @code{select} function to find out when the pending operation
 TRANS has completed; @pxref{Waiting for I/O}. */
-_S(ERR_MAP(EINPROGRESS), N_("Operation now in progress"))
+_S(EINPROGRESS, N_("Operation now in progress"))
 #endif
 #ifdef EALREADY
 /*
 TRANS An operation is already in progress on an object that has non-blocking
 TRANS mode selected. */
-_S(ERR_MAP(EALREADY), N_("Operation already in progress"))
+_S(EALREADY, N_("Operation already in progress"))
 #endif
 #ifdef ENOTSOCK
 /*
 TRANS A file that isn't a socket was specified when a socket is required. */
-_S(ERR_MAP(ENOTSOCK), N_("Socket operation on non-socket"))
+_S(ENOTSOCK, N_("Socket operation on non-socket"))
 #endif
 #ifdef EMSGSIZE
 /*
 TRANS The size of a message sent on a socket was larger than the supported
 TRANS maximum size. */
-_S(ERR_MAP(EMSGSIZE), N_("Message too long"))
+_S(EMSGSIZE, N_("Message too long"))
 #endif
 #ifdef EPROTOTYPE
 /*
 TRANS The socket type does not support the requested communications protocol. */
-_S(ERR_MAP(EPROTOTYPE), N_("Protocol wrong type for socket"))
+_S(EPROTOTYPE, N_("Protocol wrong type for socket"))
 #endif
 #ifdef ENOPROTOOPT
 /*
 TRANS You specified a socket option that doesn't make sense for the
 TRANS particular protocol being used by the socket.  @xref{Socket Options}. */
-_S(ERR_MAP(ENOPROTOOPT), N_("Protocol not available"))
+_S(ENOPROTOOPT, N_("Protocol not available"))
 #endif
 #ifdef EPROTONOSUPPORT
 /*
 TRANS The socket domain does not support the requested communications protocol
 TRANS (perhaps because the requested protocol is completely invalid).
 TRANS @xref{Creating a Socket}. */
-_S(ERR_MAP(EPROTONOSUPPORT), N_("Protocol not supported"))
+_S(EPROTONOSUPPORT, N_("Protocol not supported"))
 #endif
 #ifdef ESOCKTNOSUPPORT
 /*
 TRANS The socket type is not supported. */
-_S(ERR_MAP(ESOCKTNOSUPPORT), N_("Socket type not supported"))
+_S(ESOCKTNOSUPPORT, N_("Socket type not supported"))
 #endif
 #ifdef EOPNOTSUPP
 /*
@@ -323,71 +320,71 @@ TRANS implemented for all communications protocols.  On @gnuhurdsystems{}, this
 TRANS error can happen for many calls when the object does not support the
 TRANS particular operation; it is a generic indication that the server knows
 TRANS nothing to do for that call. */
-_S(ERR_MAP(EOPNOTSUPP), N_("Operation not supported"))
+_S(EOPNOTSUPP, N_("Operation not supported"))
 #endif
 #ifdef EPFNOSUPPORT
 /*
 TRANS The socket communications protocol family you requested is not supported. */
-_S(ERR_MAP(EPFNOSUPPORT), N_("Protocol family not supported"))
+_S(EPFNOSUPPORT, N_("Protocol family not supported"))
 #endif
 #ifdef EAFNOSUPPORT
 /*
 TRANS The address family specified for a socket is not supported; it is
 TRANS inconsistent with the protocol being used on the socket.  @xref{Sockets}. */
-_S(ERR_MAP(EAFNOSUPPORT), N_("Address family not supported by protocol"))
+_S(EAFNOSUPPORT, N_("Address family not supported by protocol"))
 #endif
 #ifdef EADDRINUSE
 /*
 TRANS The requested socket address is already in use.  @xref{Socket Addresses}. */
-_S(ERR_MAP(EADDRINUSE), N_("Address already in use"))
+_S(EADDRINUSE, N_("Address already in use"))
 #endif
 #ifdef EADDRNOTAVAIL
 /*
 TRANS The requested socket address is not available; for example, you tried
 TRANS to give a socket a name that doesn't match the local host name.
 TRANS @xref{Socket Addresses}. */
-_S(ERR_MAP(EADDRNOTAVAIL), N_("Cannot assign requested address"))
+_S(EADDRNOTAVAIL, N_("Cannot assign requested address"))
 #endif
 #ifdef ENETDOWN
 /*
 TRANS A socket operation failed because the network was down. */
-_S(ERR_MAP(ENETDOWN), N_("Network is down"))
+_S(ENETDOWN, N_("Network is down"))
 #endif
 #ifdef ENETUNREACH
 /*
 TRANS A socket operation failed because the subnet containing the remote host
 TRANS was unreachable. */
-_S(ERR_MAP(ENETUNREACH), N_("Network is unreachable"))
+_S(ENETUNREACH, N_("Network is unreachable"))
 #endif
 #ifdef ENETRESET
 /*
 TRANS A network connection was reset because the remote host crashed. */
-_S(ERR_MAP(ENETRESET), N_("Network dropped connection on reset"))
+_S(ENETRESET, N_("Network dropped connection on reset"))
 #endif
 #ifdef ECONNABORTED
 /*
 TRANS A network connection was aborted locally. */
-_S(ERR_MAP(ECONNABORTED), N_("Software caused connection abort"))
+_S(ECONNABORTED, N_("Software caused connection abort"))
 #endif
 #ifdef ECONNRESET
 /*
 TRANS A network connection was closed for reasons outside the control of the
 TRANS local host, such as by the remote machine rebooting or an unrecoverable
 TRANS protocol violation. */
-_S(ERR_MAP(ECONNRESET), N_("Connection reset by peer"))
+_S(ECONNRESET, N_("Connection reset by peer"))
 #endif
 #ifdef ENOBUFS
 /*
 TRANS The kernel's buffers for I/O operations are all in use.  In GNU, this
 TRANS error is always synonymous with @code{ENOMEM}; you may get one or the
 TRANS other from network operations. */
-_S(ERR_MAP(ENOBUFS), N_("No buffer space available"))
+_S(ENOBUFS, N_("No buffer space available"))
 #endif
 #ifdef EISCONN
 /*
 TRANS You tried to connect a socket that is already connected.
 TRANS @xref{Connecting}. */
-_S(ERR_MAP(EISCONN), N_("Transport endpoint is already connected"))
+_S(EISCONN, N_("Transport endpoint is already connected"))
 #endif
 #ifdef ENOTCONN
 /*
@@ -395,74 +392,74 @@ TRANS The socket is not connected to anything.  You get this error when you
 TRANS try to transmit data over a socket, without first specifying a
 TRANS destination for the data.  For a connectionless socket (for datagram
 TRANS protocols, such as UDP), you get @code{EDESTADDRREQ} instead. */
-_S(ERR_MAP(ENOTCONN), N_("Transport endpoint is not connected"))
+_S(ENOTCONN, N_("Transport endpoint is not connected"))
 #endif
 #ifdef EDESTADDRREQ
 /*
 TRANS No default destination address was set for the socket.  You get this
 TRANS error when you try to transmit data over a connectionless socket,
 TRANS without first specifying a destination for the data with @code{connect}. */
-_S(ERR_MAP(EDESTADDRREQ), N_("Destination address required"))
+_S(EDESTADDRREQ, N_("Destination address required"))
 #endif
 #ifdef ESHUTDOWN
 /*
 TRANS The socket has already been shut down. */
-_S(ERR_MAP(ESHUTDOWN), N_("Cannot send after transport endpoint shutdown"))
+_S(ESHUTDOWN, N_("Cannot send after transport endpoint shutdown"))
 #endif
 #ifdef ETOOMANYREFS
-_S(ERR_MAP(ETOOMANYREFS), N_("Too many references: cannot splice"))
+_S(ETOOMANYREFS, N_("Too many references: cannot splice"))
 #endif
 #ifdef ETIMEDOUT
 /*
 TRANS A socket operation with a specified timeout received no response during
 TRANS the timeout period. */
-_S(ERR_MAP(ETIMEDOUT), N_("Connection timed out"))
+_S(ETIMEDOUT, N_("Connection timed out"))
 #endif
 #ifdef ECONNREFUSED
 /*
 TRANS A remote host refused to allow the network connection (typically because
 TRANS it is not running the requested service). */
-_S(ERR_MAP(ECONNREFUSED), N_("Connection refused"))
+_S(ECONNREFUSED, N_("Connection refused"))
 #endif
 #ifdef ELOOP
 /*
 TRANS Too many levels of symbolic links were encountered in looking up a file name.
 TRANS This often indicates a cycle of symbolic links. */
-_S(ERR_MAP(ELOOP), N_("Too many levels of symbolic links"))
+_S(ELOOP, N_("Too many levels of symbolic links"))
 #endif
 #ifdef ENAMETOOLONG
 /*
 TRANS Filename too long (longer than @code{PATH_MAX}; @pxref{Limits for
 TRANS Files}) or host name too long (in @code{gethostname} or
 TRANS @code{sethostname}; @pxref{Host Identification}). */
-_S(ERR_MAP(ENAMETOOLONG), N_("File name too long"))
+_S(ENAMETOOLONG, N_("File name too long"))
 #endif
 #ifdef EHOSTDOWN
 /*
 TRANS The remote host for a requested network connection is down. */
-_S(ERR_MAP(EHOSTDOWN), N_("Host is down"))
+_S(EHOSTDOWN, N_("Host is down"))
 #endif
 /*
 TRANS The remote host for a requested network connection is not reachable. */
 #ifdef EHOSTUNREACH
-_S(ERR_MAP(EHOSTUNREACH), N_("No route to host"))
+_S(EHOSTUNREACH, N_("No route to host"))
 #endif
 #ifdef ENOTEMPTY
 /*
 TRANS Directory not empty, where an empty directory was expected.  Typically,
 TRANS this error occurs when you are trying to delete a directory. */
-_S(ERR_MAP(ENOTEMPTY), N_("Directory not empty"))
+_S(ENOTEMPTY, N_("Directory not empty"))
 #endif
 #ifdef EUSERS
 /*
 TRANS The file quota system is confused because there are too many users.
 TRANS @c This can probably happen in a GNU system when using NFS. */
-_S(ERR_MAP(EUSERS), N_("Too many users"))
+_S(EUSERS, N_("Too many users"))
 #endif
 #ifdef EDQUOT
 /*
 TRANS The user's disk quota was exceeded. */
-_S(ERR_MAP(EDQUOT), N_("Disk quota exceeded"))
+_S(EDQUOT, N_("Disk quota exceeded"))
 #endif
 #ifdef ESTALE
 /*
@@ -471,7 +468,7 @@ TRANS file system which is due to file system rearrangements on the server host
 TRANS for NFS file systems or corruption in other file systems.
 TRANS Repairing this condition usually requires unmounting, possibly repairing
 TRANS and remounting the file system. */
-_S(ERR_MAP(ESTALE), N_("Stale file handle"))
+_S(ESTALE, N_("Stale file handle"))
 #endif
 #ifdef EREMOTE
 /*
@@ -479,7 +476,7 @@ TRANS An attempt was made to NFS-mount a remote file system with a file name tha
 TRANS already specifies an NFS-mounted file.
 TRANS (This is an error on some operating systems, but we expect it to work
 TRANS properly on @gnuhurdsystems{}, making this error code impossible.) */
-_S(ERR_MAP(EREMOTE), N_("Object is remote"))
+_S(EREMOTE, N_("Object is remote"))
 #endif
 #ifdef ENOLCK
 /*
@@ -487,7 +484,7 @@ TRANS This is used by the file locking facilities; see
 TRANS @ref{File Locks}.  This error is never generated by @gnuhurdsystems{}, but
 TRANS it can result from an operation to an NFS server running another
 TRANS operating system. */
-_S(ERR_MAP(ENOLCK), N_("No locks available"))
+_S(ENOLCK, N_("No locks available"))
 #endif
 #ifdef ENOSYS
 /*
@@ -496,46 +493,46 @@ TRANS not implemented at all, either in the C library itself or in the
 TRANS operating system.  When you get this error, you can be sure that this
 TRANS particular function will always fail with @code{ENOSYS} unless you
 TRANS install a new version of the C library or the operating system. */
-_S(ERR_MAP(ENOSYS), N_("Function not implemented"))
+_S(ENOSYS, N_("Function not implemented"))
 #endif
 #ifdef EILSEQ
 /*
 TRANS While decoding a multibyte character the function came along an invalid
 TRANS or an incomplete sequence of bytes or the given wide character is invalid. */
-_S(ERR_MAP(EILSEQ), N_("Invalid or incomplete multibyte or wide character"))
+_S(EILSEQ, N_("Invalid or incomplete multibyte or wide character"))
 #endif
 #ifdef EBADMSG
-_S(ERR_MAP(EBADMSG), N_("Bad message"))
+_S(EBADMSG, N_("Bad message"))
 #endif
 #ifdef EIDRM
-_S(ERR_MAP(EIDRM), N_("Identifier removed"))
+_S(EIDRM, N_("Identifier removed"))
 #endif
 #ifdef EMULTIHOP
-_S(ERR_MAP(EMULTIHOP), N_("Multihop attempted"))
+_S(EMULTIHOP, N_("Multihop attempted"))
 #endif
 #ifdef ENODATA
-_S(ERR_MAP(ENODATA), N_("No data available"))
+_S(ENODATA, N_("No data available"))
 #endif
 #ifdef ENOLINK
-_S(ERR_MAP(ENOLINK), N_("Link has been severed"))
+_S(ENOLINK, N_("Link has been severed"))
 #endif
 #ifdef ENOMSG
-_S(ERR_MAP(ENOMSG), N_("No message of desired type"))
+_S(ENOMSG, N_("No message of desired type"))
 #endif
 #ifdef ENOSR
-_S(ERR_MAP(ENOSR), N_("Out of streams resources"))
+_S(ENOSR, N_("Out of streams resources"))
 #endif
 #ifdef ENOSTR
-_S(ERR_MAP(ENOSTR), N_("Device not a stream"))
+_S(ENOSTR, N_("Device not a stream"))
 #endif
 #ifdef EOVERFLOW
-_S(ERR_MAP(EOVERFLOW), N_("Value too large for defined data type"))
+_S(EOVERFLOW, N_("Value too large for defined data type"))
 #endif
 #ifdef EPROTO
-_S(ERR_MAP(EPROTO), N_("Protocol error"))
+_S(EPROTO, N_("Protocol error"))
 #endif
 #ifdef ETIME
-_S(ERR_MAP(ETIME), N_("Timer expired"))
+_S(ETIME, N_("Timer expired"))
 #endif
 #ifdef ECANCELED
 /*
@@ -543,148 +540,148 @@ TRANS An asynchronous operation was canceled before it
 TRANS completed.  @xref{Asynchronous I/O}.  When you call @code{aio_cancel},
 TRANS the normal result is for the operations affected to complete with this
 TRANS error; @pxref{Cancel AIO Operations}. */
-_S(ERR_MAP(ECANCELED), N_("Operation canceled"))
+_S(ECANCELED, N_("Operation canceled"))
 #endif
 #ifdef EOWNERDEAD
-_S(ERR_MAP(EOWNERDEAD), N_("Owner died"))
+_S(EOWNERDEAD, N_("Owner died"))
 #endif
 #ifdef ENOTRECOVERABLE
-_S(ERR_MAP(ENOTRECOVERABLE), N_("State not recoverable"))
+_S(ENOTRECOVERABLE, N_("State not recoverable"))
 #endif
 #ifdef ERESTART
-_S(ERR_MAP(ERESTART), N_("Interrupted system call should be restarted"))
+_S(ERESTART, N_("Interrupted system call should be restarted"))
 #endif
 #ifdef ECHRNG
-_S(ERR_MAP(ECHRNG), N_("Channel number out of range"))
+_S(ECHRNG, N_("Channel number out of range"))
 #endif
 #ifdef EL2NSYNC
-_S(ERR_MAP(EL2NSYNC), N_("Level 2 not synchronized"))
+_S(EL2NSYNC, N_("Level 2 not synchronized"))
 #endif
 #ifdef EL3HLT
-_S(ERR_MAP(EL3HLT), N_("Level 3 halted"))
+_S(EL3HLT, N_("Level 3 halted"))
 #endif
 #ifdef EL3RST
-_S(ERR_MAP(EL3RST), N_("Level 3 reset"))
+_S(EL3RST, N_("Level 3 reset"))
 #endif
 #ifdef ELNRNG
-_S(ERR_MAP(ELNRNG), N_("Link number out of range"))
+_S(ELNRNG, N_("Link number out of range"))
 #endif
 #ifdef EUNATCH
-_S(ERR_MAP(EUNATCH), N_("Protocol driver not attached"))
+_S(EUNATCH, N_("Protocol driver not attached"))
 #endif
 #ifdef ENOCSI
-_S(ERR_MAP(ENOCSI), N_("No CSI structure available"))
+_S(ENOCSI, N_("No CSI structure available"))
 #endif
 #ifdef EL2HLT
-_S(ERR_MAP(EL2HLT), N_("Level 2 halted"))
+_S(EL2HLT, N_("Level 2 halted"))
 #endif
 #ifdef EBADE
-_S(ERR_MAP(EBADE), N_("Invalid exchange"))
+_S(EBADE, N_("Invalid exchange"))
 #endif
 #ifdef EBADR
-_S(ERR_MAP(EBADR), N_("Invalid request descriptor"))
+_S(EBADR, N_("Invalid request descriptor"))
 #endif
 #ifdef EXFULL
-_S(ERR_MAP(EXFULL), N_("Exchange full"))
+_S(EXFULL, N_("Exchange full"))
 #endif
 #ifdef ENOANO
-_S(ERR_MAP(ENOANO), N_("No anode"))
+_S(ENOANO, N_("No anode"))
 #endif
 #ifdef EBADRQC
-_S(ERR_MAP(EBADRQC), N_("Invalid request code"))
+_S(EBADRQC, N_("Invalid request code"))
 #endif
 #ifdef EBADSLT
-_S(ERR_MAP(EBADSLT), N_("Invalid slot"))
+_S(EBADSLT, N_("Invalid slot"))
 #endif
 #ifdef EBFONT
-_S(ERR_MAP(EBFONT), N_("Bad font file format"))
+_S(EBFONT, N_("Bad font file format"))
 #endif
 #ifdef ENONET
-_S(ERR_MAP(ENONET), N_("Machine is not on the network"))
+_S(ENONET, N_("Machine is not on the network"))
 #endif
 #ifdef ENOPKG
-_S(ERR_MAP(ENOPKG), N_("Package not installed"))
+_S(ENOPKG, N_("Package not installed"))
 #endif
 #ifdef EADV
-_S(ERR_MAP(EADV), N_("Advertise error"))
+_S(EADV, N_("Advertise error"))
 #endif
 #ifdef ESRMNT
-_S(ERR_MAP(ESRMNT), N_("Srmount error"))
+_S(ESRMNT, N_("Srmount error"))
 #endif
 #ifdef ECOMM
-_S(ERR_MAP(ECOMM), N_("Communication error on send"))
+_S(ECOMM, N_("Communication error on send"))
 #endif
 #ifdef EDOTDOT
-_S(ERR_MAP(EDOTDOT), N_("RFS specific error"))
+_S(EDOTDOT, N_("RFS specific error"))
 #endif
 #ifdef ENOTUNIQ
-_S(ERR_MAP(ENOTUNIQ), N_("Name not unique on network"))
+_S(ENOTUNIQ, N_("Name not unique on network"))
 #endif
 #ifdef EBADFD
-_S(ERR_MAP(EBADFD), N_("File descriptor in bad state"))
+_S(EBADFD, N_("File descriptor in bad state"))
 #endif
 #ifdef EREMCHG
-_S(ERR_MAP(EREMCHG), N_("Remote address changed"))
+_S(EREMCHG, N_("Remote address changed"))
 #endif
 #ifdef ELIBACC
-_S(ERR_MAP(ELIBACC), N_("Can not access a needed shared library"))
+_S(ELIBACC, N_("Can not access a needed shared library"))
 #endif
 #ifdef ELIBBAD
-_S(ERR_MAP(ELIBBAD), N_("Accessing a corrupted shared library"))
+_S(ELIBBAD, N_("Accessing a corrupted shared library"))
 #endif
 #ifdef ELIBSCN
-_S(ERR_MAP(ELIBSCN), N_(".lib section in a.out corrupted"))
+_S(ELIBSCN, N_(".lib section in a.out corrupted"))
 #endif
 #ifdef ELIBMAX
-_S(ERR_MAP(ELIBMAX), N_("Attempting to link in too many shared libraries"))
+_S(ELIBMAX, N_("Attempting to link in too many shared libraries"))
 #endif
 #ifdef ELIBEXEC
-_S(ERR_MAP(ELIBEXEC), N_("Cannot exec a shared library directly"))
+_S(ELIBEXEC, N_("Cannot exec a shared library directly"))
 #endif
 #ifdef ESTRPIPE
-_S(ERR_MAP(ESTRPIPE), N_("Streams pipe error"))
+_S(ESTRPIPE, N_("Streams pipe error"))
 #endif
 #ifdef EUCLEAN
-_S(ERR_MAP(EUCLEAN), N_("Structure needs cleaning"))
+_S(EUCLEAN, N_("Structure needs cleaning"))
 #endif
 #ifdef ENOTNAM
-_S(ERR_MAP(ENOTNAM), N_("Not a XENIX named type file"))
+_S(ENOTNAM, N_("Not a XENIX named type file"))
 #endif
 #ifdef ENAVAIL
-_S(ERR_MAP(ENAVAIL), N_("No XENIX semaphores available"))
+_S(ENAVAIL, N_("No XENIX semaphores available"))
 #endif
 #ifdef EISNAM
-_S(ERR_MAP(EISNAM), N_("Is a named type file"))
+_S(EISNAM, N_("Is a named type file"))
 #endif
 #ifdef EREMOTEIO
-_S(ERR_MAP(EREMOTEIO), N_("Remote I/O error"))
+_S(EREMOTEIO, N_("Remote I/O error"))
 #endif
 #ifdef ENOMEDIUM
-_S(ERR_MAP(ENOMEDIUM), N_("No medium found"))
+_S(ENOMEDIUM, N_("No medium found"))
 #endif
 #ifdef EMEDIUMTYPE
-_S(ERR_MAP(EMEDIUMTYPE), N_("Wrong medium type"))
+_S(EMEDIUMTYPE, N_("Wrong medium type"))
 #endif
 #ifdef ENOKEY
-_S(ERR_MAP(ENOKEY), N_("Required key not available"))
+_S(ENOKEY, N_("Required key not available"))
 #endif
 #ifdef EKEYEXPIRED
-_S(ERR_MAP(EKEYEXPIRED), N_("Key has expired"))
+_S(EKEYEXPIRED, N_("Key has expired"))
 #endif
 #ifdef EKEYREVOKED
-_S(ERR_MAP(EKEYREVOKED), N_("Key has been revoked"))
+_S(EKEYREVOKED, N_("Key has been revoked"))
 #endif
 #ifdef EKEYREJECTED
-_S(ERR_MAP(EKEYREJECTED), N_("Key was rejected by service"))
+_S(EKEYREJECTED, N_("Key was rejected by service"))
 #endif
 #ifdef ERFKILL
-_S(ERR_MAP(ERFKILL), N_("Operation not possible due to RF-kill"))
+_S(ERFKILL, N_("Operation not possible due to RF-kill"))
 #endif
 #ifdef EHWPOISON
-_S(ERR_MAP(EHWPOISON), N_("Memory page has hardware error"))
+_S(EHWPOISON, N_("Memory page has hardware error"))
 #endif
 #ifdef EBADRPC
-_S(ERR_MAP(EBADRPC), N_("RPC struct is bad"))
+_S(EBADRPC, N_("RPC struct is bad"))
 #endif
 #ifdef EFTYPE
 /*
@@ -693,40 +690,40 @@ TRANS operation, or a data file had the wrong format.
 TRANS
 TRANS On some systems @code{chmod} returns this error if you try to set the
 TRANS sticky bit on a non-directory file; @pxref{Setting Permissions}. */
-_S(ERR_MAP(EFTYPE), N_("Inappropriate file type or format"))
+_S(EFTYPE, N_("Inappropriate file type or format"))
 #endif
 #ifdef EPROCUNAVAIL
-_S(ERR_MAP(EPROCUNAVAIL), N_("RPC bad procedure for program"))
+_S(EPROCUNAVAIL, N_("RPC bad procedure for program"))
 #endif
 #ifdef EAUTH
-_S(ERR_MAP(EAUTH), N_("Authentication error"))
+_S(EAUTH, N_("Authentication error"))
 #endif
 #ifdef EDIED
 /*
 TRANS On @gnuhurdsystems{}, opening a file returns this error when the file is
 TRANS translated by a program and the translator program dies while starting
 TRANS up, before it has connected to the file. */
-_S(ERR_MAP(EDIED), N_("Translator died"))
+_S(EDIED, N_("Translator died"))
 #endif
 #ifdef ERPCMISMATCH
-_S(ERR_MAP(ERPCMISMATCH), N_("RPC version wrong"))
+_S(ERPCMISMATCH, N_("RPC version wrong"))
 #endif
 #ifdef EGREGIOUS
 /*
 TRANS You did @strong{what}? */
-_S(ERR_MAP(EGREGIOUS), N_("You really blew it this time"))
+_S(EGREGIOUS, N_("You really blew it this time"))
 #endif
 #ifdef EPROCLIM
 /*
 TRANS This means that the per-user limit on new process would be exceeded by
 TRANS an attempted @code{fork}.  @xref{Limits on Resources}, for details on
 TRANS the @code{RLIMIT_NPROC} limit. */
-_S(ERR_MAP(EPROCLIM), N_("Too many processes"))
+_S(EPROCLIM, N_("Too many processes"))
 #endif
 #ifdef EGRATUITOUS
 /*
 TRANS This error code has no purpose. */
-_S(ERR_MAP(EGRATUITOUS), N_("Gratuitous error"))
+_S(EGRATUITOUS, N_("Gratuitous error"))
 #endif
 #if defined (ENOTSUP) && ENOTSUP != EOPNOTSUPP
 /*
@@ -742,10 +739,10 @@ TRANS values.
 TRANS
 TRANS If the entire function is not available at all in the implementation,
 TRANS it returns @code{ENOSYS} instead. */
-_S(ERR_MAP(ENOTSUP), N_("Not supported"))
+_S(ENOTSUP, N_("Not supported"))
 #endif
 #ifdef EPROGMISMATCH
-_S(ERR_MAP(EPROGMISMATCH), N_("RPC program version wrong"))
+_S(EPROGMISMATCH, N_("RPC program version wrong"))
 #endif
 #ifdef EBACKGROUND
 /*
@@ -755,7 +752,7 @@ TRANS foreground process group of the terminal.  Users do not usually see this
 TRANS error because functions such as @code{read} and @code{write} translate
 TRANS it into a @code{SIGTTIN} or @code{SIGTTOU} signal.  @xref{Job Control},
 TRANS for information on process groups and these signals. */
-_S(ERR_MAP(EBACKGROUND), N_("Inappropriate operation for background process"))
+_S(EBACKGROUND, N_("Inappropriate operation for background process"))
 #endif
 #ifdef EIEIO
 /*
@@ -773,7 +770,7 @@ TRANS @c "bought the farm" means "died".  -jtobey
 TRANS @c
 TRANS @c Translators, please do not translate this litteraly, translate it into
 TRANS @c an idiomatic funny way of saying that the computer died. */
-_S(ERR_MAP(EIEIO), N_("Computer bought the farm"))
+_S(EIEIO, N_("Computer bought the farm"))
 #endif
 #if defined (EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
 /*
@@ -782,18 +779,18 @@ TRANS The values are always the same, on every operating system.
 TRANS
 TRANS C libraries in many older Unix systems have @code{EWOULDBLOCK} as a
 TRANS separate error code. */
-_S(ERR_MAP(EWOULDBLOCK), N_("Operation would block"))
+_S(EWOULDBLOCK, N_("Operation would block"))
 #endif
 #ifdef ENEEDAUTH
-_S(ERR_MAP(ENEEDAUTH), N_("Need authenticator"))
+_S(ENEEDAUTH, N_("Need authenticator"))
 #endif
 #ifdef ED
 /*
 TRANS The experienced user will know what is wrong.
 TRANS @c This error code is a joke.  Its perror text is part of the joke.
 TRANS @c Don't change it. */
-_S(ERR_MAP(ED), N_("?"))
+_S(ED, N_("?"))
 #endif
 #ifdef EPROGUNAVAIL
-_S(ERR_MAP(EPROGUNAVAIL), N_("RPC program not available"))
+_S(EPROGUNAVAIL, N_("RPC program not available"))
 #endif
-- 
2.41.0

