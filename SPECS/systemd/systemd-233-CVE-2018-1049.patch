commit e7d54bf58789545a9eb0b3964233defa0b007318
Author: Anchor Cat <githubanchorcat@anchor.net.au>
Date:   Wed May 10 21:23:58 2017 +1000

    automount: ack automount requests even when already mounted (#5916)
    
    If a process accesses an autofs filesystem while systemd is in the
    middle of starting the mount unit on top of it, it is possible for the
    autofs_ptype_missing_direct request from the kernel to be received after
    the mount unit has been fully started:
    
      systemd forks and execs mount             ...
                ...                     access autofs, blocks
      mount exits                               ...
      systemd receives SIGCHLD                  ...
                ...                     kernel sends request
      systemd receives request                  ...
    
    systemd needs to respond to this request, otherwise the kernel will
    continue to block access to the mount point.

diff --git a/src/core/automount.c b/src/core/automount.c
index 99e8047..8f88c8d 100644
--- a/src/core/automount.c
+++ b/src/core/automount.c
@@ -742,8 +742,9 @@ static void automount_stop_expire(Automount *a) {
         (void) sd_event_source_set_enabled(a->expire_event_source, SD_EVENT_OFF);
 }
 
-static void automount_enter_runnning(Automount *a) {
+static void automount_enter_running(Automount *a) {
         _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;
+        Unit *trigger;
         struct stat st;
         int r;
 
@@ -772,22 +773,24 @@ static void automount_enter_runnning(Automount *a) {
                 goto fail;
         }
 
-        if (!S_ISDIR(st.st_mode) || st.st_dev != a->dev_id)
+        /* The mount unit may have been explicitly started before we got the
+         * autofs request. Ack it to unblock anything waiting on the mount point. */
+        if (!S_ISDIR(st.st_mode) || st.st_dev != a->dev_id) {
                 log_unit_info(UNIT(a), "Automount point already active?");
-        else {
-                Unit *trigger;
+                automount_send_ready(a, a->tokens, 0);
+                return;
+        }
 
-                trigger = UNIT_TRIGGER(UNIT(a));
-                if (!trigger) {
-                        log_unit_error(UNIT(a), "Unit to trigger vanished.");
-                        goto fail;
-                }
+        trigger = UNIT_TRIGGER(UNIT(a));
+        if (!trigger) {
+                log_unit_error(UNIT(a), "Unit to trigger vanished.");
+                goto fail;
+        }
 
-                r = manager_add_job(UNIT(a)->manager, JOB_START, trigger, JOB_REPLACE, &error, NULL);
-                if (r < 0) {
-                        log_unit_warning(UNIT(a), "Failed to queue mount startup job: %s", bus_error_message(&error, r));
-                        goto fail;
-                }
+        r = manager_add_job(UNIT(a)->manager, JOB_START, trigger, JOB_REPLACE, &error, NULL);
+        if (r < 0) {
+                log_unit_warning(UNIT(a), "Failed to queue mount startup job: %s", bus_error_message(&error, r));
+                goto fail;
         }
 
         automount_set_state(a, AUTOMOUNT_RUNNING);
@@ -1012,7 +1015,7 @@ static int automount_dispatch_io(sd_event_source *s, int fd, uint32_t events, vo
                         goto fail;
                 }
 
-                automount_enter_runnning(a);
+                automount_enter_running(a);
                 break;
 
         case autofs_ptype_expire_direct:
