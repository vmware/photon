From d2f4188c2776b355c6e427ac82a22ffd974c6466 Mon Sep 17 00:00:00 2001
From: Vivek Goyal <vivekgoyal@vmware.com>
Date: Wed, 13 Feb 2019 13:44:14 -0800
Subject: [PATCH] VCP patch for K8s v1.11.6

---
 api/swagger-spec/apps_v1alpha1.json           |   21 +
 api/swagger-spec/apps_v1beta1.json            |   21 +
 api/swagger-spec/apps_v1beta2.json            |   21 +
 api/swagger-spec/batch_v1.json                |   21 +
 api/swagger-spec/batch_v1beta1.json           |   21 +
 api/swagger-spec/batch_v2alpha1.json          |   21 +
 api/swagger-spec/extensions_v1beta1.json      |   21 +
 .../settings.k8s.io_v1alpha1.json             |   21 +
 api/swagger-spec/v1.json                      |   25 +
 cmd/kube-controller-manager/app/BUILD         |    2 +-
 cmd/kube-controller-manager/app/plugins.go    |    4 +
 cmd/kubelet/app/BUILD                         |    1 +
 cmd/kubelet/app/plugins.go                    |    2 +
 pkg/apis/core/types.go                        |   14 +
 pkg/apis/core/validation/validation.go        |   25 +
 pkg/apis/policy/types.go                      |    1 +
 pkg/cloudprovider/providers/BUILD             |    2 +
 pkg/cloudprovider/providers/cascade/BUILD     |   56 +
 pkg/cloudprovider/providers/cascade/OWNERS    |    3 +
 .../providers/cascade/apitypes.go             |  230 ++
 pkg/cloudprovider/providers/cascade/auth.go   |  145 +
 .../providers/cascade/cascade.go              |  219 ++
 .../providers/cascade/cascade_disks.go        |  253 ++
 .../providers/cascade/cascade_instances.go    |  129 +
 .../cascade/cascade_instances_test.go         |   44 +
 .../providers/cascade/cascade_loadbalancer.go |  295 ++
 pkg/cloudprovider/providers/cascade/client.go |  400 +++
 .../providers/cascade/oidcclient.go           |  297 ++
 .../providers/cascade/restclient.go           |  262 ++
 .../providers/cascade/tests_owed              |    5 +
 pkg/cloudprovider/providers/cascade/utils.go  |   29 +
 pkg/cloudprovider/providers/providers.go      |    1 +
 pkg/kubeapiserver/authorizer/config.go        |    7 +
 pkg/kubeapiserver/authorizer/modes/modes.go   |    3 +-
 pkg/kubeapiserver/options/plugins.go          |    3 +
 pkg/printers/internalversion/describe.go      |   11 +
 pkg/security/podsecuritypolicy/util/util.go   |    3 +
 pkg/volume/cascade_disk/BUILD                 |   43 +
 pkg/volume/cascade_disk/OWNERS                |    2 +
 pkg/volume/cascade_disk/attacher.go           |  264 ++
 pkg/volume/cascade_disk/azure_disk_util.go    |  135 +
 pkg/volume/cascade_disk/cascade_disk.go       |  399 +++
 pkg/volume/cascade_disk/cascade_util.go       |  217 ++
 .../persistentvolume/label/admission.go       |   54 +
 plugin/pkg/admission/vke/BUILD                |   61 +
 plugin/pkg/admission/vke/admission.go         |  662 ++++
 plugin/pkg/admission/vke/admission_test.go    |  995 ++++++
 plugin/pkg/auth/authorizer/vke/BUILD          |   40 +
 plugin/pkg/auth/authorizer/vke/OWNERS         |    2 +
 .../pkg/auth/authorizer/vke/vke_authorizer.go |  125 +
 .../authorizer/vke/vke_authorizer_test.go     |  230 ++
 .../src/k8s.io/api/core/v1/generated.pb.go    | 2686 +++++++++--------
 staging/src/k8s.io/api/core/v1/types.go       |   24 +-
 53 files changed, 7363 insertions(+), 1215 deletions(-)
 create mode 100644 pkg/cloudprovider/providers/cascade/BUILD
 create mode 100644 pkg/cloudprovider/providers/cascade/OWNERS
 create mode 100644 pkg/cloudprovider/providers/cascade/apitypes.go
 create mode 100644 pkg/cloudprovider/providers/cascade/auth.go
 create mode 100644 pkg/cloudprovider/providers/cascade/cascade.go
 create mode 100644 pkg/cloudprovider/providers/cascade/cascade_disks.go
 create mode 100644 pkg/cloudprovider/providers/cascade/cascade_instances.go
 create mode 100644 pkg/cloudprovider/providers/cascade/cascade_instances_test.go
 create mode 100644 pkg/cloudprovider/providers/cascade/cascade_loadbalancer.go
 create mode 100644 pkg/cloudprovider/providers/cascade/client.go
 create mode 100644 pkg/cloudprovider/providers/cascade/oidcclient.go
 create mode 100644 pkg/cloudprovider/providers/cascade/restclient.go
 create mode 100644 pkg/cloudprovider/providers/cascade/tests_owed
 create mode 100644 pkg/cloudprovider/providers/cascade/utils.go
 create mode 100644 pkg/volume/cascade_disk/BUILD
 create mode 100644 pkg/volume/cascade_disk/OWNERS
 create mode 100644 pkg/volume/cascade_disk/attacher.go
 create mode 100644 pkg/volume/cascade_disk/azure_disk_util.go
 create mode 100644 pkg/volume/cascade_disk/cascade_disk.go
 create mode 100644 pkg/volume/cascade_disk/cascade_util.go
 create mode 100644 plugin/pkg/admission/vke/BUILD
 create mode 100644 plugin/pkg/admission/vke/admission.go
 create mode 100644 plugin/pkg/admission/vke/admission_test.go
 create mode 100644 plugin/pkg/auth/authorizer/vke/BUILD
 create mode 100644 plugin/pkg/auth/authorizer/vke/OWNERS
 create mode 100644 plugin/pkg/auth/authorizer/vke/vke_authorizer.go
 create mode 100644 plugin/pkg/auth/authorizer/vke/vke_authorizer_test.go

diff --git a/api/swagger-spec/apps_v1alpha1.json b/api/swagger-spec/apps_v1alpha1.json
index 6f546623de..0ce6f3f2fc 100644
--- a/api/swagger-spec/apps_v1alpha1.json
+++ b/api/swagger-spec/apps_v1alpha1.json
@@ -1459,6 +1459,10 @@
      "photonPersistentDisk": {
       "$ref": "v1.PhotonPersistentDiskVolumeSource",
       "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine"
+     },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
      }
     }
    },
@@ -2109,6 +2113,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.Container": {
     "id": "v1.Container",
     "description": "A single application container that you want to run within a pod.",
diff --git a/api/swagger-spec/apps_v1beta1.json b/api/swagger-spec/apps_v1beta1.json
index eaacb45105..dfe940052f 100644
--- a/api/swagger-spec/apps_v1beta1.json
+++ b/api/swagger-spec/apps_v1beta1.json
@@ -4490,6 +4490,10 @@
       "$ref": "v1.PhotonPersistentDiskVolumeSource",
       "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine"
      },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
+     },
      "projected": {
       "$ref": "v1.ProjectedVolumeSource",
       "description": "Items for all in one resources secrets, configmaps, and downward API"
@@ -5221,6 +5225,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.ProjectedVolumeSource": {
     "id": "v1.ProjectedVolumeSource",
     "description": "Represents a projected volume source",
diff --git a/api/swagger-spec/apps_v1beta2.json b/api/swagger-spec/apps_v1beta2.json
index d6bc46eae9..1c607176a2 100644
--- a/api/swagger-spec/apps_v1beta2.json
+++ b/api/swagger-spec/apps_v1beta2.json
@@ -6856,6 +6856,10 @@
       "$ref": "v1.PhotonPersistentDiskVolumeSource",
       "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine"
      },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
+     },
      "projected": {
       "$ref": "v1.ProjectedVolumeSource",
       "description": "Items for all in one resources secrets, configmaps, and downward API"
@@ -7587,6 +7591,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.ProjectedVolumeSource": {
     "id": "v1.ProjectedVolumeSource",
     "description": "Represents a projected volume source",
diff --git a/api/swagger-spec/batch_v1.json b/api/swagger-spec/batch_v1.json
index 3f4abc9212..2ed4018106 100644
--- a/api/swagger-spec/batch_v1.json
+++ b/api/swagger-spec/batch_v1.json
@@ -1830,6 +1830,10 @@
       "$ref": "v1.PhotonPersistentDiskVolumeSource",
       "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine"
      },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
+     },
      "projected": {
       "$ref": "v1.ProjectedVolumeSource",
       "description": "Items for all in one resources secrets, configmaps, and downward API"
@@ -2561,6 +2565,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.ProjectedVolumeSource": {
     "id": "v1.ProjectedVolumeSource",
     "description": "Represents a projected volume source",
diff --git a/api/swagger-spec/batch_v1beta1.json b/api/swagger-spec/batch_v1beta1.json
index 58fa7522e8..74fcd28e7d 100644
--- a/api/swagger-spec/batch_v1beta1.json
+++ b/api/swagger-spec/batch_v1beta1.json
@@ -1885,6 +1885,10 @@
       "$ref": "v1.PhotonPersistentDiskVolumeSource",
       "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine"
      },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
+     },
      "projected": {
       "$ref": "v1.ProjectedVolumeSource",
       "description": "Items for all in one resources secrets, configmaps, and downward API"
@@ -2616,6 +2620,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.ProjectedVolumeSource": {
     "id": "v1.ProjectedVolumeSource",
     "description": "Represents a projected volume source",
diff --git a/api/swagger-spec/batch_v2alpha1.json b/api/swagger-spec/batch_v2alpha1.json
index 050235b53f..3484e13353 100644
--- a/api/swagger-spec/batch_v2alpha1.json
+++ b/api/swagger-spec/batch_v2alpha1.json
@@ -1900,6 +1900,10 @@
      "storageos": {
       "$ref": "v1.StorageOSVolumeSource",
       "description": "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes."
+     },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
      }
     }
    },
@@ -2834,6 +2838,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.Container": {
     "id": "v1.Container",
     "description": "A single application container that you want to run within a pod.",
diff --git a/api/swagger-spec/extensions_v1beta1.json b/api/swagger-spec/extensions_v1beta1.json
index 07c832d787..26d2578257 100644
--- a/api/swagger-spec/extensions_v1beta1.json
+++ b/api/swagger-spec/extensions_v1beta1.json
@@ -7513,6 +7513,10 @@
      "storageos": {
       "$ref": "v1.StorageOSVolumeSource",
       "description": "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes."
+     },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
      }
     }
    },
@@ -8229,6 +8233,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.ProjectedVolumeSource": {
     "id": "v1.ProjectedVolumeSource",
     "description": "Represents a projected volume source",
diff --git a/api/swagger-spec/settings.k8s.io_v1alpha1.json b/api/swagger-spec/settings.k8s.io_v1alpha1.json
index 8c9e275eb5..90c0e0b777 100644
--- a/api/swagger-spec/settings.k8s.io_v1alpha1.json
+++ b/api/swagger-spec/settings.k8s.io_v1alpha1.json
@@ -1676,6 +1676,10 @@
      "storageos": {
       "$ref": "v1.StorageOSVolumeSource",
       "description": "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes."
+     },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
      }
     }
    },
@@ -2354,6 +2358,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.ProjectedVolumeSource": {
     "id": "v1.ProjectedVolumeSource",
     "description": "Represents a projected volume source",
diff --git a/api/swagger-spec/v1.json b/api/swagger-spec/v1.json
index 7cfc2e91ac..b36450efdf 100644
--- a/api/swagger-spec/v1.json
+++ b/api/swagger-spec/v1.json
@@ -19360,6 +19360,10 @@
       "$ref": "v1.PhotonPersistentDiskVolumeSource",
       "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine"
      },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
+     },
      "portworxVolume": {
       "$ref": "v1.PortworxVolumeSource",
       "description": "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine"
@@ -19929,6 +19933,23 @@
      }
     }
    },
+   "v1.CascadeDiskVolumeSource": {
+    "id": "v1.CascadeDiskVolumeSource",
+    "description": "Represents a Cascade persistent disk resource.",
+    "required": [
+     "diskID"
+    ],
+    "properties": {
+     "diskID": {
+      "type": "string",
+      "description": "ID that identifies Cascade persistent disk"
+     },
+     "fsType": {
+      "type": "string",
+      "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
+     }
+    }
+   },
    "v1.PortworxVolumeSource": {
     "id": "v1.PortworxVolumeSource",
     "description": "PortworxVolumeSource represents a Portworx volume resource.",
@@ -20488,6 +20509,10 @@
      "storageos": {
       "$ref": "v1.StorageOSVolumeSource",
       "description": "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes."
+     },
+     "vkeDisk": {
+      "$ref": "v1.CascadeDiskVolumeSource",
+      "description": "vkeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine"
      }
     }
    },
diff --git a/cmd/kube-controller-manager/app/BUILD b/cmd/kube-controller-manager/app/BUILD
index e3ddc733f0..0a9bd71e9c 100644
--- a/cmd/kube-controller-manager/app/BUILD
+++ b/cmd/kube-controller-manager/app/BUILD
@@ -86,6 +86,7 @@ go_library(
         "//pkg/volume/aws_ebs:go_default_library",
         "//pkg/volume/azure_dd:go_default_library",
         "//pkg/volume/azure_file:go_default_library",
+        "//pkg/volume/cascade_disk:go_default_library",
         "//pkg/volume/cinder:go_default_library",
         "//pkg/volume/csi:go_default_library",
         "//pkg/volume/fc:go_default_library",
@@ -113,7 +114,6 @@ go_library(
         "//vendor/k8s.io/apimachinery/pkg/util/sets:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/uuid:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
-        "//vendor/k8s.io/apiserver/pkg/server/healthz:go_default_library",
         "//vendor/k8s.io/apiserver/pkg/util/feature:go_default_library",
         "//vendor/k8s.io/client-go/discovery/cached:go_default_library",
         "//vendor/k8s.io/client-go/dynamic:go_default_library",
diff --git a/cmd/kube-controller-manager/app/plugins.go b/cmd/kube-controller-manager/app/plugins.go
index 42034d5c6d..e729785006 100644
--- a/cmd/kube-controller-manager/app/plugins.go
+++ b/cmd/kube-controller-manager/app/plugins.go
@@ -34,6 +34,7 @@ import (
 	"k8s.io/kubernetes/pkg/volume/aws_ebs"
 	"k8s.io/kubernetes/pkg/volume/azure_dd"
 	"k8s.io/kubernetes/pkg/volume/azure_file"
+	"k8s.io/kubernetes/pkg/volume/cascade_disk"
 	"k8s.io/kubernetes/pkg/volume/cinder"
 	"k8s.io/kubernetes/pkg/volume/csi"
 	"k8s.io/kubernetes/pkg/volume/fc"
@@ -77,6 +78,7 @@ func ProbeAttachableVolumePlugins() []volume.VolumePlugin {
 	allPlugins = append(allPlugins, fc.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, iscsi.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, rbd.ProbeVolumePlugins()...)
+	allPlugins = append(allPlugins, cascade_disk.ProbeVolumePlugins()...)
 	if utilfeature.DefaultFeatureGate.Enabled(features.CSIPersistentVolume) {
 		allPlugins = append(allPlugins, csi.ProbeVolumePlugins()...)
 	}
@@ -107,6 +109,7 @@ func ProbeExpandableVolumePlugins(config componentconfig.VolumeConfiguration) []
 	allPlugins = append(allPlugins, scaleio.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, storageos.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, fc.ProbeVolumePlugins()...)
+	allPlugins = append(allPlugins, cascade_disk.ProbeVolumePlugins()...)
 	return allPlugins
 }
 
@@ -163,6 +166,7 @@ func ProbeControllerVolumePlugins(cloud cloudprovider.Interface, config componen
 	allPlugins = append(allPlugins, vsphere_volume.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, azure_dd.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, photon_pd.ProbeVolumePlugins()...)
+	allPlugins = append(allPlugins, cascade_disk.ProbeVolumePlugins()...)
 
 	return allPlugins
 }
diff --git a/cmd/kubelet/app/BUILD b/cmd/kubelet/app/BUILD
index b2f3efbc79..278970c4cb 100644
--- a/cmd/kubelet/app/BUILD
+++ b/cmd/kubelet/app/BUILD
@@ -119,6 +119,7 @@ go_library(
         "//pkg/volume/aws_ebs:go_default_library",
         "//pkg/volume/azure_dd:go_default_library",
         "//pkg/volume/azure_file:go_default_library",
+        "//pkg/volume/cascade_disk:go_default_library",
         "//pkg/volume/cephfs:go_default_library",
         "//pkg/volume/cinder:go_default_library",
         "//pkg/volume/configmap:go_default_library",
diff --git a/cmd/kubelet/app/plugins.go b/cmd/kubelet/app/plugins.go
index 22700b051f..540e5016a1 100644
--- a/cmd/kubelet/app/plugins.go
+++ b/cmd/kubelet/app/plugins.go
@@ -32,6 +32,7 @@ import (
 	"k8s.io/kubernetes/pkg/volume/aws_ebs"
 	"k8s.io/kubernetes/pkg/volume/azure_dd"
 	"k8s.io/kubernetes/pkg/volume/azure_file"
+	"k8s.io/kubernetes/pkg/volume/cascade_disk"
 	"k8s.io/kubernetes/pkg/volume/cephfs"
 	"k8s.io/kubernetes/pkg/volume/cinder"
 	"k8s.io/kubernetes/pkg/volume/configmap"
@@ -100,6 +101,7 @@ func ProbeVolumePlugins() []volume.VolumePlugin {
 	allPlugins = append(allPlugins, scaleio.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, local.ProbeVolumePlugins()...)
 	allPlugins = append(allPlugins, storageos.ProbeVolumePlugins()...)
+	allPlugins = append(allPlugins, cascade_disk.ProbeVolumePlugins()...)
 	if utilfeature.DefaultFeatureGate.Enabled(features.CSIPersistentVolume) {
 		allPlugins = append(allPlugins, csi.ProbeVolumePlugins()...)
 	}
diff --git a/pkg/apis/core/types.go b/pkg/apis/core/types.go
index 1669edc41e..60ba08e91b 100644
--- a/pkg/apis/core/types.go
+++ b/pkg/apis/core/types.go
@@ -152,6 +152,8 @@ type VolumeSource struct {
 	// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
 	// +optional
 	StorageOS *StorageOSVolumeSource
+	// CascadeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine
+	CascadeDisk *CascadeDiskVolumeSource
 }
 
 // Similar to VolumeSource but meant for the administrator who creates PVs.
@@ -230,6 +232,8 @@ type PersistentVolumeSource struct {
 	// CSI (Container Storage Interface) represents storage that handled by an external CSI driver (Beta feature).
 	// +optional
 	CSI *CSIPersistentVolumeSource
+	// CascadeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine
+	CascadeDisk *CascadeDiskVolumeSource
 }
 
 type PersistentVolumeClaimVolumeSource struct {
@@ -1372,6 +1376,16 @@ type StorageOSPersistentVolumeSource struct {
 	SecretRef *ObjectReference
 }
 
+// Represents a Cascade persistent disk resource.
+type CascadeDiskVolumeSource struct {
+	// ID that identifies Cascade persistent disk
+	DiskID string
+	// Filesystem type to mount.
+	// Must be a filesystem type supported by the host operating system.
+	// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
+	FSType string
+}
+
 // Adapts a ConfigMap into a volume.
 //
 // The contents of the target ConfigMap's Data field will be presented in a
diff --git a/pkg/apis/core/validation/validation.go b/pkg/apis/core/validation/validation.go
index 120879c85b..b1c6f9a154 100644
--- a/pkg/apis/core/validation/validation.go
+++ b/pkg/apis/core/validation/validation.go
@@ -638,6 +638,14 @@ func validateVolumeSource(source *core.VolumeSource, fldPath *field.Path, volNam
 			allErrs = append(allErrs, validateScaleIOVolumeSource(source.ScaleIO, fldPath.Child("scaleIO"))...)
 		}
 	}
+	if source.CascadeDisk != nil {
+		if numVolumes > 0 {
+			allErrs = append(allErrs, field.Forbidden(fldPath.Child("cascadeDisk"), "may not specify more than 1 volume type"))
+		} else {
+			numVolumes++
+			allErrs = append(allErrs, validateCascadeDiskVolumeSource(source.CascadeDisk, fldPath.Child("cascadeDisk"))...)
+		}
+	}
 
 	if numVolumes == 0 {
 		allErrs = append(allErrs, field.Required(fldPath, "must specify a volume type"))
@@ -1491,6 +1499,14 @@ func validateCSIPersistentVolumeSource(csi *core.CSIPersistentVolumeSource, fldP
 	return allErrs
 }
 
+func validateCascadeDiskVolumeSource(cd *core.CascadeDiskVolumeSource, fldPath *field.Path) field.ErrorList {
+	allErrs := field.ErrorList{}
+	if len(cd.DiskID) == 0 {
+		allErrs = append(allErrs, field.Required(fldPath.Child("diskID"), ""))
+	}
+	return allErrs
+}
+
 // ValidatePersistentVolumeName checks that a name is appropriate for a
 // PersistentVolumeName object.
 var ValidatePersistentVolumeName = NameIsDNSSubdomain
@@ -1725,6 +1741,15 @@ func ValidatePersistentVolume(pv *core.PersistentVolume) field.ErrorList {
 		}
 	}
 
+	if pv.Spec.CascadeDisk != nil {
+		if numVolumes > 0 {
+			allErrs = append(allErrs, field.Forbidden(specPath.Child("cascadeDisk"), "may not specify more than 1 volume type"))
+		} else {
+			numVolumes++
+			allErrs = append(allErrs, validateCascadeDiskVolumeSource(pv.Spec.CascadeDisk, specPath.Child("cascadeDisk"))...)
+		}
+	}
+
 	if numVolumes == 0 {
 		allErrs = append(allErrs, field.Required(specPath, "must specify a volume type"))
 	}
diff --git a/pkg/apis/policy/types.go b/pkg/apis/policy/types.go
index 298fcd0e4d..174d0fc876 100644
--- a/pkg/apis/policy/types.go
+++ b/pkg/apis/policy/types.go
@@ -290,6 +290,7 @@ var (
 	PortworxVolume        FSType = "portworxVolume"
 	ScaleIO               FSType = "scaleIO"
 	CSI                   FSType = "csi"
+	CascadeDisk           FSType = "cascadeDisk"
 	All                   FSType = "*"
 )
 
diff --git a/pkg/cloudprovider/providers/BUILD b/pkg/cloudprovider/providers/BUILD
index aeccfa1e5b..4313576203 100644
--- a/pkg/cloudprovider/providers/BUILD
+++ b/pkg/cloudprovider/providers/BUILD
@@ -12,6 +12,7 @@ go_library(
     deps = [
         "//pkg/cloudprovider/providers/aws:go_default_library",
         "//pkg/cloudprovider/providers/azure:go_default_library",
+        "//pkg/cloudprovider/providers/cascade:go_default_library",
         "//pkg/cloudprovider/providers/cloudstack:go_default_library",
         "//pkg/cloudprovider/providers/gce:go_default_library",
         "//pkg/cloudprovider/providers/openstack:go_default_library",
@@ -34,6 +35,7 @@ filegroup(
         ":package-srcs",
         "//pkg/cloudprovider/providers/aws:all-srcs",
         "//pkg/cloudprovider/providers/azure:all-srcs",
+        "//pkg/cloudprovider/providers/cascade:all-srcs",
         "//pkg/cloudprovider/providers/cloudstack:all-srcs",
         "//pkg/cloudprovider/providers/fake:all-srcs",
         "//pkg/cloudprovider/providers/gce:all-srcs",
diff --git a/pkg/cloudprovider/providers/cascade/BUILD b/pkg/cloudprovider/providers/cascade/BUILD
new file mode 100644
index 0000000000..4089166732
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/BUILD
@@ -0,0 +1,56 @@
+package(default_visibility = ["//visibility:public"])
+
+load(
+    "@io_bazel_rules_go//go:def.bzl",
+    "go_library",
+)
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "apitypes.go",
+        "auth.go",
+        "cascade.go",
+        "cascade_disks.go",
+        "cascade_instances.go",
+        "cascade_loadbalancer.go",
+        "client.go",
+        "oidcclient.go",
+        "restclient.go",
+        "utils.go"
+        ],
+    deps = [
+        "//pkg/api/v1/helper:go_default_library",
+        "//pkg/cloudprovider:go_default_library",
+        "//pkg/controller:go_default_library",
+        "//vendor/github.com/golang/glog:go_default_library",
+        "//vendor/gopkg.in/gcfg.v1:go_default_library",
+        "//vendor/k8s.io/api/core/v1:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/types:go_default_library",
+    ],
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = [
+        "cascade_instances_test.go",
+    ],
+    embed = [":go_default_library"],
+    deps = [
+        "//vendor/k8s.io/api/core/v1:go_default_library",
+        "//vendor/github.com/stretchr/testify/assert:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [":package-srcs"],
+    tags = ["automanaged"],
+)
diff --git a/pkg/cloudprovider/providers/cascade/OWNERS b/pkg/cloudprovider/providers/cascade/OWNERS
new file mode 100644
index 0000000000..70efc9dc1c
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/OWNERS
@@ -0,0 +1,3 @@
+maintainers:
+- ashokc
+- ysheng
diff --git a/pkg/cloudprovider/providers/cascade/apitypes.go b/pkg/cloudprovider/providers/cascade/apitypes.go
new file mode 100644
index 0000000000..d437394462
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/apitypes.go
@@ -0,0 +1,230 @@
+package cascade
+
+import "fmt"
+
+const (
+	NotFoundError     = 1408
+	VMNotFoundError   = 2006
+	DiskNotFoundError = 3011
+	DiskInUseError    = 3012
+
+	DiskStateAttached = "ATTACHED"
+)
+
+// Represents APIError returned by the API in case of an error.
+type APIError struct {
+	Code           *string           `json:"code"`
+	Data           map[string]string `json:"data"`
+	ErrorCode      int32             `json:"errorCode,omitempty"`
+	Message        *string           `json:"message"`
+	HttpStatusCode int               `json:"-"` // Not part of API contract
+}
+
+// Implement Go error interface for ApiError.
+func (e APIError) Error() string {
+	return fmt.Sprintf(
+		"Cascade: { HTTP status: '%d', code: '%s', message: '%s', data: '%v', errorcode: '%d' }",
+		e.HttpStatusCode, StringVal(e.Code), StringVal(e.Message), e.Data, e.ErrorCode)
+}
+
+// Used to represent a generic HTTP error, i.e. an unexpected HTTP 500.
+type HttpError struct {
+	StatusCode int
+	Message    string
+}
+
+// Implementation of error interface for HttpError.
+func (e HttpError) Error() string {
+	return fmt.Sprintf("Cascade: HTTP %d: %v", e.StatusCode, e.Message)
+}
+
+// Represents a task which gets returned for long running API calls.
+type Task struct {
+	EndTime            int64       `json:"endTime,omitempty"`
+	Entity             *Entity     `json:"entity,omitempty"`
+	ID                 *string     `json:"id"`
+	Operation          string      `json:"operation,omitempty"`
+	QueuedTime         *int64      `json:"queuedTime"`
+	ResourceProperties interface{} `json:"resourceProperties,omitempty"`
+	SelfLink           string      `json:"selfLink,omitempty"`
+	StartedTime        *int64      `json:"startedTime"`
+	State              *string     `json:"state"`
+	Steps              []*Step     `json:"steps"`
+}
+
+// Represents the entity associated with the task.
+type Entity struct {
+	ID   *string `json:"id"`
+	Kind *string `json:"kind"`
+}
+
+// Represents a task that has entered into an error state. Task errors can be caught and type-checked against with the
+// usual Go idiom.
+type TaskError struct {
+	ID   string `json:"id"`
+	Step Step   `json:"step,omitempty"`
+}
+
+// Implement Go error interface for TaskError.
+func (e TaskError) Error() string {
+	return fmt.Sprintf("Cascade: Task '%s' is in error state: {@step==%s}", e.ID, GetStep(e.Step))
+}
+
+// An error representing a timeout while waiting for a task to complete.
+type TaskTimeoutError struct {
+	ID string
+}
+
+// Implement Go error interface for TaskTimeoutError.
+func (e TaskTimeoutError) Error() string {
+	return fmt.Sprintf("Cascade: Timed out waiting for task '%s'. "+
+		"Task may not be in error state, examine task for full details.", e.ID)
+}
+
+// Represents a step in a task.
+type Step struct {
+	EndTime     int64             `json:"endTime,omitempty"`
+	Errors      []*APIError       `json:"errors"`
+	Operation   string            `json:"operation,omitempty"`
+	Options     map[string]string `json:"options,omitempty"`
+	QueuedTime  *int64            `json:"queuedTime"`
+	Sequence    int32             `json:"sequence,omitempty"`
+	StartedTime *int64            `json:"startedTime"`
+	State       *string           `json:"state"`
+	Warnings    []*APIError       `json:"warnings"`
+}
+
+// Implement Go error interface for Step.
+func GetStep(s Step) string {
+	return fmt.Sprintf("{\"operation\"=>\"%s\",\"state\"=>\"%s}", s.Operation, StringVal(s.State))
+}
+
+// Represents the VM response returned by the API.
+type VM struct {
+	AttachedDisks          []*AttachedDisk  `json:"attachedDisks"`
+	Cost                   []*QuotaLineItem `json:"cost"`
+	Flavor                 *string          `json:"flavor"`
+	FloatingIP             string           `json:"floatingIp,omitempty"`
+	HighAvailableVMGroupID string           `json:"highAvailableVMGroupID,omitempty"`
+	ID                     *string          `json:"id"`
+	Kind                   string           `json:"kind"`
+	Name                   *string          `json:"name"`
+	SelfLink               string           `json:"selfLink,omitempty"`
+	SourceImageID          string           `json:"sourceImageId,omitempty"`
+	State                  *string          `json:"state"`
+	Subnets                []string         `json:"subnets"`
+	Tags                   []string         `json:"tags"`
+}
+
+// Represents the listVMs response returned by the API.
+type VMList struct {
+	Items            []*VM  `json:"items"`
+	NextPageLink     string `json:"nextPageLink,omitempty"`
+	PreviousPageLink string `json:"previousPageLink,omitempty"`
+}
+
+// Represents multiple VMs returned by the API.
+type VMs struct {
+	Items []VM `json:"items"`
+}
+
+// Represents the disks attached to the VMs.
+type AttachedDisk struct {
+	BootDisk   *bool   `json:"bootDisk"`
+	CapacityGb *int32  `json:"capacityGb"`
+	Flavor     *string `json:"flavor"`
+	ID         *string `json:"id"`
+	Kind       *string `json:"kind"`
+	Name       *string `json:"name"`
+	State      *string `json:"state"`
+}
+
+// Represents an attach disk operation request.
+type VMDiskOperation struct {
+	Arguments map[string]string `json:"arguments,omitempty"`
+	DiskID    *string           `json:"diskId"`
+}
+
+// Represents the quota line items for the VM.
+type QuotaLineItem struct {
+	Key   *string  `json:"key"`
+	Unit  *string  `json:"unit"`
+	Value *float64 `json:"value"`
+}
+
+// Represents a persistent disk
+type PersistentDisk struct {
+	CapacityGB  int32            `json:"capacityGb,omitempty"`
+	Cost        []*QuotaLineItem `json:"cost"`
+	Datastore   string           `json:"datastore,omitempty"`
+	Flavor      *string          `json:"flavor"`
+	ID          *string          `json:"id"`
+	Kind        string           `json:"kind"`
+	Name        *string          `json:"name"`
+	SelfLink    string           `json:"selfLink,omitempty"`
+	State       *string          `json:"state"`
+	Tags        []string         `json:"tags"`
+	VM          string           `json:"vm"`
+	MountDevice string           `json:"mountDevice,omitempty"`
+	Zone        *string          `json:"zone"`
+}
+
+// Represents the spec for creating a disk.
+type DiskCreateSpec struct {
+	Affinities []*LocalitySpec `json:"affinities"`
+	CapacityGB *int32          `json:"capacityGb"`
+	Flavor     *string         `json:"flavor"`
+	Kind       *string         `json:"kind"`
+	Name       *string         `json:"name"`
+	Tags       []string        `json:"tags"`
+	Zone       *string         `json:"zone"`
+	Encrypted  *bool           `json:"encrypted"`
+}
+
+// Represents the spec for specifying affinity for a disk with another entity.
+type LocalitySpec struct {
+	ID   *string `json:"id"`
+	Kind *string `json:"kind"`
+}
+
+// Represens the LoadBalancer response returned by the API.
+type LoadBalancer struct {
+	Endpoint *string `json:"endpoint"`
+}
+
+// Represents the spec for creating a LoadBalancer.
+type LoadBalancerCreateSpec struct {
+	HealthCheck *LoadBalancerHealthCheck `json:"healthCheck"`
+	Name        *string                  `json:"name"`
+	PortMaps    []*LoadBalancerPortMap   `json:"portMaps"`
+	Type        *string                  `json:"type"`
+	SubDomain   *string                  `json:"subDomain"`
+}
+
+// Represents the health check spec for a load balancer.
+type LoadBalancerHealthCheck struct {
+	HealthyThreshold  int64   `json:"healthyThreshold,omitempty"`
+	IntervalInSeconds int64   `json:"intervalInSeconds,omitempty"`
+	Path              *string `json:"path,omitempty"`
+	Port              *int64  `json:"port"`
+	Protocol          *string `json:"protocol"`
+}
+
+// Represents a port mapping spec for a load balancer.
+type LoadBalancerPortMap struct {
+	AllowedCidrs         []*string `json:"allowedCidrs"`
+	InstancePort         *int64    `json:"instancePort"`
+	InstanceProtocol     *string   `json:"instanceProtocol"`
+	LoadBalancerPort     *int64    `json:"loadBalancerPort"`
+	LoadBalancerProtocol *string   `json:"loadBalancerProtocol"`
+}
+
+// Represents a VM to be registered with or deregistered from the load balancer.
+type LoadBalancerVM struct {
+	ID *string `json:"id"`
+}
+
+// Represents a list of VMs to be registered with or deregistered from the load balancer.
+type LoadBalancerVMUpdate struct {
+	VMIds []*LoadBalancerVM `json:"vmIds"`
+}
diff --git a/pkg/cloudprovider/providers/cascade/auth.go b/pkg/cloudprovider/providers/cascade/auth.go
new file mode 100644
index 0000000000..fc9237767f
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/auth.go
@@ -0,0 +1,145 @@
+package cascade
+
+import (
+	"fmt"
+	"strings"
+	"github.com/golang/glog"
+	"os/exec"
+)
+
+const (
+	tScope = "openid offline_access rs_admin_server at_groups rs_vmdir"
+
+	afdCli                     = "/opt/vmware/bin/vmafd-cli"
+	afdCliMachineAccountCmd    = "get-machine-account-info"
+	afdCliPasswordPrefix       = "Password: "
+	afdCliSeparator            = "\n"
+)
+
+// AuthConfig contains configuration information for the authentication client.
+type AuthConfig struct {
+	tenantName string
+	authEndpoint string
+	machineAccountName string
+}
+
+// AuthClient defines functions related to authentication.
+type AuthClient struct {
+	cfg *AuthConfig
+}
+
+// NewAuthClient creates a new authentication client
+func NewAuthClient(cascadeCfg *CascadeConfig) (*AuthClient, error) {
+	return &AuthClient{
+		cfg: &AuthConfig{
+			tenantName: cascadeCfg.Global.TenantName,
+			authEndpoint: cascadeCfg.Global.AuthEndpoint,
+			machineAccountName: fmt.Sprintf("%s@%s", cascadeCfg.Global.DNSName, cascadeCfg.Global.DomainName),
+		},
+	}, nil
+}
+
+func (c *AuthClient) GetTokensByMachineAccount() (*TokenOptions, error) {
+	// Use the VMAFD CLI to get the machine account password
+	cmd := exec.Command(afdCli, afdCliMachineAccountCmd)
+	output, err := cmd.Output()
+	if err != nil {
+		glog.Errorf("Cascade Cloud Provider: Failed to get machine account credentials. Cannot create Client.")
+		return nil, fmt.Errorf("Failed to get machine account credentials, err: %v", err)
+	}
+
+	password, err := parseMachineAccountInfo(output)
+	if err != nil {
+		glog.Errorf("Cascade Cloud Provider: Failed to parse machine account credentials. Cannot create Client.")
+		return nil, fmt.Errorf("Failed to parse machine account credentials, err: %v", err)
+	}
+
+	return c.GetTokensByCredentials(c.cfg.machineAccountName, password)
+}
+
+// GetTokensByPassword gets tokens using username and password
+func (c *AuthClient) GetTokensByCredentials(username, password string) (*TokenOptions, error) {
+	// Parse tenant part from username
+	parts := strings.Split(username, "@")
+	if len(parts) != 2 {
+		return nil, fmt.Errorf("Invalid full user name '%s': expected user@tenant", username)
+	}
+	tenant := parts[1]
+
+	oidcClient, err := buildOIDCClient(c.cfg.authEndpoint)
+	if err != nil {
+		return nil, err
+	}
+
+	tokenResponse, err := oidcClient.GetTokenByPasswordGrant(tenant, username, password)
+	if err != nil {
+		return nil, err
+	}
+
+	return toTokenOptions(tokenResponse), nil
+}
+
+// GetTokensByRefreshToken gets tokens using refresh token
+func (c *AuthClient) GetTokensByRefreshToken(refreshtoken string) (*TokenOptions, error) {
+	oidcClient, err := buildOIDCClient(c.cfg.authEndpoint)
+	if err != nil {
+		return nil, err
+	}
+
+	tokenResponse, err := oidcClient.GetTokenByRefreshTokenGrant(c.cfg.tenantName, refreshtoken)
+	if err != nil {
+		return nil, err
+	}
+
+	return toTokenOptions(tokenResponse), nil
+}
+
+func buildOIDCClient(authEndpoint string) (*OIDCClient, error) {
+	options := &OIDCClientOptions{
+		IgnoreCertificate: false,
+		RootCAs:           nil,
+		TokenScope:        tScope,
+	}
+
+	return NewOIDCClient(authEndpoint, options, nil), nil
+}
+
+func toTokenOptions(response *OIDCTokenResponse) *TokenOptions {
+	return &TokenOptions{
+		AccessToken:  response.AccessToken,
+		ExpiresIn:    response.ExpiresIn,
+		RefreshToken: response.RefreshToken,
+		IDToken:      response.IDToken,
+		TokenType:    response.TokenType,
+	}
+}
+
+// parseMachineAccountInfo parses the machine account password from the machine-account-info output which looks like
+// this:
+//MachineAccount: photon-8rwdscr1.lw-testdom.com
+//Password: FT`])}]d/3\EPwRpz9k1
+func parseMachineAccountInfo(output []byte) (string, error) {
+	if len(output) <= 0 {
+		return "", fmt.Errorf("account info is not specified")
+	}
+
+	strOut := string(output)
+	strOutLen := len(strOut)
+
+	pwdStart := strings.Index(strOut, afdCliPasswordPrefix)
+	if pwdStart < 0 {
+		return "", fmt.Errorf("account info is not in expected format")
+	}
+	pwdStart = pwdStart + len(afdCliPasswordPrefix)
+	if pwdStart >= strOutLen {
+		return "", fmt.Errorf("account info is not in expected format")
+	}
+	pwdEnd := strings.LastIndex(strOut, afdCliSeparator)
+	if pwdEnd < 0 || pwdEnd <= pwdStart || pwdEnd >= strOutLen {
+		return "", fmt.Errorf("account info is not in expected format")
+	}
+
+	pwd := strOut[pwdStart:pwdEnd]
+
+	return pwd, nil
+}
\ No newline at end of file
diff --git a/pkg/cloudprovider/providers/cascade/cascade.go b/pkg/cloudprovider/providers/cascade/cascade.go
new file mode 100644
index 0000000000..b9fafb92e1
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/cascade.go
@@ -0,0 +1,219 @@
+// The use of Cascade cloud provider requires the kubelet, kube-apiserver, and kube-controller-manager to be started
+// with config flag: '--cloud-provider=cascade --cloud-config=[path_to_config_file]'.
+package cascade
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"github.com/golang/glog"
+	"gopkg.in/gcfg.v1"
+	"io"
+	k8stypes "k8s.io/apimachinery/pkg/types"
+	"k8s.io/kubernetes/pkg/cloudprovider"
+	"k8s.io/kubernetes/pkg/controller"
+	"os"
+	"strings"
+)
+
+const (
+	ProviderName = "vke"
+	DiskSpecKind = "persistent-disk"
+	MasterPrefix = "master"
+)
+
+// CascadeCloud is an implementation of the cloud provider interface for Cascade Controller.
+type CascadeCloud struct {
+	cfg *CascadeConfig
+	// Authentication client to get token for Cascade API calls
+	authClient *AuthClient
+	// API Client to make Cascade API calls
+	apiClient *Client
+	// local $HOSTNAME
+	localHostname string
+	// hostname from K8S, could be overridden
+	localK8sHostname string
+}
+
+// CascadeCloud represents Cascade cloud provider's configuration.
+type CascadeConfig struct {
+	Global struct {
+		// the Cascade Controller endpoint
+		CloudTarget string `gcfg:"target"`
+		// Cascade Controller tenantName name
+		TenantName string `gcfg:"tenantName"`
+		// Cascade Controller cluster ID
+		ClusterID string `gcfg:"clusterID"`
+		// Authentication server endpoint for Cascade Controller
+		AuthEndpoint string `gcfg:"authEndpoint"`
+		// Lightwave domain name for the node
+		DomainName string `gcfg:"domainName"`
+		// DNS name of the node.
+		DNSName string `gcfg:"dnsName"`
+		// Region in which the cluster is in
+		Region string `gcfg:"region"`
+		// Availability zone in which the cluster is in
+		Zone string `gcfg:"zone"`
+		// IP address of the node.
+		IPAddress string `gcfg:"ipAddress"`
+	}
+}
+
+// Disks is interface for manipulation with Cascade Controller Persistent Disks.
+type Disks interface {
+	// AttachDisk attaches given disk to given node. Current node
+	// is used when nodeName is empty string.
+	AttachDisk(diskID string, nodeName k8stypes.NodeName) (string, error)
+
+	// DetachDisk detaches given disk to given node. Current node
+	// is used when nodeName is empty string.
+	DetachDisk(diskID string, nodeName k8stypes.NodeName) error
+
+	// DiskIsAttached checks if a disk is attached to the given node.
+	DiskIsAttached(diskID string, nodeName k8stypes.NodeName) (bool, error)
+
+	// DisksAreAttached is a batch function to check if a list of disks are attached
+	// to the node with the specified NodeName.
+	DisksAreAttached(diskID []string, nodeName k8stypes.NodeName) (map[string]bool, error)
+
+	// CreateDisk creates a new PD with given properties.
+	CreateDisk(volumeOptions *VolumeOptions) (diskID string, err error)
+
+	// DeleteDisk deletes PD.
+	DeleteDisk(diskID string) error
+
+	// Get labels to apply to volume on creation.
+	GetVolumeLabels(diskID string) (map[string]string, error)
+}
+
+// VolumeOptions specifies capacity, tags, name and flavorID for a volume.
+type VolumeOptions struct {
+	CapacityGB        int
+	Tags              map[string]string
+	Name              string
+	Type              string
+	ZonePresent       bool
+	ZonesPresent      bool
+	AvailabilityZone  string
+	AvailabilityZones string
+	Encrypted         bool
+}
+
+func readConfig(config io.Reader) (*CascadeConfig, error) {
+	if config == nil {
+		err := fmt.Errorf("Cascade Cloud Provider: config file is missing. Please restart with " +
+			"--cloud-provider=cascade --cloud-config=[path_to_config_file]")
+		return nil, err
+	}
+
+	var cfg CascadeConfig
+	err := gcfg.ReadInto(&cfg, config)
+	return &cfg, err
+}
+
+func init() {
+	cloudprovider.RegisterCloudProvider(ProviderName, func(config io.Reader) (cloudprovider.Interface, error) {
+		cfg, err := readConfig(config)
+		if err != nil {
+			glog.Errorf("Cascade Cloud Provider: failed to read in cloud provider config file. Error[%v]", err)
+			return nil, err
+		}
+		return newCascadeCloud(cfg)
+	})
+}
+
+func newCascadeCloud(cfg *CascadeConfig) (*CascadeCloud, error) {
+	if len(cfg.Global.CloudTarget) == 0 {
+		return nil, fmt.Errorf("Cascade Controller endpoint was not specified.")
+	}
+
+	// Get local hostname
+	hostname, err := os.Hostname()
+	if err != nil {
+		glog.Errorf("Cascade Cloud Provider: get hostname failed. Error[%v]", err)
+		return nil, err
+	}
+
+	cc := CascadeCloud{
+		cfg:              cfg,
+		localHostname:    hostname,
+		localK8sHostname: "",
+	}
+
+	// Instantiate the auth and API clients only on the master nodes. Kubelets running on the workers don't need them as
+	// they are used primarily for making API calls to Cascade.
+	if strings.HasPrefix(hostname, MasterPrefix) {
+		if cc.authClient, err = NewAuthClient(cfg); err != nil {
+			return nil, err
+		}
+
+		if cc.apiClient, err = NewClient(cfg, cc.authClient); err != nil {
+			return nil, err
+		}
+	}
+
+	return &cc, nil
+}
+
+// Initialize passes a Kubernetes clientBuilder interface to the cloud provider
+func (cc *CascadeCloud) Initialize(clientBuilder controller.ControllerClientBuilder) {}
+
+// Instances returns an implementation of Instances for Cascade Controller.
+func (cc *CascadeCloud) Instances() (cloudprovider.Instances, bool) {
+	return cc, true
+}
+
+func (cc *CascadeCloud) Clusters() (cloudprovider.Clusters, bool) {
+	return nil, true
+}
+
+// ProviderName returns the cloud provider ID.
+func (cc *CascadeCloud) ProviderName() string {
+	return ProviderName
+}
+
+// LoadBalancer returns an implementation of LoadBalancer for Cascade Controller.
+func (cc *CascadeCloud) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
+	return cc, true
+}
+
+// Zones returns an implementation of Zones for Cascade Controller.
+func (cc *CascadeCloud) Zones() (cloudprovider.Zones, bool) {
+	return cc, true
+}
+
+func (cc *CascadeCloud) GetZone(ctx context.Context) (cloudprovider.Zone, error) {
+	return cloudprovider.Zone{
+		Region:        cc.cfg.Global.Region,
+		FailureDomain: cc.cfg.Global.Zone,
+	}, nil
+}
+
+// GetZoneByProviderID implements Zones.GetZoneByProviderID
+// This is particularly useful in external cloud providers where the kubelet
+// does not initialize node data.
+func (cc *CascadeCloud) GetZoneByProviderID(ctx context.Context, providerID string) (cloudprovider.Zone, error) {
+	return cloudprovider.Zone{}, errors.New("unimplemented")
+}
+
+// GetZoneByNodeName implements Zones.GetZoneByNodeName
+// This is particularly useful in external cloud providers where the kubelet
+// does not initialize node data.
+func (cc *CascadeCloud) GetZoneByNodeName(ctx context.Context, nodeName k8stypes.NodeName) (cloudprovider.Zone, error) {
+	return cloudprovider.Zone{}, errors.New("unimeplemented")
+}
+
+// Routes returns a false since the interface is not supported for Cascade controller.
+func (cc *CascadeCloud) Routes() (cloudprovider.Routes, bool) {
+	return nil, false
+}
+
+// ScrubDNS filters DNS settings for pods.
+func (cc *CascadeCloud) ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string) {
+	return nameservers, searches
+}
+
+// HasClusterID returns true if the cluster has a clusterID
+func (cc *CascadeCloud) HasClusterID() bool {
+	return true
+}
diff --git a/pkg/cloudprovider/providers/cascade/cascade_disks.go b/pkg/cloudprovider/providers/cascade/cascade_disks.go
new file mode 100644
index 0000000000..ab1c8d3157
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/cascade_disks.go
@@ -0,0 +1,253 @@
+package cascade
+
+import (
+	"context"
+	"fmt"
+	"github.com/golang/glog"
+	k8stypes "k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/sets"
+	"k8s.io/kubernetes/pkg/kubelet/apis"
+	"k8s.io/kubernetes/pkg/volume"
+	volumeutil "k8s.io/kubernetes/pkg/volume/util"
+)
+
+// Attaches given virtual disk volume to the node running kubelet.
+func (cc *CascadeCloud) AttachDisk(diskID string, nodeName k8stypes.NodeName) (string, error) {
+	// Check if disk is already attached to that node.
+	attached, err := cc.DiskIsAttached(diskID, nodeName)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: cc.DiskIsAttached failed during AttachDisk. Error[%v]", err)
+		return "", err
+	}
+
+	// If not already attached, attach the disk.
+	if !attached {
+		operation := &VMDiskOperation{
+			DiskID: StringPtr(diskID),
+		}
+
+		vmID, err := cc.InstanceIDFromNodeName(context.TODO(), nodeName)
+		if err != nil {
+			glog.Errorf("VKE Cloud Provider: cc.InstanceID failed for AttachDisk. Error[%v]", err)
+			return "", err
+		}
+
+		task, err := cc.apiClient.AttachDisk(vmID, operation)
+		if err != nil {
+			glog.Errorf("VKE Cloud Provider: Failed to attach disk with ID %s. Error[%v]", diskID, err)
+			return "", err
+		}
+
+		_, err = cc.apiClient.WaitForTask(StringVal(task.ID))
+		if err != nil {
+			glog.Errorf("VKE Cloud Provider: Failed to wait for task to attach disk with ID %s. Error[%v]",
+				diskID, err)
+			return "", err
+		}
+	}
+
+	// Get mount device of the attached disk.
+	disk, err := cc.apiClient.GetDisk(diskID)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to Get disk with diskID %s. Error[%v]", diskID, err)
+		return "", err
+	}
+
+	return disk.MountDevice, nil
+}
+
+// Detaches given virtual disk volume from the node running kubelet.
+func (cc *CascadeCloud) DetachDisk(diskID string, nodeName k8stypes.NodeName) error {
+	operation := &VMDiskOperation{
+		DiskID: StringPtr(diskID),
+	}
+
+	vmID, err := cc.InstanceIDFromNodeName(context.TODO(), nodeName)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: cc.InstanceID failed for DetachDisk. Error[%v]", err)
+		return err
+	}
+
+	task, err := cc.apiClient.DetachDisk(vmID, operation)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to detach disk with pdID %s. Error[%v]", diskID, err)
+		return err
+	}
+
+	_, err = cc.apiClient.WaitForTask(StringVal(task.ID))
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to wait for task to detach disk with pdID %s. Error[%v]",
+			diskID, err)
+		return err
+	}
+
+	return nil
+}
+
+// DiskIsAttached returns if disk is attached to the VM using controllers supported by the plugin.
+func (cc *CascadeCloud) DiskIsAttached(diskID string, nodeName k8stypes.NodeName) (bool, error) {
+	vmID, err := cc.InstanceIDFromNodeName(context.TODO(), nodeName)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: cc.InstanceID failed for DiskIsAttached. Error[%v]", err)
+		return false, err
+	}
+
+	_, err = cc.apiClient.GetVM(vmID)
+	if err != nil {
+		switch err.(type) {
+		case APIError:
+			if err.(APIError).ErrorCode == VMNotFoundError {
+				// If instance no longer exists, we will assume that the volume is not attached.
+				glog.Warningf("VKE Cloud Provider: Instance %s does not exist. DiskIsAttached will assume"+
+					" disk %s is not attached to it.", nodeName, diskID)
+				return false, nil
+			}
+		}
+		return false, err
+	}
+
+	disk, err := cc.apiClient.GetDisk(diskID)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to Get disk with diskID %s. Error[%v]", diskID, err)
+		return false, err
+	}
+
+	if disk.VM == vmID && StringVal(disk.State) == DiskStateAttached {
+		return true, nil
+	}
+
+	return false, nil
+}
+
+// DisksAreAttached returns if disks are attached to the VM using controllers supported by the plugin.
+func (cc *CascadeCloud) DisksAreAttached(diskIDs []string, nodeName k8stypes.NodeName) (map[string]bool, error) {
+	attached := make(map[string]bool)
+	for _, diskID := range diskIDs {
+		attached[diskID] = false
+	}
+
+	vmID, err := cc.InstanceIDFromNodeName(context.TODO(), nodeName)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: cc.InstanceID failed for DiskIsAttached. Error[%v]", err)
+		return attached, err
+	}
+
+	for _, diskID := range diskIDs {
+		disk, err := cc.apiClient.GetDisk(diskID)
+		if err != nil {
+			glog.Warningf("VKE Cloud Provider: failed to get VMs for persistent disk %s, err [%v]",
+				diskID, err)
+		} else {
+			if disk.VM == vmID && StringVal(disk.State) == DiskStateAttached {
+				attached[diskID] = true
+			}
+		}
+	}
+
+	return attached, nil
+}
+
+// Create a volume of given size (in GB).
+func (cc *CascadeCloud) CreateDisk(volumeOptions *VolumeOptions) (diskID string, err error) {
+	// Get Zones for the cluster
+	zones, err := cc.apiClient.GetZones()
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to Get zones for the cluster. Error[%v]", err)
+		return "", err
+	}
+
+	// Pick a zone to place the disk in.
+	zoneSet := sets.NewString()
+	for _, zone := range zones {
+		zoneSet.Insert(zone)
+	}
+	var zone string
+	if !volumeOptions.ZonePresent && !volumeOptions.ZonesPresent {
+		zone = volumeutil.ChooseZoneForVolume(zoneSet, volumeOptions.Name)
+	}
+	if !volumeOptions.ZonePresent && volumeOptions.ZonesPresent {
+		userZoneSet, err := volumeutil.ZonesToSet(volumeOptions.AvailabilityZones)
+		if err != nil {
+			return "", err
+		}
+		if !zoneSet.IsSuperset(userZoneSet) {
+			return "", fmt.Errorf("VKE Cloud Provider: Zones '%s' is invalid. "+
+				"Please use one or more of the following zones: %v", volumeOptions.AvailabilityZones, zoneSet.List())
+		}
+		zone = volumeutil.ChooseZoneForVolume(userZoneSet, volumeOptions.Name)
+	}
+	if volumeOptions.ZonePresent && !volumeOptions.ZonesPresent {
+		if err := volumeutil.ValidateZone(volumeOptions.AvailabilityZone); err != nil {
+			return "", err
+		}
+		if !zoneSet.Has(volumeOptions.AvailabilityZone) {
+			return "", fmt.Errorf("VKE Cloud Provider: Zone '%s' is invalid. "+
+				"Please use one of the following zones: %v", volumeOptions.AvailabilityZone, zoneSet.List())
+		}
+		zone = volumeOptions.AvailabilityZone
+	}
+
+	diskSpec := DiskCreateSpec{}
+	diskSpec.Name = StringPtr(volumeOptions.Name)
+	diskSpec.Flavor = StringPtr(volumeOptions.Type)
+	diskSpec.CapacityGB = Int32Ptr(int32(volumeOptions.CapacityGB))
+	diskSpec.Kind = StringPtr(DiskSpecKind)
+	diskSpec.Zone = StringPtr(zone)
+	diskSpec.Encrypted = BoolPtr(volumeOptions.Encrypted)
+
+	task, err := cc.apiClient.CreateDisk(&diskSpec)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to CreateDisk. Error[%v]", err)
+		return "", err
+	}
+
+	waitTask, err := cc.apiClient.WaitForTask(StringVal(task.ID))
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to wait for task to CreateDisk. Error[%v]", err)
+		return "", err
+	}
+
+	return StringVal(waitTask.Entity.ID), nil
+}
+
+// Deletes a volume given volume name.
+func (cc *CascadeCloud) DeleteDisk(diskID string) error {
+	task, err := cc.apiClient.DeleteDisk(diskID)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to DeleteDisk. Error[%v]", err)
+		// If we get a DiskNotFound error, we assume that the disk is already deleted. So we don't return an error here.
+		switch err.(type) {
+		case APIError:
+			if err.(APIError).ErrorCode == DiskNotFoundError {
+				return nil
+			}
+			if err.(APIError).ErrorCode == DiskInUseError {
+				return volume.NewDeletedVolumeInUseError(err.Error())
+			}
+		}
+		return err
+	}
+
+	_, err = cc.apiClient.WaitForTask(StringVal(task.ID))
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to wait for task to DeleteDisk. Error[%v]", err)
+		return err
+	}
+
+	return nil
+}
+
+// Gets the zone and region for the volume.
+func (cc *CascadeCloud) GetVolumeLabels(diskID string) (map[string]string, error) {
+	disk, err := cc.apiClient.GetDisk(diskID)
+	if err != nil {
+		glog.Errorf("VKE Cloud Provider: Failed to GetDisk for GetVolumeLabels. Error[%v]", err)
+		return nil, err
+	}
+
+	labels := make(map[string]string)
+	labels[apis.LabelZoneFailureDomain] = StringVal(disk.Zone)
+	labels[apis.LabelZoneRegion] = cc.cfg.Global.Region
+
+	return labels, nil
+}
diff --git a/pkg/cloudprovider/providers/cascade/cascade_instances.go b/pkg/cloudprovider/providers/cascade/cascade_instances.go
new file mode 100644
index 0000000000..b7d14cb09a
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/cascade_instances.go
@@ -0,0 +1,129 @@
+package cascade
+
+import (
+	"context"
+	"errors"
+	"github.com/golang/glog"
+	"os"
+	"strings"
+
+	"k8s.io/api/core/v1"
+	k8stypes "k8s.io/apimachinery/pkg/types"
+	"k8s.io/kubernetes/pkg/cloudprovider"
+)
+
+// NodeAddresses is an implementation of Instances.NodeAddresses. In the future, private IP address, external IP, etc.
+// will be added based on need.
+func (cc *CascadeCloud) NodeAddresses(ctx context.Context, nodeName k8stypes.NodeName) ([]v1.NodeAddress, error) {
+	return []v1.NodeAddress{
+		{Type: v1.NodeInternalIP, Address: cc.cfg.Global.IPAddress},
+		{Type: v1.NodeInternalDNS, Address: cc.cfg.Global.DNSName},
+	}, nil
+}
+
+// NodeAddressesByProviderID returns the node addresses of an instances with the specified unique providerID
+// This method will not be called from the node that is requesting this ID. i.e. metadata service
+// and other local methods cannot be used here
+func (cc *CascadeCloud) NodeAddressesByProviderID(ctx context.Context, providerID string) ([]v1.NodeAddress, error) {
+	// Get the name of the VM using the ID and generate the DNS name based on the VM name.
+	vm, err := cc.apiClient.GetVM(providerID)
+	if err != nil {
+		return nil, err
+	}
+	// Get the DNS name for the master VM and replace the VM name portion with the requested VM name.
+	dnsNameParts := strings.SplitN(cc.cfg.Global.DNSName, ".", 2)
+	if len(dnsNameParts) != 2 {
+		return nil, errors.New("Cascade cloud provider: Invalid DNS name specified in the configuation. " +
+			"Cannot get NodeAddressByProviderID.")
+	}
+	dnsAddress := StringVal(vm.Name) + dnsNameParts[1]
+	addresses := []v1.NodeAddress{}
+	addresses = append(addresses, v1.NodeAddress{Type: v1.NodeInternalDNS, Address: dnsAddress})
+	return addresses, nil
+}
+
+func (cc *CascadeCloud) AddSSHKeyToAllInstances(ctx context.Context, user string, keyData []byte) error {
+	return errors.New("unimplemented")
+}
+
+// Current node name returns node name based on host name. For Cascade Kubernetes nodes, we will use host name as the
+// node name.
+func (cc *CascadeCloud) CurrentNodeName(ctx context.Context, hostname string) (k8stypes.NodeName, error) {
+	cc.localK8sHostname = hostname
+	return k8stypes.NodeName(hostname), nil
+}
+
+// InstanceIDFromNodeName returns the cloud provider ID of the specified instance.
+func (cc *CascadeCloud) InstanceIDFromNodeName(ctx context.Context, nodeName k8stypes.NodeName) (string, error) {
+	return getInstanceIDFromNodeName(nodeName)
+}
+
+// InstanceExistsByProviderID returns true if the instance with the given provider id still exists and is running.
+// If false is returned with no error, the instance will be immediately deleted by the cloud controller manager.
+func (cc *CascadeCloud) InstanceExistsByProviderID(ctx context.Context, providerID string) (bool, error) {
+	return false, errors.New("unimplemented")
+}
+
+// InstanceID returns the cloud provider ID of the specified instance.
+// Note: We call Cascade Controller here to check if the instance is alive or not. That check is used by Kubernetes
+// to proactively remove nodes that the cloud provider believes is no longer available.
+func (cc *CascadeCloud) InstanceID(ctx context.Context, nodeName k8stypes.NodeName) (string, error) {
+	return getInstanceIDAndLivelinessFromNodeName(cc, nodeName)
+}
+
+// This gets the Cascade VM ID from the Kubernetes node name.
+func getInstanceIDFromNodeName(nodeName k8stypes.NodeName) (string, error) {
+	// nodeName is of the format master-instance-id or worker-instance-id. To compute the instance ID, we need to just
+	// get the portion after master- or worker-. That is what we do below.
+	nodeParts := strings.SplitN(string(nodeName), "-", 2)
+	if len(nodeParts) != 2 {
+		return "", errors.New("Cascade cloud provider: Invalid node name. Cannot fetch instance ID.")
+	}
+	return nodeParts[1], nil
+}
+
+// This gets the Cascade VM ID and its liveliness from the Kubernetes node name.
+func getInstanceIDAndLivelinessFromNodeName(cc *CascadeCloud, nodeName k8stypes.NodeName) (string, error) {
+	instanceID, err := getInstanceIDFromNodeName(nodeName)
+	if err != nil {
+		return "", err
+	}
+	// Get local hostname. We need to do this check to make sure we call VKE controller only from master nodes
+	// because worker nodes cannot login to VKE controller.
+	hostname, err := os.Hostname()
+	if err != nil {
+		glog.Errorf("Cascade Cloud Provider: get hostname failed. Error[%v]", err)
+		return "", err
+	}
+	// Note: Kubelet running on the worker node do not need to call VKE.
+	if strings.HasPrefix(hostname, MasterPrefix) {
+		_, err := cc.apiClient.GetVM(instanceID)
+		if err != nil {
+			switch err.(type) {
+			case APIError:
+				if err.(APIError).ErrorCode == VMNotFoundError {
+					// If instance no longer exists, we will return instance not found error
+					glog.Warningf("Cascade Cloud Provider: VM %s does not exist", instanceID)
+					return "", cloudprovider.InstanceNotFound
+				}
+			}
+		}
+	}
+	return instanceID, nil
+}
+
+// InstanceTypeByProviderID returns the cloudprovider instance type of the node with the specified unique providerID
+// This method will not be called from the node that is requesting this ID. i.e. metadata service
+// and other local methods cannot be used here
+func (cc *CascadeCloud) InstanceTypeByProviderID(ctx context.Context, providerID string) (string, error) {
+	return "", errors.New("unimplemented")
+}
+
+func (cc *CascadeCloud) InstanceType(ctx context.Context, nodeName k8stypes.NodeName) (string, error) {
+	return "", nil
+}
+
+// InstanceShutdownByProviderID returns true if the instance is in safe state to detach volumes
+func (cc *CascadeCloud) InstanceShutdownByProviderID(ctx context.Context, providerID string) (bool, error) {
+	return false, cloudprovider.NotImplemented
+}
diff --git a/pkg/cloudprovider/providers/cascade/cascade_instances_test.go b/pkg/cloudprovider/providers/cascade/cascade_instances_test.go
new file mode 100644
index 0000000000..8fb314def1
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/cascade_instances_test.go
@@ -0,0 +1,44 @@
+package cascade
+
+import (
+	"context"
+	"strings"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+	"k8s.io/api/core/v1"
+)
+
+const configFile = `
+[Global]
+target = target
+tenantName = tenant
+clusterID = cluster-id
+authEndpoint = auth-endpoint
+domainName = domain.test
+dnsName = node.domain.test
+region = region
+zone = zone
+ipAddress = 1.1.1.1
+`
+
+func getCascadeInstance() (*CascadeCloud, error) {
+	cfg, err := readConfig(strings.NewReader(configFile))
+	return &CascadeCloud{
+		cfg:              cfg,
+		localHostname:    "hostname",
+		localK8sHostname: "",
+	}, err
+}
+
+func TestNodeAddresses(t *testing.T) {
+	cc, err := getCascadeInstance()
+	assert.Nil(t, err)
+	expectedNodeAddresses := []v1.NodeAddress{
+		{Type: v1.NodeInternalIP, Address: "1.1.1.1"},
+		{Type: v1.NodeInternalDNS, Address: "node.domain.test"},
+	}
+	actualNodeAddresses, err := cc.NodeAddresses(context.TODO(), "node")
+	assert.Nil(t, err)
+	assert.Equal(t, expectedNodeAddresses, actualNodeAddresses)
+}
diff --git a/pkg/cloudprovider/providers/cascade/cascade_loadbalancer.go b/pkg/cloudprovider/providers/cascade/cascade_loadbalancer.go
new file mode 100644
index 0000000000..c9052b9983
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/cascade_loadbalancer.go
@@ -0,0 +1,295 @@
+package cascade
+
+import (
+	"context"
+	"fmt"
+	"github.com/golang/glog"
+	"k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/kubernetes/pkg/api/v1/service"
+	"k8s.io/kubernetes/pkg/cloudprovider"
+)
+
+const TCP_PROTOCOL = "TCP"
+
+const HTTP_PROTOCOL = "HTTP"
+
+const ServiceAnnotationLoadBalancerInternal = "service.beta.kubernetes.io/vke-load-balancer-internal"
+
+// EnsureLoadBalancer creates or updates a Cascade load balancer
+func (cc *CascadeCloud) EnsureLoadBalancer(ctx context.Context, clusterName string, k8sService *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
+	logger := newLoadBalancerLogger(clusterName, k8sService, "EnsureLoadBalancer")
+
+	loadBalancerName := cloudprovider.GetLoadBalancerName(k8sService)
+	logger.Infof("Load balancer name: %s", loadBalancerName)
+
+	// Sanity checks
+	if k8sService.Spec.SessionAffinity != v1.ServiceAffinityNone {
+		logger.Errorf("Unsupported load balancer session affinity: %+v", k8sService.Spec.SessionAffinity)
+		return nil, fmt.Errorf("Unsupported load balancer session affinity: %+v", k8sService.Spec.SessionAffinity)
+	}
+
+	if len(k8sService.Spec.Ports) == 0 {
+		logger.Errorf("No port mapping is specified")
+		return nil, fmt.Errorf("No port mapping is specified")
+	}
+
+	// Create load balancer port maps
+	portMaps := []*LoadBalancerPortMap{}
+	for _, port := range k8sService.Spec.Ports {
+		if port.Protocol != v1.ProtocolTCP {
+			logger.Warningf("Ignoring port that does not use TCP protocol: %+v", port)
+			continue
+		}
+
+		if port.NodePort == 0 {
+			logger.Warningf("Ignoring port without node port defined: %+v", port)
+			continue
+		}
+
+		// TODO: For now we only support SSL pass through. All port mappings are using TCP protocol.
+		//       Also note that we allow all external traffic to access the ports.
+		portMap := &LoadBalancerPortMap{
+			InstancePort:         Int64Ptr(int64(port.NodePort)),
+			InstanceProtocol:     StringPtr(TCP_PROTOCOL),
+			LoadBalancerPort:     Int64Ptr(int64(port.Port)),
+			LoadBalancerProtocol: StringPtr(TCP_PROTOCOL),
+		}
+		portMaps = append(portMaps, portMap)
+	}
+
+	// Create load balancer health check
+	healthCheck := &LoadBalancerHealthCheck{
+		HealthyThreshold:  5,
+		IntervalInSeconds: 10,
+	}
+	if healthCheckPath, healthCheckNodePort := service.GetServiceHealthCheckPathPort(k8sService); healthCheckPath != "" {
+		logger.Infof("HTTP health checks on: %s:%d", healthCheckPath, healthCheckNodePort)
+		healthCheck.Path = StringPtr(healthCheckPath)
+		healthCheck.Port = Int64Ptr(int64(healthCheckNodePort))
+		healthCheck.Protocol = StringPtr(HTTP_PROTOCOL)
+	} else {
+		logger.Infof("TCP health check on port: %d", Int64Val(portMaps[0].InstancePort))
+		healthCheck.Port = portMaps[0].InstancePort
+		healthCheck.Protocol = StringPtr(TCP_PROTOCOL)
+	}
+
+	// Create load balancer
+	createSpec := &LoadBalancerCreateSpec{
+		Name:        StringPtr(loadBalancerName),
+		Type:        StringPtr(getLoadBalancerType(k8sService)),
+		PortMaps:    portMaps,
+		HealthCheck: healthCheck,
+		SubDomain:   StringPtr(k8sService.Name),
+	}
+	logger.Infof("Load balancer create spec: %+v", *createSpec)
+
+	task, err := cc.apiClient.CreateOrUpdateLoadBalancer(createSpec)
+	if err != nil {
+		logger.Errorf("Failed to create or update load balancer. Error: [%v]", err)
+		return nil, err
+	}
+
+	_, err = cc.apiClient.WaitForTask(StringVal(task.ID))
+	if err != nil {
+		logger.Errorf("Failed to poll task status of creating or updating load balancer. Error: [%v]", err)
+		return nil, err
+	}
+
+	// Apply VM update to load balancer
+	err = cc.updateLoadBalancerVMs(nodes, loadBalancerName, logger)
+	if err != nil {
+		// The private function already did logging. No need to log again.
+		return nil, err
+	}
+
+	// Get load balancer
+	loadBalancer, err := cc.apiClient.GetLoadBalancer(StringPtr(loadBalancerName))
+	if err != nil {
+		glog.Errorf("Failed to get load balancer. Error: [%v]", err)
+		return nil, err
+	}
+
+	return toLoadBalancerStatus(loadBalancer), nil
+}
+
+// GetLoadBalancer returns the information about a Cascade load balancer
+func (cc *CascadeCloud) GetLoadBalancer(ctx context.Context, clusterName string, k8sService *v1.Service) (*v1.LoadBalancerStatus, bool, error) {
+	logger := newLoadBalancerLogger(clusterName, k8sService, "GetLoadBalancer")
+
+	loadBalancerName := cloudprovider.GetLoadBalancerName(k8sService)
+	logger.Infof("Load balancer name: %s", loadBalancerName)
+
+	// Get load balancer
+	loadBalancer, err := cc.apiClient.GetLoadBalancer(StringPtr(loadBalancerName))
+	if err != nil {
+		logger.Errorf("Failed to get load balancer. Error: [%v]", err)
+		// Do not return error here because we want the caller of this function to determine
+		// what to do with the not-found situation.
+		switch err.(type) {
+		case APIError:
+			if err.(APIError).ErrorCode == NotFoundError {
+				return nil, false, nil
+			}
+		}
+		return nil, false, err
+	}
+
+	return toLoadBalancerStatus(loadBalancer), true, nil
+}
+
+// UpdateLoadBalancer updates the node information of a Cascade load balancer
+func (cc *CascadeCloud) UpdateLoadBalancer(ctx context.Context, clusterName string, k8sService *v1.Service, nodes []*v1.Node) error {
+	logger := newLoadBalancerLogger(clusterName, k8sService, "UpdateLoadBalancer")
+
+	loadBalancerName := cloudprovider.GetLoadBalancerName(k8sService)
+	logger.Infof("Load balancer name: %s", loadBalancerName)
+
+	err := cc.updateLoadBalancerVMs(nodes, loadBalancerName, logger)
+	if err != nil {
+		// The private function already did logging. No need to log again.
+		return err
+	}
+
+	return nil
+}
+
+// EnsureLoadBalancerDeleted deletes a Cascade load balancer
+func (cc *CascadeCloud) EnsureLoadBalancerDeleted(ctx context.Context, clusterName string, k8sService *v1.Service) error {
+	logger := newLoadBalancerLogger(clusterName, k8sService, "EnsureLoadBalancerDeleted")
+
+	loadBalancerName := cloudprovider.GetLoadBalancerName(k8sService)
+	logger.Infof("Load balancer name: %s", loadBalancerName)
+
+	task, err := cc.apiClient.DeleteLoadBalancer(StringPtr(loadBalancerName), k8sService.Name)
+	if err != nil {
+		logger.Errorf("Failed to delete load balancer. Error: [%v]", err)
+		// If we get a NotFound error, we assume that the load balancer is already deleted. So we don't return an error
+		// here.
+		switch err.(type) {
+		case APIError:
+			if err.(APIError).ErrorCode == NotFoundError {
+				return nil
+			}
+		}
+		return err
+	}
+
+	_, err = cc.apiClient.WaitForTask(StringVal(task.ID))
+	if err != nil {
+		logger.Errorf("Failed to poll task status of deleting load balancer. Error: [%v]", err)
+		return err
+	}
+
+	return nil
+}
+
+func (cc *CascadeCloud) updateLoadBalancerVMs(
+	nodes []*v1.Node, loadBalancerName string, logger *loadBalancerLogger) error {
+
+	// Apply VM update to the load balancer
+	loadBalancerVMs := make([]*LoadBalancerVM, 0)
+
+	for _, node := range nodes {
+		// If the node does not have a name, we cannot derive its instance ID. Therefore we skip this node.
+		if len(node.Name) == 0 {
+			logger.Warningf("Node %s does not have a name. Skip updating this VM for load balancer", node.UID)
+			continue
+		}
+
+		// If we cannot get the instance ID, something is wrong on the Cascade Controller side.
+		// However, we should tolerate such failure and continue the load balancer VM update
+		// by skipping this VM.
+		instanceID, err := cc.InstanceIDFromNodeName(context.TODO(), types.NodeName(node.Name))
+		if err != nil {
+			logger.Warningf("Unable to get instance ID for node %s, skip updating this VM for load balancer. Error [%v]", node.Name, err)
+			continue
+		}
+
+		loadBalancerVMs = append(loadBalancerVMs, &LoadBalancerVM{
+			ID: StringPtr(instanceID),
+		})
+	}
+
+	if len(loadBalancerVMs) == 0 {
+		logger.Infof("No nodes to be added to the load balancer. Skip updating load balancer VMs")
+		return nil
+	}
+
+	vmUpdate := &LoadBalancerVMUpdate{
+		VMIds: loadBalancerVMs,
+	}
+	logger.Infof("Load balancer VM update spec: %+v", vmUpdate.VMIds)
+
+	task, err := cc.apiClient.ApplyVMsToLoadBalancer(StringPtr(loadBalancerName), vmUpdate)
+	if err != nil {
+		logger.Errorf("Failed to update load balancer VMs. Error: [%v]", err)
+		return err
+	}
+
+	_, err = cc.apiClient.WaitForTask(StringVal(task.ID))
+	if err != nil {
+		logger.Errorf("Failed to poll task status of updating load balancer VMs. Error: [%v]", err)
+		return err
+	}
+
+	return nil
+}
+
+func toLoadBalancerStatus(lb *LoadBalancer) *v1.LoadBalancerStatus {
+	var endpoint string
+	if lb != nil && lb.Endpoint != nil {
+		endpoint = StringVal(lb.Endpoint)
+	}
+
+	return &v1.LoadBalancerStatus{
+		Ingress: []v1.LoadBalancerIngress{
+			{
+				Hostname: endpoint,
+			},
+		},
+	}
+}
+
+type loadBalancerLogger struct {
+	clusterName string
+	k8sService  *v1.Service
+	callingFunc string
+}
+
+func newLoadBalancerLogger(clusterName string, k8sService *v1.Service, callingFunc string) *loadBalancerLogger {
+	return &loadBalancerLogger{
+		clusterName: clusterName,
+		k8sService:  k8sService,
+		callingFunc: callingFunc,
+	}
+}
+
+func (l *loadBalancerLogger) getLogMsg(
+	msgTemplate string, args ...interface{}) string {
+
+	errorMsg := fmt.Sprintf("Cascade Cloud Provider::%s::Cluster [%s] Service [%s]: %s",
+		l.callingFunc, l.clusterName, l.k8sService.Name,
+		msgTemplate)
+	return fmt.Sprintf(errorMsg, args)
+}
+
+func (l *loadBalancerLogger) Errorf(msgTemplate string, args ...interface{}) {
+	glog.Errorln(l.getLogMsg(msgTemplate, args))
+}
+
+func (l *loadBalancerLogger) Warningf(msgTemplate string, args ...interface{}) {
+	glog.Warningln(l.getLogMsg(msgTemplate, args))
+}
+
+func (l *loadBalancerLogger) Infof(msgTemplate string, args ...interface{}) {
+	glog.Infoln(l.getLogMsg(msgTemplate, args))
+}
+
+// Check if service requires an internal load balancer.
+func getLoadBalancerType(service *v1.Service) string {
+	if _, found := service.Annotations[ServiceAnnotationLoadBalancerInternal]; found {
+		return "PRIVATE"
+	}
+	return "PUBLIC"
+}
diff --git a/pkg/cloudprovider/providers/cascade/client.go b/pkg/cloudprovider/providers/cascade/client.go
new file mode 100644
index 0000000000..400e3777d0
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/client.go
@@ -0,0 +1,400 @@
+package cascade
+
+import (
+	"bytes"
+	"crypto/tls"
+	"crypto/x509"
+	"encoding/json"
+	"fmt"
+	"github.com/golang/glog"
+	"net/http"
+	"strings"
+	"time"
+)
+
+// Represents stateless context needed to call Cascade APIs.
+// Note that we are implementing the Cascade APIs manually instead of using the swagger generated code
+// because swagger uses a different version of openapi library than kubernetes. It is difficult to
+// address the version conflict to make it compile.
+type Client struct {
+	cfg        *ClientConfig
+	options    ClientOptions
+	restClient *restClient
+}
+
+type ClientConfig struct {
+	tenantName string
+	clusterID  string
+	region     string
+	endpoint   string
+}
+
+// Represents Tokens
+type TokenOptions struct {
+	AccessToken  string `json:"access_token"`
+	ExpiresIn    int    `json:"expires_in"`
+	RefreshToken string `json:"refresh_token,omitempty"`
+	IDToken      string `json:"id_token"`
+	TokenType    string `json:"token_type"`
+}
+
+type TokenCallback func(string)
+
+// Options for Client
+type ClientOptions struct {
+	// When using the Tasks.Wait APIs, defines the duration of how long
+	// we should continue to poll the server. Default is 30 minutes.
+	// TasksAPI.WaitTimeout() can be used to specify timeout on
+	// individual calls.
+	TaskPollTimeout time.Duration
+
+	// Whether or not to ignore any TLS errors when talking to Cascade,
+	// false by default.
+	IgnoreCertificate bool
+
+	// List of root CA's to use for server validation
+	// nil by default.
+	RootCAs *x509.CertPool
+
+	// For tasks APIs, defines the number of retries to make in the event
+	// of an error. Default is 3.
+	TaskRetryCount int
+
+	// Tokens for user authentication. Default is empty.
+	TokenOptions *TokenOptions
+}
+
+const minimumTaskPollDelay = 500 * time.Millisecond
+
+// Creates a new Cascade client which can be used to make API calls to Cascade.
+func NewClient(cfg *CascadeConfig, authClient *AuthClient) (c *Client, err error) {
+	tokenOptions, err := authClient.GetTokensByMachineAccount()
+	if err != nil {
+		glog.Errorf("Cascade Cloud Provider: Failed to create new client due to error: %+v", err)
+		return
+	}
+
+	options := &ClientOptions{
+		TaskPollTimeout:   30 * time.Minute,
+		TaskRetryCount:    3,
+		TokenOptions:      tokenOptions,
+		IgnoreCertificate: false,
+		RootCAs:           nil,
+	}
+
+	tr := &http.Transport{
+		TLSClientConfig: &tls.Config{
+			InsecureSkipVerify: options.IgnoreCertificate,
+			RootCAs:            options.RootCAs},
+	}
+
+	tokenCallback := func(newToken string) {
+		c.options.TokenOptions.AccessToken = newToken
+	}
+
+	restClient := &restClient{
+		authClient:                authClient,
+		httpClient:                &http.Client{Transport: tr},
+		UpdateAccessTokenCallback: tokenCallback,
+	}
+
+	clientConfig := &ClientConfig{
+		tenantName: cfg.Global.TenantName,
+		clusterID:  cfg.Global.ClusterID,
+		region:     cfg.Global.Region,
+		endpoint:   strings.TrimRight(cfg.Global.CloudTarget, "/"),
+	}
+
+	c = &Client{
+		cfg:        clientConfig,
+		restClient: restClient,
+		// Ensure a copy of options is made, rather than using a pointer
+		// which may change out from underneath if misused by the caller.
+		options: *options,
+	}
+
+	return
+}
+
+// Gets VM with the specified ID.
+func (api *Client) GetVM(vmID string) (vm *VM, err error) {
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/vms/%s", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, vmID)
+	res, err := api.restClient.Get(uri, api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	res, err = getError(res)
+	if err != nil {
+		return
+	}
+	vm = &VM{}
+	err = json.NewDecoder(res.Body).Decode(vm)
+	return
+}
+
+// Gets disk with the specified ID.
+func (api *Client) GetDisk(diskID string) (disk *PersistentDisk, err error) {
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/disks/%s", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, diskID)
+	res, err := api.restClient.Get(uri, api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	res, err = getError(res)
+	if err != nil {
+		return
+	}
+	disk = &PersistentDisk{}
+	err = json.NewDecoder(res.Body).Decode(disk)
+	return
+}
+
+// Creates a disk under the cluster.
+func (api *Client) CreateDisk(spec *DiskCreateSpec) (task *Task, err error) {
+	body, err := json.Marshal(spec)
+	if err != nil {
+		return
+	}
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/disks", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID)
+	res, err := api.restClient.Post(uri, "application/json", bytes.NewReader(body), api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	task, err = getTask(getError(res))
+	return
+}
+
+// Deletes a disk with the specified ID.
+func (api *Client) DeleteDisk(diskID string) (task *Task, err error) {
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/disks/%s", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, diskID)
+	res, err := api.restClient.Delete(uri, api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	task, err = getTask(getError(res))
+	return
+}
+
+// Attaches a disk to the specified VM.
+func (api *Client) AttachDisk(vmID string, op *VMDiskOperation) (task *Task, err error) {
+	body, err := json.Marshal(op)
+	if err != nil {
+		return
+	}
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/vms/%s/attach_disk", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, vmID)
+	res, err := api.restClient.Post(uri, "application/json", bytes.NewReader(body), api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	task, err = getTask(getError(res))
+	return
+}
+
+// Detaches a disk from the specified VM.
+func (api *Client) DetachDisk(vmID string, op *VMDiskOperation) (task *Task, err error) {
+	body, err := json.Marshal(op)
+	if err != nil {
+		return
+	}
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/vms/%s/detach_disk", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, vmID)
+	res, err := api.restClient.Post(uri, "application/json", bytes.NewReader(body), api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	task, err = getTask(getError(res))
+	return
+}
+
+// Gets a task by ID.
+func (api *Client) GetTask(taskID string) (task *Task, err error) {
+	uri := fmt.Sprintf("%s/v1/tenants/%s/tasks/%s?region=%s", api.cfg.endpoint, api.cfg.tenantName,
+		taskID, api.cfg.region)
+	res, err := api.restClient.Get(uri, api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	result, err := getTask(getError(res))
+	return result, err
+}
+
+// Waits for a task to complete by polling the tasks API until a task returns with the state COMPLETED or ERROR.
+func (api *Client) WaitForTask(taskID string) (task *Task, err error) {
+	start := time.Now()
+	numErrors := 0
+	maxErrors := api.options.TaskRetryCount
+	backoffMultiplier := 1
+
+	for time.Since(start) < api.options.TaskPollTimeout {
+		task, err = api.GetTask(taskID)
+		if err != nil {
+			switch err.(type) {
+			// If an ApiError comes back, something is wrong, return the error to the caller
+			case APIError:
+				return
+				// For other errors, retry before giving up
+			default:
+				numErrors++
+				if numErrors > maxErrors {
+					return
+				}
+			}
+		} else {
+			// Reset the error count any time a successful call is made
+			numErrors = 0
+			if StringVal(task.State) == "COMPLETED" {
+				return
+			}
+			if StringVal(task.State) == "ERROR" {
+				err = TaskError{StringVal(task.ID), getFailedStep(task)}
+				return
+			}
+		}
+
+		// Perform backoff based on how long it has been since we started polling. The logic is as follows:
+		// For the first 10 seconds, poll every 500 milliseconds.
+		// From there till the first 1 minute, poll every 1 second.
+		// From there till the first 10 minutes, poll every 5 seconds.
+		// From there till the timeout (30 minutes), poll every 10 seconds.
+		elapsedTime := time.Since(start)
+		if elapsedTime > 10*time.Second && elapsedTime <= 60*time.Second {
+			backoffMultiplier = 2
+		} else if elapsedTime > 60*time.Second && elapsedTime <= 600*time.Second {
+			backoffMultiplier = 10
+		} else if elapsedTime > 600*time.Second && elapsedTime <= api.options.TaskPollTimeout {
+			backoffMultiplier = 20
+		}
+		time.Sleep(time.Duration(backoffMultiplier) * minimumTaskPollDelay)
+	}
+	err = TaskTimeoutError{taskID}
+	return
+}
+
+// CreateOrUpdateLoadBalancer creates a load balancer if not existed, or update one otherwise
+func (api *Client) CreateOrUpdateLoadBalancer(spec *LoadBalancerCreateSpec) (*Task, error) {
+	body, err := json.Marshal(spec)
+	if err != nil {
+		return nil, err
+	}
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/loadbalancers", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID)
+	res, err := api.restClient.Post(uri, "application/json", bytes.NewReader(body), api.options.TokenOptions)
+	if err != nil {
+		return nil, err
+	}
+	defer res.Body.Close()
+	return getTask(getError(res))
+}
+
+// GetLoadBalancer returns a load balancer by name
+func (api *Client) GetLoadBalancer(loadBalancerName *string) (*LoadBalancer, error) {
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/loadbalancers/%s", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, StringVal(loadBalancerName))
+	res, err := api.restClient.Get(uri, api.options.TokenOptions)
+	if err != nil {
+		return nil, err
+	}
+	defer res.Body.Close()
+	res, err = getError(res)
+	if err != nil {
+		return nil, err
+	}
+	loadBalancer := &LoadBalancer{}
+	err = json.NewDecoder(res.Body).Decode(loadBalancer)
+	return loadBalancer, err
+}
+
+// DeleteLoadBalancer deletes a load balancer by name
+func (api *Client) DeleteLoadBalancer(loadBalancerName *string, subDomain string) (*Task, error) {
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/loadbalancers/%s", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, StringVal(loadBalancerName))
+
+	if len(subDomain) > 0 {
+		uri = fmt.Sprintf(uri+"?sub-domain=%s", subDomain)
+	}
+
+	res, err := api.restClient.Delete(uri, api.options.TokenOptions)
+	if err != nil {
+		return nil, err
+	}
+	return getTask(getError(res))
+}
+
+// ApplyVMsToLoadBalancer updates the instances that are registered with the load balancer
+func (api *Client) ApplyVMsToLoadBalancer(loadBalancerName *string, update *LoadBalancerVMUpdate) (*Task, error) {
+	body, err := json.Marshal(update)
+	if err != nil {
+		return nil, err
+	}
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/loadbalancers/%s/update_vms", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID, StringVal(loadBalancerName))
+	res, err := api.restClient.Post(uri, "application/json", bytes.NewReader(body), api.options.TokenOptions)
+	if err != nil {
+		return nil, err
+	}
+	defer res.Body.Close()
+	return getTask(getError(res))
+}
+
+// Gets all the zones in which the cluster has the VMs in.
+func (api *Client) GetZones() (zones []string, err error) {
+	// Call the version 2 zones API to use generic zones.
+	uri := fmt.Sprintf("%s/v1/tenants/%s/clusters/%s/zones?version=2", api.cfg.endpoint, api.cfg.tenantName,
+		api.cfg.clusterID)
+	res, err := api.restClient.Get(uri, api.options.TokenOptions)
+	if err != nil {
+		return
+	}
+	defer res.Body.Close()
+	res, err = getError(res)
+	if err != nil {
+		return
+	}
+	err = json.NewDecoder(res.Body).Decode(&zones)
+	return
+}
+
+// Reads a task object out of the HTTP response. Takes an error argument
+// so that GetTask can easily wrap GetError. This function will do nothing
+// if e is not nil.
+// e.g. res, err := getTask(getError(someApi.Get()))
+func getTask(res *http.Response, e error) (*Task, error) {
+	if e != nil {
+		return nil, e
+	}
+	var task Task
+	err := json.NewDecoder(res.Body).Decode(&task)
+	if err != nil {
+		return nil, err
+	}
+	if StringVal(task.State) == "ERROR" {
+		// Critical: return task as well, so that it can be examined
+		// for error details.
+		return &task, TaskError{StringVal(task.ID), getFailedStep(&task)}
+	}
+	return &task, nil
+}
+
+// Gets the failed step in the task to get error details for failed task.
+func getFailedStep(task *Task) (step Step) {
+	var errorStep Step
+	for _, s := range task.Steps {
+		if StringVal(s.State) == "ERROR" {
+			errorStep = *s
+			break
+		}
+	}
+
+	return errorStep
+}
diff --git a/pkg/cloudprovider/providers/cascade/oidcclient.go b/pkg/cloudprovider/providers/cascade/oidcclient.go
new file mode 100644
index 0000000000..6a71cc184f
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/oidcclient.go
@@ -0,0 +1,297 @@
+package cascade
+
+import (
+	"crypto/tls"
+	"crypto/x509"
+	"encoding/json"
+	"encoding/pem"
+	"fmt"
+	"io/ioutil"
+	"log"
+	"net/http"
+	"net/url"
+	"strings"
+)
+
+const tokenScope string = "openid offline_access"
+
+// OIDCClient is client for OIDC
+type OIDCClient struct {
+	httpClient *http.Client
+	logger     *log.Logger
+
+	Endpoint string
+	Options  *OIDCClientOptions
+}
+
+// OIDCClientOptions is OIDC client options
+type OIDCClientOptions struct {
+	// Whether or not to ignore any TLS errors when talking to Cascade,
+	// false by default.
+	IgnoreCertificate bool
+
+	// List of root CA's to use for server validation
+	// nil by default.
+	RootCAs *x509.CertPool
+
+	// The scope values to use when requesting tokens
+	TokenScope string
+}
+
+// NewOIDCClient creates an instance of OIDCClient
+func NewOIDCClient(endpoint string, options *OIDCClientOptions, logger *log.Logger) (c *OIDCClient) {
+	if logger == nil {
+		logger = log.New(ioutil.Discard, "", log.LstdFlags)
+	}
+
+	options = buildOptions(options)
+	tr := &http.Transport{
+		TLSClientConfig: &tls.Config{
+			InsecureSkipVerify: options.IgnoreCertificate,
+			RootCAs:            options.RootCAs},
+	}
+
+	c = &OIDCClient{
+		httpClient: &http.Client{Transport: tr},
+		logger:     logger,
+		Endpoint:   strings.TrimRight(endpoint, "/"),
+		Options:    options,
+	}
+	return
+}
+
+func buildOptions(options *OIDCClientOptions) (result *OIDCClientOptions) {
+	result = &OIDCClientOptions{
+		TokenScope: tokenScope,
+	}
+
+	if options == nil {
+		return
+	}
+
+	result.IgnoreCertificate = options.IgnoreCertificate
+
+	if options.RootCAs != nil {
+		result.RootCAs = options.RootCAs
+	}
+
+	if options.TokenScope != "" {
+		result.TokenScope = options.TokenScope
+	}
+
+	return
+}
+
+func (client *OIDCClient) buildURL(path string) (url string) {
+	return fmt.Sprintf("%s%s", client.Endpoint, path)
+}
+
+// Cert download helper
+
+const certDownloadPath string = "/afd/vecs/ssl"
+
+type lightWaveCert struct {
+	Value string `json:"encoded"`
+}
+
+// GetRootCerts gets root certs
+func (client *OIDCClient) GetRootCerts() (certList []*x509.Certificate, err error) {
+	// turn TLS verification off for
+	originalTr := client.httpClient.Transport
+	defer client.setTransport(originalTr)
+
+	tr := &http.Transport{
+		TLSClientConfig: &tls.Config{
+			InsecureSkipVerify: false,
+		},
+	}
+	client.setTransport(tr)
+
+	// get the certs
+	resp, err := client.httpClient.Get(client.buildURL(certDownloadPath))
+	if err != nil {
+		return
+	}
+	defer resp.Body.Close()
+	if resp.StatusCode != 200 {
+		err = fmt.Errorf("Unexpected error retrieving auth server certs: %v %s", resp.StatusCode, resp.Status)
+		return
+	}
+
+	// parse the certs
+	certsData := &[]lightWaveCert{}
+	err = json.NewDecoder(resp.Body).Decode(certsData)
+	if err != nil {
+		return
+	}
+
+	certList = make([]*x509.Certificate, len(*certsData))
+	for idx, cert := range *certsData {
+		block, _ := pem.Decode([]byte(cert.Value))
+		if block == nil {
+			err = fmt.Errorf("Unexpected response format: %v", certsData)
+			return nil, err
+		}
+
+		decodedCert, err := x509.ParseCertificate(block.Bytes)
+		if err != nil {
+			return nil, err
+		}
+
+		certList[idx] = decodedCert
+	}
+
+	return
+}
+
+func (client *OIDCClient) setTransport(tr http.RoundTripper) {
+	client.httpClient.Transport = tr
+}
+
+// Metadata request helpers
+const metadataPathFormat string = "/openidconnect/%s/.well-known/openid-configuration"
+
+// OIDCMetadataResponse is the response for Metadata request
+type OIDCMetadataResponse struct {
+	TokenEndpoint         string `json:"token_endpoint"`
+	AuthorizationEndpoint string `json:"authorization_endpoint"`
+	EndSessionEndpoint    string `json:"end_session_endpoint"`
+}
+
+func (client *OIDCClient) getMetadata(domain string) (metadata *OIDCMetadataResponse, err error) {
+	metadataPath := fmt.Sprintf(metadataPathFormat, domain)
+	request, err := http.NewRequest("GET", client.buildURL(metadataPath), nil)
+	if err != nil {
+		return nil, err
+	}
+
+	resp, err := client.httpClient.Do(request)
+	if err != nil {
+		return nil, err
+	}
+	defer resp.Body.Close()
+
+	err = client.checkResponse(resp)
+	if err != nil {
+		return nil, err
+	}
+
+	metadata = &OIDCMetadataResponse{}
+	err = json.NewDecoder(resp.Body).Decode(metadata)
+	if err != nil {
+		return nil, err
+	}
+
+	return
+}
+
+// Token request helpers
+
+const passwordGrantFormatString = "grant_type=password&username=%s&password=%s&scope=%s"
+const refreshTokenGrantFormatString = "grant_type=refresh_token&refresh_token=%s"
+const clientGrantFormatString = "grant_type=password&username=%s&password=%s&scope=%s&client_id=%s"
+
+// OIDCTokenResponse is the response for OIDC request
+type OIDCTokenResponse struct {
+	AccessToken  string `json:"access_token"`
+	ExpiresIn    int    `json:"expires_in"`
+	RefreshToken string `json:"refresh_token,omitempty"`
+	IDToken      string `json:"id_token"`
+	TokenType    string `json:"token_type"`
+}
+
+// GetTokenByPasswordGrant gets OIDC tokens by password
+func (client *OIDCClient) GetTokenByPasswordGrant(domain, username, password string) (tokens *OIDCTokenResponse, err error) {
+	metadata, err := client.getMetadata(domain)
+	if err != nil {
+		return nil, err
+	}
+
+	username = url.QueryEscape(username)
+	password = url.QueryEscape(password)
+	body := fmt.Sprintf(passwordGrantFormatString, username, password, client.Options.TokenScope)
+	return client.getToken(metadata.TokenEndpoint, body)
+}
+
+// GetClientTokenByPasswordGrant gets OIDC tokens by password
+func (client *OIDCClient) GetClientTokenByPasswordGrant(domain, username, password, clientID string) (tokens *OIDCTokenResponse, err error) {
+	metadata, err := client.getMetadata(domain)
+	if err != nil {
+		return nil, err
+	}
+
+	username = url.QueryEscape(username)
+	password = url.QueryEscape(password)
+	clientID = url.QueryEscape(clientID)
+	body := fmt.Sprintf(clientGrantFormatString, username, password, client.Options.TokenScope, clientID)
+	return client.getToken(metadata.TokenEndpoint, body)
+}
+
+// GetTokenByRefreshTokenGrant gets OIDC tokens by refresh token
+func (client *OIDCClient) GetTokenByRefreshTokenGrant(domain, refreshToken string) (tokens *OIDCTokenResponse, err error) {
+	metadata, err := client.getMetadata(domain)
+	if err != nil {
+		return nil, err
+	}
+
+	body := fmt.Sprintf(refreshTokenGrantFormatString, refreshToken)
+	return client.getToken(metadata.TokenEndpoint, body)
+}
+
+func (client *OIDCClient) getToken(tokenEndpoint, body string) (tokens *OIDCTokenResponse, err error) {
+	request, err := http.NewRequest("POST", tokenEndpoint, strings.NewReader(body))
+	if err != nil {
+		return nil, err
+	}
+	request.Header.Add("Content-Type", "application/x-www-form-urlencoded")
+
+	resp, err := client.httpClient.Do(request)
+	if err != nil {
+		return nil, err
+	}
+	defer resp.Body.Close()
+
+	err = client.checkResponse(resp)
+	if err != nil {
+		return nil, err
+	}
+
+	tokens = &OIDCTokenResponse{}
+	err = json.NewDecoder(resp.Body).Decode(tokens)
+	if err != nil {
+		return nil, err
+	}
+
+	return
+}
+
+// OIDCError is OIDC error
+type OIDCError struct {
+	Code    string `json:"error"`
+	Message string `json:"error_description"`
+}
+
+func (e OIDCError) Error() string {
+	return fmt.Sprintf("%v: %v", e.Code, e.Message)
+}
+
+func (client *OIDCClient) checkResponse(response *http.Response) (err error) {
+	if response.StatusCode/100 == 2 {
+		return
+	}
+
+	respBody, readErr := ioutil.ReadAll(response.Body)
+	if readErr != nil {
+		return fmt.Errorf(
+			"Status: %v, Body: %v [%v]", response.Status, string(respBody[:]), readErr)
+	}
+
+	var oidcErr OIDCError
+	err = json.Unmarshal(respBody, &oidcErr)
+	if err != nil || oidcErr.Code == "" {
+		return fmt.Errorf(
+			"Status: %v, Body: %v [%v]", response.Status, string(respBody[:]), readErr)
+	}
+
+	return oidcErr
+}
diff --git a/pkg/cloudprovider/providers/cascade/restclient.go b/pkg/cloudprovider/providers/cascade/restclient.go
new file mode 100644
index 0000000000..71d8d1c164
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/restclient.go
@@ -0,0 +1,262 @@
+package cascade
+
+import (
+	"bytes"
+	"encoding/json"
+	"io"
+	"io/ioutil"
+	"net/http"
+)
+
+type restClient struct {
+	httpClient                *http.Client
+	authClient                *AuthClient
+	UpdateAccessTokenCallback TokenCallback
+}
+
+type request struct {
+	Method      string
+	URL         string
+	ContentType string
+	Body        io.Reader
+	Tokens      *TokenOptions
+}
+
+type page struct {
+	Items            []interface{} `json:"items"`
+	NextPageLink     string        `json:"nextPageLink"`
+	PreviousPageLink string        `json:"previousPageLink"`
+}
+
+type documentList struct {
+	Items []interface{}
+}
+
+type bodyRewinder func() io.Reader
+
+const appJson string = "application/json"
+const expiredAuthToken int32 = 1904
+
+func (client *restClient) AppendSlice(origSlice []interface{}, dataToAppend []interface{}) []interface{} {
+	origLen := len(origSlice)
+	newLen := origLen + len(dataToAppend)
+
+	if newLen > cap(origSlice) {
+		newSlice := make([]interface{}, (newLen+1)*2)
+		copy(newSlice, origSlice)
+		origSlice = newSlice
+	}
+
+	origSlice = origSlice[0:newLen]
+	copy(origSlice[origLen:newLen], dataToAppend)
+
+	return origSlice
+}
+
+func (client *restClient) Get(url string, tokens *TokenOptions) (res *http.Response, err error) {
+	req := request{"GET", url, "", nil, tokens}
+	res, err = client.SendRequest(&req, nil)
+	return
+}
+
+func (client *restClient) GetList(endpoint string, url string, tokens *TokenOptions) (result []byte, err error) {
+	req := request{"GET", url, "", nil, tokens}
+	res, err := client.SendRequest(&req, nil)
+	if err != nil {
+		return
+	}
+	res, err = getError(res)
+	if err != nil {
+		return
+	}
+
+	decoder := json.NewDecoder(res.Body)
+	decoder.UseNumber()
+
+	page := &page{}
+	err = decoder.Decode(page)
+	if err != nil {
+		return
+	}
+
+	documentList := &documentList{}
+	documentList.Items = client.AppendSlice(documentList.Items, page.Items)
+
+	for page.NextPageLink != "" {
+		req = request{"GET", endpoint + page.NextPageLink, "", nil, tokens}
+		res, err = client.SendRequest(&req, nil)
+		if err != nil {
+			return
+		}
+		res, err = getError(res)
+		if err != nil {
+			return
+		}
+
+		decoder = json.NewDecoder(res.Body)
+		decoder.UseNumber()
+
+		page.NextPageLink = ""
+		page.PreviousPageLink = ""
+
+		err = decoder.Decode(page)
+		if err != nil {
+			return
+		}
+
+		documentList.Items = client.AppendSlice(documentList.Items, page.Items)
+	}
+
+	result, err = json.Marshal(documentList)
+
+	return
+}
+
+func (client *restClient) Post(url string, contentType string, body io.ReadSeeker, tokens *TokenOptions) (res *http.Response, err error) {
+	if contentType == "" {
+		contentType = appJson
+	}
+
+	req := request{"POST", url, contentType, body, tokens}
+	rewinder := func() io.Reader {
+		body.Seek(0, 0)
+		return body
+	}
+	res, err = client.SendRequest(&req, rewinder)
+	return
+}
+
+func (client *restClient) Patch(url string, contentType string, body io.ReadSeeker, tokens *TokenOptions) (res *http.Response, err error) {
+	if contentType == "" {
+		contentType = appJson
+	}
+
+	req := request{"PATCH", url, contentType, body, tokens}
+	rewinder := func() io.Reader {
+		body.Seek(0, 0)
+		return body
+	}
+	res, err = client.SendRequest(&req, rewinder)
+	return
+}
+
+func (client *restClient) Put(url string, contentType string, body io.ReadSeeker, tokens *TokenOptions) (res *http.Response, err error) {
+	if contentType == "" {
+		contentType = appJson
+	}
+
+	req := request{"PUT", url, contentType, body, tokens}
+	rewinder := func() io.Reader {
+		body.Seek(0, 0)
+		return body
+	}
+	res, err = client.SendRequest(&req, rewinder)
+	return
+}
+
+func (client *restClient) Delete(url string, tokens *TokenOptions) (res *http.Response, err error) {
+	req := request{"DELETE", url, "", nil, tokens}
+	res, err = client.SendRequest(&req, nil)
+	return
+}
+
+func (client *restClient) SendRequest(req *request, bodyRewinder bodyRewinder) (res *http.Response, err error) {
+	res, err = client.sendRequestHelper(req)
+	// In most cases, we'll return immediately
+	// If the operation succeeded, but we got a 401 response and if we're using
+	// authentication, then we'll look into the body to see if the token expired
+	if err != nil {
+		return res, err
+	}
+	if res.StatusCode != 401 {
+		// It's not a 401, so the token didn't expire
+		return res, err
+	}
+	if req.Tokens == nil || req.Tokens.AccessToken == "" {
+		// We don't have a token, so we can't renew the token, no need to proceed
+		return res, err
+	}
+
+	// We're going to look in the body to see if it failed because the token expired
+	// This means we need to read the body, but the functions that call us also
+	// expect to read the body. So we read the body, then create a new reader
+	// so they can read the body as normal.
+	body, err := ioutil.ReadAll(res.Body)
+	if err != nil {
+		return res, err
+	}
+	res.Body = ioutil.NopCloser(bytes.NewReader(body))
+
+	// Now see if we had an expired token or not
+	var apiError APIError
+	err = json.Unmarshal(body, &apiError)
+	if err != nil {
+		return res, err
+	}
+	if apiError.ErrorCode != expiredAuthToken {
+		return res, nil
+	}
+
+	// We were told that the access token expired, so we acquire a new token using the refresh token.
+	newTokens, err := client.authClient.GetTokensByRefreshToken(req.Tokens.RefreshToken)
+	// If there is an error during token refresh, we assume that the refresh token also expired. So we login again using
+	// the machine account.
+	if err != nil {
+		newTokens, err = client.authClient.GetTokensByMachineAccount()
+		if err != nil {
+			return res, err
+		}
+	}
+	req.Tokens.AccessToken = newTokens.AccessToken
+	if client.UpdateAccessTokenCallback != nil {
+		client.UpdateAccessTokenCallback(newTokens.AccessToken)
+	}
+	if req.Body != nil && bodyRewinder != nil {
+		req.Body = bodyRewinder()
+	}
+	res, err = client.sendRequestHelper(req)
+	return res, nil
+}
+
+func (client *restClient) sendRequestHelper(req *request) (res *http.Response, err error) {
+	r, err := http.NewRequest(req.Method, req.URL, req.Body)
+	if err != nil {
+		return
+	}
+	if req.ContentType != "" {
+		r.Header.Add("Content-Type", req.ContentType)
+	}
+	if req.Tokens != nil && req.Tokens.AccessToken != "" {
+		r.Header.Add("Authorization", "Bearer "+req.Tokens.AccessToken)
+	}
+	res, err = client.httpClient.Do(r)
+	if err != nil {
+		return
+	}
+
+	return
+}
+
+// Reads an error out of the HTTP response, or does nothing if
+// no error occured.
+func getError(res *http.Response) (*http.Response, error) {
+	// Do nothing if the response is a successful 2xx
+	if res.StatusCode/100 == 2 {
+		return res, nil
+	}
+	var apiError APIError
+	// ReadAll is usually a bad practice, but here we need to read the response all
+	// at once because we may attempt to use the data twice. It's preferable to use
+	// methods that take io.Reader, e.g. json.NewDecoder
+	body, err := ioutil.ReadAll(res.Body)
+	if err != nil {
+		return nil, err
+	}
+	err = json.Unmarshal(body, &apiError)
+	if err != nil {
+		// If deserializing into ApiError fails, return a generic HttpError instead
+		return nil, HttpError{res.StatusCode, string(body[:])}
+	}
+	apiError.HttpStatusCode = res.StatusCode
+	return nil, apiError
+}
diff --git a/pkg/cloudprovider/providers/cascade/tests_owed b/pkg/cloudprovider/providers/cascade/tests_owed
new file mode 100644
index 0000000000..dff5ab1dcd
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/tests_owed
@@ -0,0 +1,5 @@
+
+Yu Sheng
+Change-Id: Ifc11818f65a3e018aeea6988d9e2c0719b592920
+
+
diff --git a/pkg/cloudprovider/providers/cascade/utils.go b/pkg/cloudprovider/providers/cascade/utils.go
new file mode 100644
index 0000000000..866f853b42
--- /dev/null
+++ b/pkg/cloudprovider/providers/cascade/utils.go
@@ -0,0 +1,29 @@
+package cascade
+
+func StringPtr(s string) *string {
+	return &s
+}
+
+// StringVal returns string from string pointer, nil returns ""
+func StringVal(p *string) (s string) {
+	if p != nil {
+		s = *p
+	}
+	return
+}
+
+func Int64Ptr(s int64) *int64 {
+	return &s
+}
+
+func Int64Val(s *int64) int64 {
+	return *s
+}
+
+func Int32Ptr(s int32) *int32 {
+	return &s
+}
+
+func BoolPtr(s bool) *bool {
+	return &s
+}
diff --git a/pkg/cloudprovider/providers/providers.go b/pkg/cloudprovider/providers/providers.go
index 7de9ca9a41..a65547783a 100644
--- a/pkg/cloudprovider/providers/providers.go
+++ b/pkg/cloudprovider/providers/providers.go
@@ -21,6 +21,7 @@ import (
 	_ "k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
 	_ "k8s.io/kubernetes/pkg/cloudprovider/providers/azure"
 	_ "k8s.io/kubernetes/pkg/cloudprovider/providers/cloudstack"
+	_ "k8s.io/kubernetes/pkg/cloudprovider/providers/cascade"
 	_ "k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
 	_ "k8s.io/kubernetes/pkg/cloudprovider/providers/openstack"
 	_ "k8s.io/kubernetes/pkg/cloudprovider/providers/ovirt"
diff --git a/pkg/kubeapiserver/authorizer/config.go b/pkg/kubeapiserver/authorizer/config.go
index a72ba5ee63..be1f0a7bdd 100644
--- a/pkg/kubeapiserver/authorizer/config.go
+++ b/pkg/kubeapiserver/authorizer/config.go
@@ -32,6 +32,7 @@ import (
 	"k8s.io/kubernetes/plugin/pkg/auth/authorizer/node"
 	"k8s.io/kubernetes/plugin/pkg/auth/authorizer/rbac"
 	"k8s.io/kubernetes/plugin/pkg/auth/authorizer/rbac/bootstrappolicy"
+	"k8s.io/kubernetes/plugin/pkg/auth/authorizer/vke"
 )
 
 type AuthorizationConfig struct {
@@ -82,6 +83,12 @@ func (config AuthorizationConfig) New() (authorizer.Authorizer, authorizer.RuleR
 			nodeAuthorizer := node.NewAuthorizer(graph, nodeidentifier.NewDefaultNodeIdentifier(), bootstrappolicy.NodeRules())
 			authorizers = append(authorizers, nodeAuthorizer)
 
+		case modes.ModeVKE:
+			vkeAuthorizer, err := vke.NewAuthorizer()
+			if err != nil {
+				return nil, nil, err
+			}
+			authorizers = append(authorizers, vkeAuthorizer)
 		case modes.ModeAlwaysAllow:
 			alwaysAllowAuthorizer := authorizerfactory.NewAlwaysAllowAuthorizer()
 			authorizers = append(authorizers, alwaysAllowAuthorizer)
diff --git a/pkg/kubeapiserver/authorizer/modes/modes.go b/pkg/kubeapiserver/authorizer/modes/modes.go
index 54d0a62770..73a763ff14 100644
--- a/pkg/kubeapiserver/authorizer/modes/modes.go
+++ b/pkg/kubeapiserver/authorizer/modes/modes.go
@@ -25,9 +25,10 @@ const (
 	ModeWebhook     string = "Webhook"
 	ModeRBAC        string = "RBAC"
 	ModeNode        string = "Node"
+	ModeVKE         string = "VKE"
 )
 
-var AuthorizationModeChoices = []string{ModeAlwaysAllow, ModeAlwaysDeny, ModeABAC, ModeWebhook, ModeRBAC, ModeNode}
+var AuthorizationModeChoices = []string{ModeAlwaysAllow, ModeAlwaysDeny, ModeABAC, ModeWebhook, ModeRBAC, ModeNode, ModeVKE}
 
 // IsValidAuthorizationMode returns true if the given authorization mode is a valid one for the apiserver
 func IsValidAuthorizationMode(authzMode string) bool {
diff --git a/pkg/kubeapiserver/options/plugins.go b/pkg/kubeapiserver/options/plugins.go
index abcb5b4673..292fcdd1dc 100644
--- a/pkg/kubeapiserver/options/plugins.go
+++ b/pkg/kubeapiserver/options/plugins.go
@@ -57,6 +57,7 @@ import (
 	"k8s.io/apiserver/pkg/admission/plugin/namespace/lifecycle"
 	mutatingwebhook "k8s.io/apiserver/pkg/admission/plugin/webhook/mutating"
 	validatingwebhook "k8s.io/apiserver/pkg/admission/plugin/webhook/validating"
+	"k8s.io/kubernetes/plugin/pkg/admission/vke"
 	utilfeature "k8s.io/apiserver/pkg/util/feature"
 	"k8s.io/kubernetes/pkg/features"
 )
@@ -93,6 +94,7 @@ var AllOrderedPlugins = []string{
 	initialization.PluginName,               // Initializers
 	validatingwebhook.PluginName,            // ValidatingAdmissionWebhook
 	resourcequota.PluginName,                // ResourceQuota
+	vke.PluginName,                          // VMwareAdmissionController
 	deny.PluginName,                         // AlwaysDeny
 }
 
@@ -125,6 +127,7 @@ func RegisterAllAdmissionPlugins(plugins *admission.Plugins) {
 	setdefault.Register(plugins)
 	resize.Register(plugins)
 	storageobjectinuseprotection.Register(plugins)
+	vke.Register(plugins)
 }
 
 // DefaultOffAdmissionPlugins get admission plugins off by default for kube-apiserver.
diff --git a/pkg/printers/internalversion/describe.go b/pkg/printers/internalversion/describe.go
index c1b59cf96e..f6b18a7f16 100644
--- a/pkg/printers/internalversion/describe.go
+++ b/pkg/printers/internalversion/describe.go
@@ -757,6 +757,8 @@ func describeVolumes(volumes []api.Volume, w PrefixWriter, space string) {
 			printFlexVolumeSource(volume.VolumeSource.FlexVolume, w)
 		case volume.VolumeSource.Flocker != nil:
 			printFlockerVolumeSource(volume.VolumeSource.Flocker, w)
+		case volume.VolumeSource.CascadeDisk != nil:
+			printCascadeDiskVolumeSource(volume.VolumeSource.CascadeDisk, w)
 		default:
 			w.Write(LEVEL_1, "<unknown>\n")
 		}
@@ -1127,6 +1129,13 @@ func printCSIPersistentVolumeSource(csi *api.CSIPersistentVolumeSource, w Prefix
 		csi.Driver, csi.VolumeHandle, csi.ReadOnly)
 }
 
+func printCascadeDiskVolumeSource(cascade *api.CascadeDiskVolumeSource, w PrefixWriter) {
+	w.Write(LEVEL_2, "Type:\tVKEDisk (a Persistent Disk resource in VKE)\n"+
+		"    DiskID:\t%v\n"+
+		"    FSType:\t%v\n",
+		cascade.DiskID, cascade.FSType)
+}
+
 type PersistentVolumeDescriber struct {
 	clientset.Interface
 }
@@ -1263,6 +1272,8 @@ func describePersistentVolume(pv *api.PersistentVolume, events *api.EventList) (
 			printFlockerVolumeSource(pv.Spec.Flocker, w)
 		case pv.Spec.CSI != nil:
 			printCSIPersistentVolumeSource(pv.Spec.CSI, w)
+		case pv.Spec.CascadeDisk != nil:
+			printCascadeDiskVolumeSource(pv.Spec.CascadeDisk, w)
 		default:
 			w.Write(LEVEL_1, "<unknown>\n")
 		}
diff --git a/pkg/security/podsecuritypolicy/util/util.go b/pkg/security/podsecuritypolicy/util/util.go
index 3f29f6e7a4..8e965032d4 100644
--- a/pkg/security/podsecuritypolicy/util/util.go
+++ b/pkg/security/podsecuritypolicy/util/util.go
@@ -68,6 +68,7 @@ func GetAllFSTypesAsSet() sets.String {
 		string(policy.PortworxVolume),
 		string(policy.ScaleIO),
 		string(policy.CSI),
+		string(policy.CascadeDisk),
 	)
 	return fstypes
 }
@@ -129,6 +130,8 @@ func GetVolumeFSType(v api.Volume) (policy.FSType, error) {
 		return policy.PortworxVolume, nil
 	case v.ScaleIO != nil:
 		return policy.ScaleIO, nil
+	case v.CascadeDisk != nil:
+		return policy.CascadeDisk, nil
 	}
 
 	return "", fmt.Errorf("unknown volume type for volume: %#v", v)
diff --git a/pkg/volume/cascade_disk/BUILD b/pkg/volume/cascade_disk/BUILD
new file mode 100644
index 0000000000..3386612450
--- /dev/null
+++ b/pkg/volume/cascade_disk/BUILD
@@ -0,0 +1,43 @@
+package(default_visibility = ["//visibility:public"])
+
+load(
+    "@io_bazel_rules_go//go:def.bzl",
+    "go_library",
+    "go_test",
+)
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "attacher.go",
+        "cascade_disk.go",
+        "cascade_util.go",
+    ],
+    deps = [
+        "//pkg/cloudprovider:go_default_library",
+        "//pkg/cloudprovider/providers/cascade:go_default_library",
+        "//pkg/util/mount:go_default_library",
+        "//pkg/util/strings:go_default_library",
+        "//pkg/volume:go_default_library",
+        "//pkg/volume/util:go_default_library",
+        "//pkg/volume/util/volumehelper:go_default_library",
+        "//vendor/github.com/golang/glog:go_default_library",
+        "//vendor/k8s.io/api/core/v1:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/api/resource:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/types:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [":package-srcs"],
+    tags = ["automanaged"],
+)
diff --git a/pkg/volume/cascade_disk/OWNERS b/pkg/volume/cascade_disk/OWNERS
new file mode 100644
index 0000000000..c3a4ed77dc
--- /dev/null
+++ b/pkg/volume/cascade_disk/OWNERS
@@ -0,0 +1,2 @@
+maintainers:
+- ashokc
diff --git a/pkg/volume/cascade_disk/attacher.go b/pkg/volume/cascade_disk/attacher.go
new file mode 100644
index 0000000000..c19c37c965
--- /dev/null
+++ b/pkg/volume/cascade_disk/attacher.go
@@ -0,0 +1,264 @@
+package cascade_disk
+
+import (
+	"fmt"
+	"os"
+	"path"
+	"time"
+
+	"github.com/golang/glog"
+	"k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/kubernetes/pkg/cloudprovider/providers/cascade"
+	"k8s.io/kubernetes/pkg/util/mount"
+	"k8s.io/kubernetes/pkg/volume"
+	volumeutil "k8s.io/kubernetes/pkg/volume/util"
+)
+
+type cascadeDiskAttacher struct {
+	host         volume.VolumeHost
+	cascadeDisks cascade.Disks
+}
+
+var _ volume.Attacher = &cascadeDiskAttacher{}
+var _ volume.AttachableVolumePlugin = &cascadeDiskPlugin{}
+
+func (plugin *cascadeDiskPlugin) NewAttacher() (volume.Attacher, error) {
+	cascadeCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
+	if err != nil {
+		glog.Errorf("Cascade attacher: NewAttacher failed to get cloud provider")
+		return nil, err
+	}
+
+	return &cascadeDiskAttacher{
+		host:         plugin.host,
+		cascadeDisks: cascadeCloud,
+	}, nil
+}
+
+// Attach attaches the volume specified by the given spec to the given host. On success, returns the device path where
+// the device was attached on the node.
+func (attacher *cascadeDiskAttacher) Attach(spec *volume.Spec, nodeName types.NodeName) (string, error) {
+	hostName := string(nodeName)
+	volumeSource, _, err := getVolumeSource(spec)
+	if err != nil {
+		glog.Errorf("Cascade attacher: Attach failed to get volume source")
+		return "", err
+	}
+
+	// cascadeDisks.AttachDisk checks if disk is already attached to the node. So we don't have to do that separately
+	// here.
+	glog.V(4).Infof("Cascade: Attach disk called for host %s", hostName)
+	devicePath, err := attacher.cascadeDisks.AttachDisk(volumeSource.DiskID, nodeName)
+	if err != nil {
+		glog.Errorf("Error attaching volume %q to node %q: %+v", volumeSource.DiskID, nodeName, err)
+		return "", err
+	}
+	return devicePath, nil
+}
+
+// VolumesAreAttached verifies whether the volumes specified in the spec are attached to the specified node.
+func (attacher *cascadeDiskAttacher) VolumesAreAttached(specs []*volume.Spec,
+	nodeName types.NodeName) (map[*volume.Spec]bool, error) {
+	volumesAttachedCheck := make(map[*volume.Spec]bool)
+	volumeSpecMap := make(map[string]*volume.Spec)
+	diskIDList := []string{}
+	for _, spec := range specs {
+		volumeSource, _, err := getVolumeSource(spec)
+		if err != nil {
+			glog.Errorf("Error getting volume (%q) source : %v", spec.Name(), err)
+			continue
+		}
+
+		diskIDList = append(diskIDList, volumeSource.DiskID)
+		volumesAttachedCheck[spec] = true
+		volumeSpecMap[volumeSource.DiskID] = spec
+	}
+	attachedResult, err := attacher.cascadeDisks.DisksAreAttached(diskIDList, nodeName)
+	if err != nil {
+		glog.Errorf(
+			"Error checking if volumes (%v) are attached to current node (%q). err=%v",
+			diskIDList, nodeName, err)
+		return volumesAttachedCheck, err
+	}
+
+	for diskID, attached := range attachedResult {
+		if !attached {
+			spec := volumeSpecMap[diskID]
+			volumesAttachedCheck[spec] = false
+			glog.V(2).Infof("VolumesAreAttached: check volume %q (specName: %q) is no longer attached",
+				diskID, spec.Name())
+		}
+	}
+	return volumesAttachedCheck, nil
+}
+
+// WaitForAttach waits until the devicePath returned by the Attach call is available.
+func (attacher *cascadeDiskAttacher) WaitForAttach(spec *volume.Spec, devicePath string, _ *v1.Pod,
+	timeout time.Duration) (string, error) {
+	volumeSource, _, err := getVolumeSource(spec)
+	if err != nil {
+		glog.Errorf("Cascade attacher: WaitForAttach failed to get volume source")
+		return "", err
+	}
+
+	if devicePath == "" {
+		return "", fmt.Errorf("WaitForAttach failed for disk %s: devicePath is empty.", volumeSource.DiskID)
+	}
+
+	ticker := time.NewTicker(checkSleepDuration)
+	defer ticker.Stop()
+
+	timer := time.NewTimer(timeout)
+	defer timer.Stop()
+
+	for {
+		select {
+		case <-ticker.C:
+			glog.V(4).Infof("Checking disk %s is attached", volumeSource.DiskID)
+			devicePath := getDiskByIdPath(devicePath)
+			checkPath, err := verifyDevicePath(devicePath)
+			if err != nil {
+				// Log error, if any, and continue checking periodically. See issue #11321
+				glog.Warningf("Cascade attacher: WaitForAttach with devicePath %s Checking PD %s Error verify "+
+					"path", devicePath, volumeSource.DiskID)
+			} else if checkPath != "" {
+				// A device path has successfully been created for the disk
+				glog.V(4).Infof("Successfully found attached disk %s.", volumeSource.DiskID)
+				return checkPath, nil
+			}
+		case <-timer.C:
+			return "", fmt.Errorf("Could not find attached disk %s. Timeout waiting for mount paths to be "+
+				"created.", volumeSource.DiskID)
+		}
+	}
+}
+
+// GetDeviceMountPath returns a path where the device should point which should be bind mounted for individual volumes.
+func (attacher *cascadeDiskAttacher) GetDeviceMountPath(spec *volume.Spec) (string, error) {
+	volumeSource, _, err := getVolumeSource(spec)
+	if err != nil {
+		glog.Errorf("Cascade attacher: GetDeviceMountPath failed to get volume source")
+		return "", err
+	}
+
+	return makeGlobalPDPath(attacher.host, volumeSource.DiskID), nil
+}
+
+// GetMountDeviceRefs finds all other references to the device referenced by deviceMountPath; returns a list of paths.
+func (plugin *cascadeDiskPlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
+	mounter := plugin.host.GetMounter(plugin.GetPluginName())
+	return mount.GetMountRefs(mounter, deviceMountPath)
+}
+
+// MountDevice mounts device to global mount point.
+func (attacher *cascadeDiskAttacher) MountDevice(spec *volume.Spec, devicePath string, deviceMountPath string) error {
+	mounter := attacher.host.GetMounter(cascadeDiskPluginName)
+	notMnt, err := mounter.IsLikelyNotMountPoint(deviceMountPath)
+	if err != nil {
+		if os.IsNotExist(err) {
+			if err := os.MkdirAll(deviceMountPath, 0750); err != nil {
+				glog.Errorf("Failed to create directory at %#v. err: %s", deviceMountPath, err)
+				return err
+			}
+			notMnt = true
+		} else {
+			return err
+		}
+	}
+
+	volumeSource, _, err := getVolumeSource(spec)
+	if err != nil {
+		glog.Errorf("Cascade attacher: MountDevice failed to get volume source. err: %s", err)
+		return err
+	}
+
+	options := []string{}
+
+	if notMnt {
+		diskMounter := volumeutil.NewSafeFormatAndMountFromHost(cascadeDiskPluginName, attacher.host)
+		mountOptions := volumeutil.MountOptionFromSpec(spec)
+		err = diskMounter.FormatAndMount(devicePath, deviceMountPath, volumeSource.FSType, mountOptions)
+		if err != nil {
+			os.Remove(deviceMountPath)
+			return err
+		}
+		glog.V(4).Infof("formatting spec %v devicePath %v deviceMountPath %v fs %v with options %+v",
+			spec.Name(), devicePath, deviceMountPath, volumeSource.FSType, options)
+	}
+	return nil
+}
+
+type cascadeDiskDetacher struct {
+	mounter      mount.Interface
+	cascadeDisks cascade.Disks
+}
+
+var _ volume.Detacher = &cascadeDiskDetacher{}
+
+// NewDetacher returns the detacher associated with the Cascade volume plugin.
+func (plugin *cascadeDiskPlugin) NewDetacher() (volume.Detacher, error) {
+	cascadeCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
+	if err != nil {
+		glog.Errorf("Cascade attacher: NewDetacher failed to get cloud provider. err: %s", err)
+		return nil, err
+	}
+
+	return &cascadeDiskDetacher{
+		mounter:      plugin.host.GetMounter(plugin.GetPluginName()),
+		cascadeDisks: cascadeCloud,
+	}, nil
+}
+
+// Detach detaches the given device from the given host.
+func (detacher *cascadeDiskDetacher) Detach(deviceMountPath string, nodeName types.NodeName) error {
+	hostName := string(nodeName)
+	diskID := path.Base(deviceMountPath)
+	attached, err := detacher.cascadeDisks.DiskIsAttached(diskID, nodeName)
+	if err != nil {
+		// Log error and continue with detach
+		glog.Errorf(
+			"Error checking if persistent disk (%q) is already attached to current node (%q). "+
+				"Will continue and try detach anyway. err=%v", diskID, hostName, err)
+	}
+
+	if err == nil && !attached {
+		// Volume is already detached from node.
+		glog.V(4).Infof("detach operation was successful. persistent disk %q is already detached "+
+			"from node %q.", diskID, hostName)
+		return nil
+	}
+
+	if err := detacher.cascadeDisks.DetachDisk(diskID, nodeName); err != nil {
+		glog.Errorf("Error detaching volume %q: %v", diskID, err)
+		return err
+	}
+	return nil
+}
+
+// WaitForDetach waits for the devicePath to become unavailable.
+func (detacher *cascadeDiskDetacher) WaitForDetach(devicePath string, timeout time.Duration) error {
+	ticker := time.NewTicker(checkSleepDuration)
+	defer ticker.Stop()
+	timer := time.NewTimer(timeout)
+	defer timer.Stop()
+
+	for {
+		select {
+		case <-ticker.C:
+			glog.V(4).Infof("Checking device %q is detached.", devicePath)
+			if pathExists, err := volumeutil.PathExists(devicePath); err != nil {
+				return fmt.Errorf("Error checking if device path exists: %v", err)
+			} else if !pathExists {
+				return nil
+			}
+		case <-timer.C:
+			return fmt.Errorf("Timeout reached; Device %v is still attached", devicePath)
+		}
+	}
+}
+
+// UnmountDevice unmounts the disk specified by the device mount path.
+func (detacher *cascadeDiskDetacher) UnmountDevice(deviceMountPath string) error {
+	return volumeutil.UnmountPath(deviceMountPath, detacher.mounter)
+}
diff --git a/pkg/volume/cascade_disk/azure_disk_util.go b/pkg/volume/cascade_disk/azure_disk_util.go
new file mode 100644
index 0000000000..7f9812f767
--- /dev/null
+++ b/pkg/volume/cascade_disk/azure_disk_util.go
@@ -0,0 +1,135 @@
+package cascade_disk
+
+import (
+	"io/ioutil"
+	"os"
+	"path"
+	"strconv"
+	"strings"
+
+	"github.com/golang/glog"
+)
+
+const (
+	environmentFilePath = "/etc/kubernetes/environment"
+	diskPath            = "/dev/disk/cloud/"
+	sysPath             = "/sys/bus/scsi/devices"
+	lunIndex            = 3
+	maxOsScsiHostNo     = 3
+	vendor              = "vendor"
+	msftVendor          = "MSFT"
+	model               = "model"
+	vhdModel            = "VIRTUAL DISK"
+	block               = "block"
+)
+
+func findAzureVolume(lun int) (device string, err error) {
+	azureDisks := listAzureDiskPath()
+	return findDiskByLunWithConstraint(lun, azureDisks)
+}
+
+// List all the devices that are used by azure.
+// All these devices are the symbolic link under /dev/disk/cloud/
+// eg. azure_resource -> ../../sdb
+func listAzureDiskPath() []string {
+	var azureDiskList []string
+	if dirs, err := ioutil.ReadDir(diskPath); err == nil {
+		for _, f := range dirs {
+			name := f.Name()
+			diskPath := diskPath + name
+			if link, linkErr := os.Readlink(diskPath); linkErr == nil {
+				sd := link[(strings.LastIndex(link, "/") + 1):]
+				azureDiskList = append(azureDiskList, sd)
+			}
+		}
+	}
+	glog.V(12).Infof("Azure sys disks paths: %v", azureDiskList)
+	return azureDiskList
+}
+
+// Azure attach/detach APIs return the disk model that does not have disk
+// device path name (eg. /dev/sde) instead it gives the lun number of the disk
+// getting attached/detached.
+// This function maps that lun number to device path name of the
+// device mounted to "current" node.
+// Refrence : https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/azure_dd/azure_common_linux.go#L69
+//            https://docs.microsoft.com/en-us/azure/virtual-machines/linux/troubleshoot-device-names-problems
+func findDiskByLunWithConstraint(lun int, azureDisks []string) (string, error) {
+	var err error
+	if dirs, err := ioutil.ReadDir(sysPath); err == nil {
+		for _, f := range dirs {
+			name := f.Name()
+			// look for path like /sys/bus/scsi/devices/3:0:0:1
+			arr := strings.Split(name, ":")
+			if len(arr) < 4 {
+				continue
+			}
+			if len(azureDisks) == 0 {
+				glog.V(4).Infof("/dev/disk/cloud is not populated, now try to parse %v directly", name)
+				target, err := strconv.Atoi(arr[0])
+				if err != nil {
+					glog.Errorf("failed to parse target from %v (%v), err %v", arr[0], name, err)
+					continue
+				}
+				// as observed, targets 0-3 are used by OS disks. Skip them
+				if target <= maxOsScsiHostNo {
+					continue
+				}
+			}
+
+			// extract LUN from the path.
+			// LUN is the last index of the array, i.e. 1 in /sys/bus/scsi/devices/3:0:0:1
+			l, err := strconv.Atoi(arr[lunIndex])
+			if err != nil {
+				// unknown path format, continue to read the next one
+				glog.V(4).Infof("azure disk - failed to parse lun from %v (%v), err %v", arr[lunIndex], name, err)
+				continue
+			}
+			if lun == l {
+				// find the matching LUN
+				// read vendor and model to ensure it is a VHD disk
+				vendorPath := path.Join(sysPath, name, vendor)
+				vendorBytes, err := ioutil.ReadFile(vendorPath)
+				if err != nil {
+					glog.Errorf("failed to read device vendor, err: %v", err)
+					continue
+				}
+				vendor := strings.TrimSpace(string(vendorBytes))
+				if strings.ToUpper(vendor) != msftVendor {
+					glog.V(4).Infof("vendor doesn't match VHD, got %s", vendor)
+					continue
+				}
+
+				modelPath := path.Join(sysPath, name, model)
+				modelBytes, err := ioutil.ReadFile(modelPath)
+				if err != nil {
+					glog.Errorf("failed to read device model, err: %v", err)
+					continue
+				}
+				model := strings.TrimSpace(string(modelBytes))
+				if strings.ToUpper(model) != vhdModel {
+					glog.V(4).Infof("model doesn't match VHD, got %s", model)
+					continue
+				}
+
+				// find a disk, validate name
+				dir := path.Join(sysPath, name, block)
+				if dev, err := ioutil.ReadDir(dir); err == nil {
+					found := false
+					devName := dev[0].Name()
+					for _, diskName := range azureDisks {
+						glog.V(12).Infof("azureDisk - validating disk %q with sys disk %q", devName, diskName)
+						if devName == diskName {
+							found = true
+							break
+						}
+					}
+					if !found {
+						return "/dev/" + devName, nil
+					}
+				}
+			}
+		}
+	}
+	return "", err
+}
diff --git a/pkg/volume/cascade_disk/cascade_disk.go b/pkg/volume/cascade_disk/cascade_disk.go
new file mode 100644
index 0000000000..b7d3fd774b
--- /dev/null
+++ b/pkg/volume/cascade_disk/cascade_disk.go
@@ -0,0 +1,399 @@
+package cascade_disk
+
+import (
+	"fmt"
+	"os"
+	"path"
+
+	"github.com/golang/glog"
+	"k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/resource"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/kubernetes/pkg/util/mount"
+	utilstrings "k8s.io/kubernetes/pkg/util/strings"
+	"k8s.io/kubernetes/pkg/volume"
+	"k8s.io/kubernetes/pkg/volume/util"
+)
+
+// This is the primary entrypoint for volume plugins.
+func ProbeVolumePlugins() []volume.VolumePlugin {
+	return []volume.VolumePlugin{&cascadeDiskPlugin{}}
+}
+
+type cascadeDiskPlugin struct {
+	host volume.VolumeHost
+}
+
+var _ volume.VolumePlugin = &cascadeDiskPlugin{}
+var _ volume.PersistentVolumePlugin = &cascadeDiskPlugin{}
+var _ volume.DeletableVolumePlugin = &cascadeDiskPlugin{}
+var _ volume.ProvisionableVolumePlugin = &cascadeDiskPlugin{}
+
+const (
+	cascadeDiskPluginName = "kubernetes.io/vke-disk"
+)
+
+// Init initializes the Cascade volume plugin.
+func (plugin *cascadeDiskPlugin) Init(host volume.VolumeHost) error {
+	plugin.host = host
+	return nil
+}
+
+// GetPluginName returns the name of the Cascade volume plugin.
+func (plugin *cascadeDiskPlugin) GetPluginName() string {
+	return cascadeDiskPluginName
+}
+
+// GetVolumeName returns the name of the volume which is the diskID in our case.
+func (plugin *cascadeDiskPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
+	volumeSource, _, err := getVolumeSource(spec)
+	if err != nil {
+		glog.Errorf("Cascade volume plugin: GetVolumeName failed to get volume source")
+		return "", err
+	}
+
+	return volumeSource.DiskID, nil
+}
+
+// CanSupport specifies whether the Cascade volume plguin can support the specific resource type.
+// Cascade plugin only supports the persistent volume and volume resource which has the Cascade disk annotation.
+func (plugin *cascadeDiskPlugin) CanSupport(spec *volume.Spec) bool {
+	return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.CascadeDisk != nil) ||
+		(spec.Volume != nil && spec.Volume.CascadeDisk != nil)
+}
+
+// RequiresRemount specifies whether remount is required for the disk.
+func (plugin *cascadeDiskPlugin) RequiresRemount() bool {
+	return false
+}
+
+// SupportsMountOption specifies whether the Cascade volume plugin supports the mount operation.
+func (plugin *cascadeDiskPlugin) SupportsMountOption() bool {
+	return true
+}
+
+// SupportsBulkVolumeVerification specifies whether bulk volume verification is supported.
+func (plugin *cascadeDiskPlugin) SupportsBulkVolumeVerification() bool {
+	return false
+}
+
+// NewMounter returns the mounter associated with the Cascade volume plugin.
+func (plugin *cascadeDiskPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod,
+	_ volume.VolumeOptions) (volume.Mounter, error) {
+	return plugin.newMounterInternal(spec, pod.UID, &CascadeDiskUtil{}, plugin.host.GetMounter(plugin.GetPluginName()))
+}
+
+// NewUnmounter returns the unmounter associated with the Cascade volume plugin.
+func (plugin *cascadeDiskPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
+	return plugin.newUnmounterInternal(volName, podUID, &CascadeDiskUtil{},
+		plugin.host.GetMounter(plugin.GetPluginName()))
+}
+
+func (plugin *cascadeDiskPlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, manager diskManager,
+	mounter mount.Interface) (volume.Mounter, error) {
+	volumeSource, _, err := getVolumeSource(spec)
+	if err != nil {
+		glog.Errorf("Cascade volume plugin: newMounterInternal failed to get volume source")
+		return nil, err
+	}
+
+	diskID := volumeSource.DiskID
+	fsType := volumeSource.FSType
+
+	return &cascadeDiskMounter{
+		cascadeDisk: &cascadeDisk{
+			podUID:  podUID,
+			volName: spec.Name(),
+			diskID:  diskID,
+			manager: manager,
+			mounter: mounter,
+			plugin:  plugin,
+		},
+		fsType:      fsType,
+		diskMounter: util.NewSafeFormatAndMountFromHost(plugin.GetPluginName(), plugin.host)}, nil
+}
+
+func (plugin *cascadeDiskPlugin) newUnmounterInternal(volName string, podUID types.UID, manager diskManager,
+	mounter mount.Interface) (volume.Unmounter, error) {
+	return &cascadeDiskUnmounter{
+		&cascadeDisk{
+			podUID:  podUID,
+			volName: volName,
+			manager: manager,
+			mounter: mounter,
+			plugin:  plugin,
+		}}, nil
+}
+
+// ConstructVolumeSpec constructs a Cascade volume spec based on the name and mount path.
+func (plugin *cascadeDiskPlugin) ConstructVolumeSpec(volumeSpecName, mountPath string) (*volume.Spec, error) {
+	mounter := plugin.host.GetMounter(plugin.GetPluginName())
+	pluginDir := plugin.host.GetPluginDir(plugin.GetPluginName())
+	diskID, err := mounter.GetDeviceNameFromMount(mountPath, pluginDir)
+	if err != nil {
+		return nil, err
+	}
+
+	cascadeDisk := &v1.Volume{
+		Name: volumeSpecName,
+		VolumeSource: v1.VolumeSource{
+			CascadeDisk: &v1.CascadeDiskVolumeSource{
+				DiskID: diskID,
+			},
+		},
+	}
+	return volume.NewSpecFromVolume(cascadeDisk), nil
+}
+
+// Abstract interface to disk operations.
+type diskManager interface {
+	// Creates a volume
+	CreateVolume(provisioner *cascadeDiskProvisioner) (diskID string, volumeSizeGB int, labels map[string]string, fstype string, err error)
+	// Deletes a volume
+	DeleteVolume(deleter *cascadeDiskDeleter) error
+}
+
+// cascadeDisk volumes are disk resources attached to the kubelet's host machine and exposed to the pod.
+type cascadeDisk struct {
+	volName string
+	podUID  types.UID
+	diskID  string
+	fsType  string
+	manager diskManager
+	mounter mount.Interface
+	plugin  *cascadeDiskPlugin
+	volume.MetricsNil
+}
+
+var _ volume.Mounter = &cascadeDiskMounter{}
+
+type cascadeDiskMounter struct {
+	*cascadeDisk
+	fsType      string
+	diskMounter *mount.SafeFormatAndMount
+}
+
+// GetAttributes returns the attributes associated with a Cascade disk.
+func (b *cascadeDiskMounter) GetAttributes() volume.Attributes {
+	return volume.Attributes{
+		SupportsSELinux: true,
+	}
+}
+
+// CanMount checks prior to mount operations to verify that the required components (binaries, etc.) to mount the
+// volume are available on the underlying node. If not, it returns an error.
+func (b *cascadeDiskMounter) CanMount() error {
+	return nil
+}
+
+// SetUp attaches the disk and bind mounts to the volume path.
+func (b *cascadeDiskMounter) SetUp(fsGroup *int64) error {
+	return b.SetUpAt(b.GetPath(), fsGroup)
+}
+
+// SetUpAt attaches the disk and bind mounts to the volume path.
+func (b *cascadeDiskMounter) SetUpAt(dir string, fsGroup *int64) error {
+	glog.V(4).Infof("Cascade Persistent Disk setup %s to %s", b.diskID, dir)
+
+	// TODO: handle failed mounts here.
+	notmnt, err := b.mounter.IsLikelyNotMountPoint(dir)
+	if err != nil && !os.IsNotExist(err) {
+		glog.Errorf("cannot validate mount point: %s %v", dir, err)
+		return err
+	}
+	if !notmnt {
+		return nil
+	}
+
+	if err := os.MkdirAll(dir, 0750); err != nil {
+		glog.Errorf("mkdir failed on disk %s (%v)", dir, err)
+		return err
+	}
+
+	options := []string{"bind"}
+
+	// Perform a bind mount to the full path to allow duplicate mounts of the same PD.
+	globalPDPath := makeGlobalPDPath(b.plugin.host, b.diskID)
+	glog.V(4).Infof("attempting to mount %s", dir)
+
+	err = b.mounter.Mount(globalPDPath, dir, "", options)
+	if err != nil {
+		notmnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
+		if mntErr != nil {
+			glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
+			return err
+		}
+		if !notmnt {
+			if mntErr = b.mounter.Unmount(dir); mntErr != nil {
+				glog.Errorf("Failed to unmount: %v", mntErr)
+				return err
+			}
+			notmnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
+			if mntErr != nil {
+				glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
+				return err
+			}
+			if !notmnt {
+				glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.",
+					b.GetPath())
+				return err
+			}
+		}
+		os.Remove(dir)
+		glog.Errorf("Mount of disk %s failed: %v", dir, err)
+		return err
+	}
+	volume.SetVolumeOwnership(b, fsGroup)
+
+	return nil
+}
+
+var _ volume.Unmounter = &cascadeDiskUnmounter{}
+
+type cascadeDiskUnmounter struct {
+	*cascadeDisk
+}
+
+// TearDown unmounts the bind mount, and detaches the disk only if the disk resource was the last reference to that
+// disk on the kubelet.
+func (c *cascadeDiskUnmounter) TearDown() error {
+	return c.TearDownAt(c.GetPath())
+}
+
+// TearDownAt unmounts the bind mount, and detaches the disk only if the disk resource was the last reference to that
+// disk on the kubelet.
+func (c *cascadeDiskUnmounter) TearDownAt(dir string) error {
+	return util.UnmountPath(dir, c.mounter)
+}
+
+func makeGlobalPDPath(host volume.VolumeHost, diskID string) string {
+	return path.Join(host.GetPluginDir(cascadeDiskPluginName), mount.MountsInGlobalPDPath, diskID)
+}
+
+func (cd *cascadeDisk) GetPath() string {
+	name := cascadeDiskPluginName
+	return cd.plugin.host.GetPodVolumeDir(cd.podUID, utilstrings.EscapeQualifiedNameForDisk(name), cd.volName)
+}
+
+func (plugin *cascadeDiskPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
+	return []v1.PersistentVolumeAccessMode{
+		v1.ReadWriteOnce,
+	}
+}
+
+type cascadeDiskDeleter struct {
+	*cascadeDisk
+}
+
+var _ volume.Deleter = &cascadeDiskDeleter{}
+
+// NewDeleter returns the deleter associated with the Cascade volume plugin.
+func (plugin *cascadeDiskPlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
+	return plugin.newDeleterInternal(spec, &CascadeDiskUtil{})
+}
+
+func (plugin *cascadeDiskPlugin) newDeleterInternal(spec *volume.Spec, manager diskManager) (volume.Deleter, error) {
+	if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.CascadeDisk == nil {
+		return nil, fmt.Errorf("spec.PersistentVolumeSource.CascadeDisk is nil")
+	}
+	return &cascadeDiskDeleter{
+		&cascadeDisk{
+			volName: spec.Name(),
+			diskID:  spec.PersistentVolume.Spec.CascadeDisk.DiskID,
+			manager: manager,
+			plugin:  plugin,
+		}}, nil
+}
+
+func (r *cascadeDiskDeleter) Delete() error {
+	return r.manager.DeleteVolume(r)
+}
+
+type cascadeDiskProvisioner struct {
+	*cascadeDisk
+	options volume.VolumeOptions
+}
+
+var _ volume.Provisioner = &cascadeDiskProvisioner{}
+
+// NewProvisioner returns the provisioner associated with the Cascade volume plugin.
+func (plugin *cascadeDiskPlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
+	return plugin.newProvisionerInternal(options, &CascadeDiskUtil{})
+}
+
+func (plugin *cascadeDiskPlugin) newProvisionerInternal(options volume.VolumeOptions,
+	manager diskManager) (volume.Provisioner, error) {
+	return &cascadeDiskProvisioner{
+		cascadeDisk: &cascadeDisk{
+			manager: manager,
+			plugin:  plugin,
+		},
+		options: options,
+	}, nil
+}
+
+// Provision provisions the persistent volume by making a CreateDisk call to Cascade Controller.
+func (p *cascadeDiskProvisioner) Provision(selectedNode *v1.Node, allowedTopologies []v1.TopologySelectorTerm) (*v1.PersistentVolume, error) {
+	if !util.AccessModesContainedInAll(p.plugin.GetAccessModes(), p.options.PVC.Spec.AccessModes) {
+		return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported",
+			p.options.PVC.Spec.AccessModes, p.plugin.GetAccessModes())
+	}
+
+	diskID, sizeGB, labels, fstype, err := p.manager.CreateVolume(p)
+	if err != nil {
+		return nil, err
+	}
+
+	if fstype == "" {
+		fstype = "ext4"
+	}
+
+	pv := &v1.PersistentVolume{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:   p.options.PVName,
+			Labels: map[string]string{},
+			Annotations: map[string]string{
+				util.VolumeDynamicallyCreatedByKey: "vke-volume-dynamic-provisioner",
+			},
+		},
+		Spec: v1.PersistentVolumeSpec{
+			PersistentVolumeReclaimPolicy: p.options.PersistentVolumeReclaimPolicy,
+			AccessModes:                   p.options.PVC.Spec.AccessModes,
+			Capacity: v1.ResourceList{
+				v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dGi", sizeGB)),
+			},
+			PersistentVolumeSource: v1.PersistentVolumeSource{
+				CascadeDisk: &v1.CascadeDiskVolumeSource{
+					DiskID: diskID,
+					FSType: fstype,
+				},
+			},
+			MountOptions: p.options.MountOptions,
+		},
+	}
+	if len(p.options.PVC.Spec.AccessModes) == 0 {
+		pv.Spec.AccessModes = p.plugin.GetAccessModes()
+	}
+
+	if len(labels) != 0 {
+		if pv.Labels == nil {
+			pv.Labels = make(map[string]string)
+		}
+		for k, v := range labels {
+			pv.Labels[k] = v
+		}
+	}
+
+	return pv, nil
+}
+
+func getVolumeSource(spec *volume.Spec) (*v1.CascadeDiskVolumeSource, bool, error) {
+	if spec.Volume != nil && spec.Volume.CascadeDisk != nil {
+		return spec.Volume.CascadeDisk, spec.ReadOnly, nil
+	} else if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.CascadeDisk != nil {
+		return spec.PersistentVolume.Spec.CascadeDisk, spec.ReadOnly, nil
+	}
+
+	return nil, false, fmt.Errorf("Spec does not reference a Cascade disk type")
+}
diff --git a/pkg/volume/cascade_disk/cascade_util.go b/pkg/volume/cascade_disk/cascade_util.go
new file mode 100644
index 0000000000..5ad0bc9316
--- /dev/null
+++ b/pkg/volume/cascade_disk/cascade_util.go
@@ -0,0 +1,217 @@
+package cascade_disk
+
+import (
+	"fmt"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/golang/glog"
+	"k8s.io/api/core/v1"
+	"k8s.io/kubernetes/pkg/cloudprovider"
+	"k8s.io/kubernetes/pkg/cloudprovider/providers/cascade"
+	"k8s.io/kubernetes/pkg/volume"
+	volumeutil "k8s.io/kubernetes/pkg/volume/util"
+	"bufio"
+)
+
+const (
+	checkSleepDuration = time.Second
+)
+
+type CascadeDiskUtil struct{}
+
+func verifyDevicePath(path string) (string, error) {
+	if pathExists, err := volumeutil.PathExists(path); err != nil {
+		return "", fmt.Errorf("Error checking if path exists: %v", err)
+	} else if pathExists {
+		return path, nil
+	}
+
+	glog.V(4).Infof("verifyDevicePath: path does not exist yet")
+	return "", nil
+}
+
+// Returns path for given VKE disk mount
+func getDiskByIdPath(devicePath string) string {
+	provider, err := getProvider()
+	if err != nil {
+		glog.Warningf("error getting provider name from %s: %v", environmentFilePath, err)
+		return devicePath
+	}
+
+	switch provider {
+	case "azure":
+		// devicePath is an integer then it is lun returned from azure attach disk.
+		if diskLun, err := strconv.Atoi(devicePath); err == nil {
+			azDevicePath, err := findAzureVolume(diskLun)
+			if err != nil {
+				glog.Warningf("error looking for azure volume %q: %v", devicePath, err)
+			} else if azDevicePath != "" {
+				devicePath = azDevicePath
+			}
+		} else {
+			glog.Warningf("The device path for azure expected to be an integer but it is %s. Error : %v", devicePath, err)
+		}
+	default:
+		nvmePath, err := findNvmeVolume(devicePath)
+		if err != nil {
+			glog.Warningf("error looking for nvme volume %q: %v", devicePath, err)
+		} else if nvmePath != "" {
+			devicePath = nvmePath
+		}
+	}
+	return devicePath
+}
+
+// CreateVolume creates a Cascade persistent disk.
+func (util *CascadeDiskUtil) CreateVolume(p *cascadeDiskProvisioner) (string, int, map[string]string, string, error) {
+
+	cloud, err := getCloudProvider(p.plugin.host.GetCloudProvider())
+	if err != nil {
+		glog.Errorf("CreateVolume failed to get cloud provider. Error [%v]", err)
+		return "", 0, nil, "", err
+	}
+
+	capacity := p.options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
+	volSizeBytes := capacity.Value()
+	// Cascade works with GB, convert to GB with rounding up
+	volSizeGB := int(volumeutil.RoundUpSize(volSizeBytes, 1024*1024*1024))
+	name := volumeutil.GenerateVolumeName(p.options.ClusterName, p.options.PVName, 255)
+	volumeOptions := &cascade.VolumeOptions{
+		CapacityGB: volSizeGB,
+		Tags:       *p.options.CloudTags,
+		Name:       name,
+	}
+	fstype := ""
+	// enabling encryption by default if not provided from within storage class
+	volumeOptions.Encrypted = true
+	for parameter, value := range p.options.Parameters {
+		switch strings.ToLower(parameter) {
+		case "type":
+			volumeOptions.Type = value
+		case "zone":
+			volumeOptions.ZonePresent = true
+			volumeOptions.AvailabilityZone = value
+		case "zones":
+			volumeOptions.ZonesPresent = true
+			volumeOptions.AvailabilityZones = value
+		case "encrypted":
+			volumeOptions.Encrypted, err = strconv.ParseBool(value)
+			if err != nil {
+				glog.Errorf("invalid value %q for encryption of volume plugin %s.", value, p.plugin.GetPluginName())
+				return "", 0, nil, "",
+					fmt.Errorf("invalid encrypted boolean value %q, must be true or false: %v", value, err)
+			}
+		case volume.VolumeParameterFSType:
+			fstype = value
+			glog.V(4).Infof("Setting fstype to %s", fstype)
+		default:
+			glog.Errorf("invalid option %s for volume plugin %s.", parameter,
+				p.plugin.GetPluginName())
+			return "", 0, nil, "",
+				fmt.Errorf("invalid option %s for volume plugin %s.", parameter, p.plugin.GetPluginName())
+		}
+	}
+
+	if volumeOptions.ZonePresent && volumeOptions.ZonesPresent {
+		return "", 0, nil, "", fmt.Errorf("both zone and zones StorageClass parameters must not be used at the same time")
+	}
+
+	diskID, err := cloud.CreateDisk(volumeOptions)
+	if err != nil {
+		glog.Errorf("failed to CreateDisk. Error [%v]", err)
+		return "", 0, nil, "", err
+	}
+
+	labels, err := cloud.GetVolumeLabels(diskID)
+	if err != nil {
+		// We don't really want to leak the volume here...
+		glog.Errorf("error building labels for new volume %q: %v", name, err)
+	}
+
+	glog.V(4).Infof("Successfully created Cascade persistent disk %s", name)
+	return diskID, volSizeGB, labels, fstype, nil
+}
+
+// DeleteVolume deletes a Cascade volume.
+func (util *CascadeDiskUtil) DeleteVolume(disk *cascadeDiskDeleter) error {
+	cloud, err := getCloudProvider(disk.plugin.host.GetCloudProvider())
+	if err != nil {
+		glog.Errorf("DeleteVolume failed to get cloud provider. Error [%v]", err)
+		return err
+	}
+
+	if err = cloud.DeleteDisk(disk.diskID); err != nil {
+		glog.Errorf("failed to DeleteDisk for diskID %s. Error [%v]", disk.diskID, err)
+		return err
+	}
+
+	glog.V(4).Infof("Successfully deleted Cascade persistent disk %s", disk.diskID)
+	return nil
+}
+
+func getCloudProvider(cloud cloudprovider.Interface) (*cascade.CascadeCloud, error) {
+	if cloud == nil {
+		glog.Errorf("Cloud provider not initialized properly")
+		return nil, fmt.Errorf("Cloud provider not initialized properly")
+	}
+
+	cc := cloud.(*cascade.CascadeCloud)
+	if cc == nil {
+		glog.Errorf("Invalid cloud provider: expected Cascade")
+		return nil, fmt.Errorf("Invalid cloud provider: expected Cascade")
+	}
+	return cc, nil
+}
+
+// findNvmeVolume looks for the nvme volume with the specified name
+// It follows the symlink (if it exists) and returns the absolute path to the device
+func findNvmeVolume(findName string) (device string, err error) {
+	stat, err := os.Lstat(findName)
+	if err != nil {
+		if os.IsNotExist(err) {
+			glog.V(6).Infof("nvme path not found %q", findName)
+			return "", nil
+		}
+		return "", fmt.Errorf("error getting stat of %q: %v", findName, err)
+	}
+
+	if stat.Mode()&os.ModeSymlink != os.ModeSymlink {
+		glog.Warningf("nvme file %q found, but was not a symlink", findName)
+		return "", nil
+	}
+
+	// Find the target, resolving to an absolute path
+	// For example, /dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_vol0fab1d5e3f72a5e23 -> ../../nvme2n1
+	resolved, err := filepath.EvalSymlinks(findName)
+	if err != nil {
+		return "", fmt.Errorf("error reading target of symlink %q: %v", findName, err)
+	}
+
+	if !strings.HasPrefix(resolved, "/dev") {
+		return "", fmt.Errorf("resolved symlink for %q was unexpected: %q", findName, resolved)
+	}
+
+	return resolved, nil
+}
+
+func getProvider() (provider string, err error) {
+	file, err := os.Open(environmentFilePath)
+	if err != nil {
+		return "", err
+	}
+	defer file.Close()
+
+	scanner := bufio.NewScanner(file)
+
+	for scanner.Scan() {
+		lineContent := scanner.Text()
+		if strings.Contains(lineContent, "PROVIDER=") {
+			return strings.SplitAfter(lineContent, "=")[1], err
+		}
+	}
+	return "", err
+}
diff --git a/plugin/pkg/admission/storage/persistentvolume/label/admission.go b/plugin/pkg/admission/storage/persistentvolume/label/admission.go
index 19fc962ca3..8c51e38c3d 100644
--- a/plugin/pkg/admission/storage/persistentvolume/label/admission.go
+++ b/plugin/pkg/admission/storage/persistentvolume/label/admission.go
@@ -27,6 +27,7 @@ import (
 	api "k8s.io/kubernetes/pkg/apis/core"
 	"k8s.io/kubernetes/pkg/cloudprovider"
 	"k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
+	"k8s.io/kubernetes/pkg/cloudprovider/providers/cascade"
 	"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
 	kubeapiserveradmission "k8s.io/kubernetes/pkg/kubeapiserver/admission"
 	kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
@@ -55,6 +56,7 @@ type persistentVolumeLabel struct {
 	ebsVolumes       aws.Volumes
 	cloudConfig      []byte
 	gceCloudProvider *gce.GCECloud
+	cascadeDisks     cascade.Disks
 }
 
 var _ admission.MutationInterface = &persistentVolumeLabel{}
@@ -107,6 +109,13 @@ func (l *persistentVolumeLabel) Admit(a admission.Attributes) (err error) {
 		}
 		volumeLabels = labels
 	}
+	if volume.Spec.CascadeDisk != nil {
+		labels, err := l.findCascadeDiskLabels(volume)
+		if err != nil {
+			return admission.NewForbidden(a, fmt.Errorf("error querying Cascade volume %s: %v", volume.Spec.CascadeDisk.DiskID, err))
+		}
+		volumeLabels = labels
+	}
 
 	if len(volumeLabels) != 0 {
 		if volume.Labels == nil {
@@ -219,3 +228,48 @@ func (l *persistentVolumeLabel) getGCECloudProvider() (*gce.GCECloud, error) {
 	}
 	return l.gceCloudProvider, nil
 }
+
+func (l *persistentVolumeLabel) findCascadeDiskLabels(volume *api.PersistentVolume) (map[string]string, error) {
+	// Ignore any volumes that are being provisioned
+	if volume.Spec.CascadeDisk.DiskID == vol.ProvisionedVolumeName {
+		return nil, nil
+	}
+	cascadeDisks, err := l.getCascadeDisks()
+	if err != nil {
+		return nil, err
+	}
+	if cascadeDisks == nil {
+		return nil, fmt.Errorf("unable to build Cascade cloud provider for volumes")
+	}
+
+	labels, err := cascadeDisks.GetVolumeLabels(volume.Spec.CascadeDisk.DiskID)
+	if err != nil {
+		return nil, err
+	}
+
+	return labels, nil
+}
+
+// getCascadeDisks returns the Cascade Disks interface
+func (l *persistentVolumeLabel) getCascadeDisks() (cascade.Disks, error) {
+	l.mutex.Lock()
+	defer l.mutex.Unlock()
+
+	if l.cascadeDisks == nil {
+		var cloudConfigReader io.Reader
+		if len(l.cloudConfig) > 0 {
+			cloudConfigReader = bytes.NewReader(l.cloudConfig)
+		}
+		cloudProvider, err := cloudprovider.GetCloudProvider("vke", cloudConfigReader)
+		if err != nil || cloudProvider == nil {
+			return nil, err
+		}
+		provider, ok := cloudProvider.(*cascade.CascadeCloud)
+		if !ok {
+			// GetCloudProvider has gone very wrong
+			return nil, fmt.Errorf("error retrieving Cascade cloud provider")
+		}
+		l.cascadeDisks = provider
+	}
+	return l.cascadeDisks, nil
+}
diff --git a/plugin/pkg/admission/vke/BUILD b/plugin/pkg/admission/vke/BUILD
new file mode 100644
index 0000000000..530877a443
--- /dev/null
+++ b/plugin/pkg/admission/vke/BUILD
@@ -0,0 +1,61 @@
+package(default_visibility = ["//visibility:public"])
+
+load(
+    "@io_bazel_rules_go//go:def.bzl",
+    "go_library",
+)
+
+go_library(
+    name = "go_default_library",
+    srcs = ["admission.go"],
+    importpath = "k8s.io/kubernetes/plugin/pkg/admission/vke",
+    deps = [
+        "//pkg/apis/core:go_default_library",
+        "//pkg/apis/extensions:go_default_library",
+        "//pkg/apis/policy/v1beta1:go_default_library",
+        "//pkg/apis/rbac:go_default_library",
+        "//pkg/registry/rbac:go_default_library",
+        "//pkg/security/podsecuritypolicy:go_default_library",
+        "//vendor/github.com/golang/glog:go_default_library",
+        "//vendor/k8s.io/api/policy/v1beta1:go_default_library"
+        "//vendor/k8s.io/apimachinery/pkg/api/equality:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/runtime:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/util/yaml:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/util/validation/field:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
+        "//vendor/k8s.io/apiserver/pkg/admission:go_default_library",
+    ],
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = ["admission_test.go"],
+    embed = [":go_default_library"],
+    deps = [
+        "//pkg/apis/core:go_default_library",
+        "//pkg/apis/extensions:go_default_library",
+        "//pkg/apis/rbac:go_default_library",
+        "//pkg/registry/rbac:go_default_library",
+        "//pkg/security/podsecuritypolicy:go_default_library",
+        "//vendor/github.com/golang/glog:go_default_library",
+        "//vendor/github.com/stretchr/testify/assert:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/api/equality:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/util/yaml:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/util/validation/field:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
+        "//vendor/k8s.io/apiserver/pkg/admission:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [":package-srcs"],
+    tags = ["automanaged"],
+)
\ No newline at end of file
diff --git a/plugin/pkg/admission/vke/admission.go b/plugin/pkg/admission/vke/admission.go
new file mode 100644
index 0000000000..cae4dd77c6
--- /dev/null
+++ b/plugin/pkg/admission/vke/admission.go
@@ -0,0 +1,662 @@
+package vke
+
+import (
+	"fmt"
+	"io"
+	"os"
+	"strings"
+
+	"github.com/golang/glog"
+	"k8s.io/api/policy/v1beta1"
+	apiequality "k8s.io/apimachinery/pkg/api/equality"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+	"k8s.io/apimachinery/pkg/util/yaml"
+	"k8s.io/apiserver/pkg/admission"
+	api "k8s.io/kubernetes/pkg/apis/core"
+	"k8s.io/kubernetes/pkg/apis/policy"
+	policybeta "k8s.io/kubernetes/pkg/apis/policy/v1beta1"
+	"k8s.io/kubernetes/pkg/apis/rbac"
+	rbacregistry "k8s.io/kubernetes/pkg/registry/rbac"
+	"k8s.io/kubernetes/pkg/security/podsecuritypolicy"
+)
+
+const (
+	// PluginName indicates name of admission plugin.
+	PluginName = "VMwareAdmissionController"
+
+	systemNodesGroup         = "system:nodes"
+	systemMastersGroup       = "system:masters"
+	systemWorkerGroup        = "system:worker"
+	privilegedNamespace      = "vke-system"
+	privilegedServiceAccount = "system:serviceaccount:" + privilegedNamespace + ":"
+	reservedPrefix           = "vke"
+	reservedTolerationKey    = "Dedicated"
+	reservedTolerationValue  = "Master"
+	masterNodePrefix         = "master"
+	etcSslCerts              = "/etc/ssl/certs"
+)
+
+// Register registers a plugin.
+func Register(plugins *admission.Plugins) {
+	plugins.Register(PluginName, func(config io.Reader) (admission.Interface, error) {
+		return NewVMwareAdmissionController(config)
+	})
+}
+
+// vmwareAdmissionController is an implementation of admission.Interface.
+// It restricts access to VKE namespace for users and prevents the users from creating privileged pods.
+type vmwareAdmissionController struct {
+	psp             *policy.PodSecurityPolicy
+	strategyFactory podsecuritypolicy.StrategyFactory
+	privilegedGroup string
+	clusterID       string
+	privilegedMode  bool
+}
+
+// vmwareAdmissionControllerConfig holds config data for VMwareAdmissionController.
+type vmwareAdmissionControllerConfig struct {
+	ClusterID             string `yaml:"clusterID"`
+	PrivilegedGroup       string `yaml:"privilegedGroup"`
+	PodSecurityPolicyFile string `yaml:"podSecurityPolicyFile"`
+}
+
+// AdmissionConfig holds config data for admission controllers.
+type AdmissionConfig struct {
+	VMwareAdmissionController vmwareAdmissionControllerConfig `yaml:"vmwareAdmissionController"`
+}
+
+var _ admission.MutationInterface = &vmwareAdmissionController{}
+var _ admission.ValidationInterface = &vmwareAdmissionController{}
+
+// Admit makes an admission decision based on the request attributes.
+// Note: We implement the mutation interface for this admission controller, which means we have the ability to modify
+// the resources. But we do not modify them because we just need to validate the requests to either let them through or
+// block them. We have implemented this mutation interface because we need access to oldObjects during update operations
+// to find out what values are being modified. For node update operation, the old and new objects are always identical
+// in the validation phase (possibly due to some initializer modifying it). So, we are performing this specific
+// vaidation during the mutation phase.
+func (vac *vmwareAdmissionController) Admit(a admission.Attributes) (err error) {
+	if isPrivilegedServiceAccount(a) {
+		return validatePrivilegedServiceAccount(a)
+	}
+
+	return err
+}
+
+// Validate makes an admission decision based on the request attributes.
+func (vac *vmwareAdmissionController) Validate(a admission.Attributes) (err error) {
+	if isPrivilegedUser(vac, a) {
+		return nil
+	}
+
+	if isCertificateFromMaster(a) {
+		return validateCertificateFromMaster(vac, a)
+	}
+
+	if isCertificateFromWorker(a) {
+		return validateCertificateFromWorker(a)
+	}
+
+	if isPrivilegedServiceAccount(a) {
+		return validatePrivilegedServiceAccount(a)
+	}
+
+	if isPrivilegedNamespace(a) {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: cannot modify resources in namespace %s", PluginName, a.GetNamespace()))
+	}
+
+	switch a.GetResource().GroupResource() {
+	case api.Resource("pods"):
+		err = validatePods(vac, a)
+	case api.Resource("nodes"):
+		err = validateNodes(a)
+	case rbac.Resource("clusterroles"):
+		err = validateClusterRoles(a)
+	case rbac.Resource("clusterrolebindings"):
+		err = validateClusterRoleBindings(a)
+	case api.Resource("persistentvolumes"):
+		err = validatePersistentVolumes(vac, a)
+	}
+
+	return err
+}
+
+// Handles returns true if this admission controller can handle the given operation
+// where operation can be one of CREATE, UPDATE, DELETE, or CONNECT.
+func (vac *vmwareAdmissionController) Handles(operation admission.Operation) bool {
+	return true
+}
+
+// NewVMwareAdmissionController creates a new VMwareAdmissionController.
+func NewVMwareAdmissionController(configFile io.Reader) (*vmwareAdmissionController, error) {
+	glog.V(2).Infof("%s is enabled", PluginName)
+	if configFile == nil {
+		glog.Warningf("No config specified for %s. Using default configuration", PluginName)
+		return nil, fmt.Errorf("no config file specified for %s", PluginName)
+	}
+
+	var config AdmissionConfig
+	d := yaml.NewYAMLOrJSONDecoder(configFile, 4096)
+	err := d.Decode(&config)
+	if err != nil {
+		return nil, err
+	}
+
+	// Load PSP from file. If it fails, use default.
+	privilegedMode := true
+	psp := getPSPFromFile(config.VMwareAdmissionController.PodSecurityPolicyFile)
+	if psp == nil {
+		psp = getDefaultPSP()
+		privilegedMode = false
+	}
+
+	return &vmwareAdmissionController{
+		psp:             psp,
+		strategyFactory: podsecuritypolicy.NewSimpleStrategyFactory(),
+		privilegedGroup: config.VMwareAdmissionController.PrivilegedGroup,
+		clusterID:       config.VMwareAdmissionController.ClusterID,
+		privilegedMode:  privilegedMode,
+	}, nil
+}
+
+func getDefaultPSP() *policy.PodSecurityPolicy {
+	return &policy.PodSecurityPolicy{
+		TypeMeta: metav1.TypeMeta{
+			Kind:       "PodSecurityPolicy",
+			APIVersion: "policy/v1beta1",
+		},
+		Spec: policy.PodSecurityPolicySpec{
+			Privileged:               false,
+			HostNetwork:              false,
+			HostIPC:                  false,
+			HostPID:                  false,
+			AllowPrivilegeEscalation: false,
+			HostPorts: []policy.HostPortRange{
+				{1, 65535},
+			},
+			Volumes: []policy.FSType{
+				"emptyDir",
+				"secret",
+				"downwardAPI",
+				"configMap",
+				"persistentVolumeClaim",
+				"projected",
+				"hostPath",
+			},
+			// We allow /etc/ssl/certs to be mounted in read only mode as a hack to allow Wavefront pods to be deployed.
+			// TODO(ashokc): Once we have support for users to create pods using privileged mode and host path, remove this.
+			AllowedHostPaths: []policy.AllowedHostPath{
+				{
+					PathPrefix: etcSslCerts,
+					ReadOnly:   true,
+				},
+			},
+			FSGroup: policy.FSGroupStrategyOptions{
+				Rule: policy.FSGroupStrategyRunAsAny,
+			},
+			RunAsUser: policy.RunAsUserStrategyOptions{
+				Rule: policy.RunAsUserStrategyRunAsAny,
+			},
+			SELinux: policy.SELinuxStrategyOptions{
+				Rule: policy.SELinuxStrategyRunAsAny,
+			},
+			SupplementalGroups: policy.SupplementalGroupsStrategyOptions{
+				Rule: policy.SupplementalGroupsStrategyRunAsAny,
+			},
+		},
+	}
+}
+
+func getPSPFromFile(pspFile string) *policy.PodSecurityPolicy {
+	pspBeta := v1beta1.PodSecurityPolicy{}
+	pspExtensions := policy.PodSecurityPolicy{}
+
+	if pspFile == "" {
+		glog.V(2).Infof("%s: PSP file not specified, using default PSP", PluginName)
+		return nil
+	}
+
+	pspConfig, err := os.Open(pspFile)
+	if err != nil {
+		glog.V(2).Infof("%s: cannot open PSP file, using default PSP: %v", PluginName, err)
+		return nil
+	}
+
+	// We load the PSP that we read from file into pspBeta because this is the struct to which we can decode yaml to.
+	d := yaml.NewYAMLOrJSONDecoder(pspConfig, 4096)
+	err = d.Decode(&pspBeta)
+	if err != nil {
+		glog.V(2).Infof("%s: cannot decode PSP file, using default PSP: %v", PluginName, err)
+		return nil
+	}
+
+	// We convert pspBeta object into pspExtensions object because this is the one that pod validation uses.
+	err = policybeta.Convert_v1beta1_PodSecurityPolicy_To_policy_PodSecurityPolicy(&pspBeta, &pspExtensions, nil)
+	if err != nil {
+		glog.V(2).Infof("%s: cannot convert v1beta1.PSP to extensions.PSP, using default PSP: %v", PluginName, err)
+		return nil
+	}
+
+	return &pspExtensions
+}
+
+func isPrivilegedUser(vac *vmwareAdmissionController, a admission.Attributes) bool {
+	// If the request comes from a user belonging to a privileged group, then we allow it. Only calls from Cascade
+	// controller will belong to this privileged group.
+	groups := a.GetUserInfo().GetGroups()
+	for _, group := range groups {
+		if group == vac.privilegedGroup {
+			return true
+		}
+	}
+
+	return false
+}
+
+func isCertificateFromMaster(a admission.Attributes) bool {
+	groups := a.GetUserInfo().GetGroups()
+	for _, group := range groups {
+		if group == systemMastersGroup {
+			return true
+		}
+	}
+	return false
+}
+
+func validateCertificateFromMaster(vac *vmwareAdmissionController, a admission.Attributes) (err error) {
+	// kube-controller-manager, kube-scheduler and cloud-init script which creates our pods and other resources can use
+	// the master certificate to create pods in privileged namespace. If the request comes to any other namespace,
+	// we need to make it go through our pod validation. This is needed because a user can create a deployment or
+	// replica set which has a privileged pod. Since our admission controller does not look at deployments or replica
+	// sets, we will allow it. The actual pod inside the deployment or replica set will be created by the
+	// controller-manager and if we allow it to create pods in any namespace, then a user can create a privileged pod
+	// totally bypassing our security checks.
+	if !isPrivilegedNamespace(a) && (a.GetResource().GroupResource() == api.Resource("pods")) {
+		return validatePods(vac, a)
+	}
+
+	// For all other resources, allow.
+	return nil
+}
+
+func isCertificateFromWorker(a admission.Attributes) bool {
+	groups := a.GetUserInfo().GetGroups()
+	for _, group := range groups {
+		if group == systemWorkerGroup {
+			return true
+		}
+	}
+	return false
+}
+
+func isCreatingPodsThroughControllerManager(resource string) bool {
+	// If the resource is one of the following, it means the controller manager will create a pod for them and not the
+	// user directly. So, we need to identify these cases and block them in certain scenarios.
+	if resource == "deployments" ||
+		resource == "replicasets" ||
+		resource == "replicationcontrollers" ||
+		resource == "statefulsets" ||
+		resource == "daemonsets" ||
+		resource == "jobs" ||
+		resource == "cronjobs" {
+		return true
+	}
+	return false
+}
+
+func validateCertificateFromWorker(a admission.Attributes) error {
+	// Block exec operations into pods for workers. This is needed to block someone from using Kubelet's certificate to
+	// exec into privileged pods running on the master. Other operations with the node certificate like modifying master
+	// node, creating pods on master node, etc. are blocked by the node restriction admission controller.
+	resource := a.GetResource().GroupResource()
+	if resource == api.Resource("pods") && a.GetOperation() == admission.Connect {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: cannot modify pods in namespace %s", PluginName, a.GetNamespace()))
+	}
+
+	// Block creation of pods indirectly by going through the controller manager.
+	if isCreatingPodsThroughControllerManager(resource.Resource) {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: cannot modify %s in namespace %s", PluginName, resource.Resource, a.GetNamespace()))
+	}
+
+	return nil
+}
+
+func isPrivilegedNamespace(a admission.Attributes) bool {
+	// If the namespace mentioned in the resource is privileged, return true. We will hit this for calls made to all
+	// resources in this namespace and during delete and update operation on the namespace itself.
+	if a.GetNamespace() == privilegedNamespace {
+		return true
+	}
+
+	// If the resource is a namespace and if its name matched the privileged namespace, return true. We will hit this
+	// during creation of the namespace.
+	if a.GetResource().GroupResource() == api.Resource("namespaces") {
+		if namespace, ok := a.GetObject().(*api.Namespace); ok {
+			if namespace.Name == privilegedNamespace {
+				return true
+			}
+		}
+	}
+
+	return false
+}
+
+func isPrivilegedServiceAccount(a admission.Attributes) bool {
+	user := a.GetUserInfo().GetName()
+	return strings.HasPrefix(user, privilegedServiceAccount)
+}
+
+func validatePrivilegedServiceAccount(a admission.Attributes) error {
+	// If the privileged service account performs any operation on the pods resource like create, update or connect,
+	// we block it. This is needed so that we can block exec access into privileged pods running on the master. Also,
+	// privileged service account does not need to perform these operations. So, just to be extra cautious we also block
+	// off create and update pods.
+	resource := a.GetResource().GroupResource()
+	if resource == api.Resource("pods") {
+		// Allow Delete operation on pods
+		if a.GetOperation() == admission.Delete {
+			return nil
+		}
+		// Allow subresources other than exec on pods
+		if len(a.GetSubresource()) != 0 && a.GetSubresource() != "exec" {
+			return nil
+		}
+		// Block all other operations
+		if a.GetOperation() == admission.Create || a.GetOperation() == admission.Update || a.GetOperation() == admission.Connect {
+			return admission.NewForbidden(a,
+				fmt.Errorf("%s validation failed: cannot modify pods in namespace %s", PluginName, a.GetNamespace()))
+		}
+	}
+
+	// If the privileged service account tries to update taints on the master node, we block. We need to do this so that
+	// a user cannot use a privileged service account to untaint the node and run pods on a master.
+	if resource == api.Resource("nodes") {
+		if a.GetOperation() == admission.Update && strings.HasPrefix(a.GetName(), masterNodePrefix) {
+			node, ok := a.GetObject().(*api.Node)
+			if !ok {
+				return admission.NewForbidden(a,
+					fmt.Errorf("%s validation failed: unexpected type %T", PluginName, a.GetObject()))
+			}
+			oldNode, ok := a.GetOldObject().(*api.Node)
+			if !ok {
+				return admission.NewForbidden(a,
+					fmt.Errorf("%s validation failed: unexpected type %T", PluginName, a.GetOldObject()))
+			}
+
+			if !apiequality.Semantic.DeepEqual(node.Spec.Taints, oldNode.Spec.Taints) {
+				return admission.NewForbidden(a,
+					fmt.Errorf("%s validation failed: cannot modify taints on a node", PluginName))
+			}
+		}
+	}
+
+	// Block creation of pods indirectly by going through the controller manager.
+	if isCreatingPodsThroughControllerManager(resource.Resource) {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: cannot modify %s in namespace %s", PluginName, resource.Resource, a.GetNamespace()))
+	}
+
+	return nil
+}
+
+func validateNodes(a admission.Attributes) error {
+	// If it is a connect operation on the sub resource, allow it. Sub resources of nodes are nodes/nodename/proxy and
+	// nodes/nodename/status. Prometheus needs read access to nodes/nodename/proxy/metrics. To support that and other
+	// pods which might need read access to node metrics, we need to allow this. But the VKE authorizer blocks off any
+	// access to perform exec, attach or run on the proxy resource on a master which will prevent the users from getting
+	// access to the privileged pods on master.
+	if a.GetOperation() == admission.Connect && len(a.GetSubresource()) != 0 {
+		return nil
+	}
+
+	// If the operation is Delete, fail. Deleting a node is not something that is useful to the user. Also, by deleting
+	// a node, they can potentially make their cluster useless.
+	if a.GetOperation() == admission.Delete {
+		return admission.NewForbidden(a, fmt.Errorf("%s validation failed: cannot delete nodes", PluginName))
+	}
+
+	// If the operation is on a master node, fail. We do not want to allow the users to modify labels and taints on the
+	// master node because it can compromise the security of the cluster.
+	if strings.HasPrefix(a.GetName(), masterNodePrefix) {
+		return admission.NewForbidden(a, fmt.Errorf("%s validation failed: cannot modify master nodes", PluginName))
+	}
+
+	return nil
+}
+
+func validateClusterRoles(a admission.Attributes) error {
+	// If the name in the request is not empty and has the reserved prefix, then fail. We will hit this during delete
+	// and update operations on the cluster roles. If it does not have the reserved prefix, allow it. If the name is
+	// empty then proceed to read it from the object in the request.
+	if a.GetName() != "" {
+		return checkReservedPrefix(a.GetName(), a)
+	}
+
+	clusterRole, ok := a.GetObject().(*rbac.ClusterRole)
+	// If we cannot get the cluster role binding object, fail.
+	if !ok {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: unexpected type %T", PluginName, a.GetObject()))
+	}
+	// If we get the object and the name has the reserved prefix, fail. We will hit this when someone tries to create a
+	// cluster role with the reserved prefix.
+	return checkReservedPrefix(clusterRole.Name, a)
+}
+
+func validateClusterRoleBindings(a admission.Attributes) error {
+	// If the name in the request is not empty and has the reserved prefix, then fail. We will hit this during delete
+	// and update operations on the cluster role bindings. If it does not have the reserved prefix, allow it. If the
+	// name is empty then proceed to read it from the object in the request.
+	if a.GetName() != "" {
+		return checkReservedPrefix(a.GetName(), a)
+	}
+
+	clusterRoleBinding, ok := a.GetObject().(*rbac.ClusterRoleBinding)
+	// If we cannot get the cluster role binding object, fail.
+	if !ok {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: unexpected type %T", PluginName, a.GetObject()))
+	}
+	// If we get the object and the name has the reserved prefix, fail. We will hit this when someone tries to create a
+	// cluster role binding with the reserved prefix.
+	return checkReservedPrefix(clusterRoleBinding.Name, a)
+}
+
+func validatePersistentVolumes(vac *vmwareAdmissionController, a admission.Attributes) error {
+	// If the operation is not a Create operation, we allow. This is because Create is the only operation which can be
+	// used to create a new PV of type hostPath to get access to the host file system. All the other operations
+	// including Update cannot be used to gain access to host file system.
+	if a.GetOperation() != admission.Create {
+		return nil
+	}
+
+	pv, ok := a.GetObject().(*api.PersistentVolume)
+	// If we cannot get the PV object, fail.
+	if !ok {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: unexpected type %T", PluginName, a.GetObject()))
+	}
+
+	// If we are running in non-privileged mode, then fail if the PV is of type hostPath. We want to do this to prevent
+	// access to host file system on a non-privileged cluster.
+	if !vac.privilegedMode {
+		if pv.Spec.HostPath != nil {
+			return admission.NewForbidden(a,
+				fmt.Errorf("%s validation failed: cannot create a PersistentVolume of type hostPath", PluginName))
+		}
+	}
+
+	return nil
+}
+
+func validatePods(vac *vmwareAdmissionController, a admission.Attributes) error {
+	// If the request is acting on a sub resource of a pod then allow it. This request is not directly coming to a pod,
+	// but to a sub-resource like pods/foo/status. So, this does not have to be blocked.
+	if len(a.GetSubresource()) != 0 {
+		return nil
+	}
+
+	// If it is a Connect or Delete operation, allow it. We restrict access to connect to any pods in the vke-system
+	// namespace. So it is OK to allow this.
+	if a.GetOperation() == admission.Connect || a.GetOperation() == admission.Delete {
+		return nil
+	}
+
+	// If we cannot get the pod object, fail.
+	if _, ok := a.GetObject().(*api.Pod); !ok {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: unexpected type %T", PluginName, a.GetObject()))
+	}
+
+	// If this is an update, see if we are only updating the ownerRef/finalizers.  Garbage collection does this
+	// and we should allow it in general, since you had the power to update and the power to delete.
+	// The worst that happens is that you delete something, but you aren't controlling the privileged object itself
+	if a.GetOperation() == admission.Update &&
+		rbacregistry.IsOnlyMutatingGCFields(a.GetObject(), a.GetOldObject(), apiequality.Semantic) {
+		return nil
+	}
+
+	errs := field.ErrorList{}
+	originalPod := a.GetObject().(*api.Pod)
+
+	// Generate a copy of the pod object because we are not allowed to mutate the pod object.
+	pod := originalPod.DeepCopy()
+
+	provider, err := podsecuritypolicy.NewSimpleProvider(vac.psp, pod.Namespace, vac.strategyFactory)
+	if err != nil {
+		return admission.NewForbidden(a, fmt.Errorf("%s validation failed: %v", PluginName, err))
+	}
+
+	// Set default security context for the pod. This fills in the defaults for the security context values that are not
+	// provided. This is needed to validate the security context correctly.
+	err = provider.DefaultPodSecurityContext(pod)
+	if err != nil {
+		errs = append(errs, field.Invalid(field.NewPath("spec", "securityContext"),
+			pod.Spec.SecurityContext, err.Error()))
+	}
+
+	// Validate the pod.
+	errs = append(errs, provider.ValidatePod(pod, field.NewPath("spec", "securityContext"))...)
+
+	// Validate the pod's tolerations.
+	fieldErr := validatePodToleration(pod)
+	if fieldErr != nil {
+		errs = append(errs, fieldErr)
+	}
+
+	// Validate the initContainers that are part of the pod.
+	for i := range pod.Spec.InitContainers {
+		err := provider.DefaultContainerSecurityContext(pod, &pod.Spec.InitContainers[i])
+		if err != nil {
+			errs = append(errs, field.Invalid(field.NewPath("spec", "initContainers").Index(i).
+				Child("securityContext"), "", err.Error()))
+			continue
+		}
+		errs = append(errs, provider.ValidateContainerSecurityContext(pod, &pod.Spec.InitContainers[i],
+			field.NewPath("spec", "initContainers").Index(i).Child("securityContext"))...)
+	}
+
+	// Validate the containers that are part of the pod.
+	for i := range pod.Spec.Containers {
+		err := provider.DefaultContainerSecurityContext(pod, &pod.Spec.Containers[i])
+		if err != nil {
+			errs = append(errs, field.Invalid(field.NewPath("spec", "containers").Index(i).
+				Child("securityContext"), "", err.Error()))
+			continue
+		}
+		errs = append(errs, provider.ValidateContainerSecurityContext(pod, &pod.Spec.Containers[i],
+			field.NewPath("spec", "containers").Index(i).Child("securityContext"))...)
+	}
+
+	// Validate that /etc/ssl/certs if mounted using hostPath volume mount is readOnly.
+	fieldErr = validateEtcSslCertsHostPath(pod)
+	if fieldErr != nil {
+		errs = append(errs, fieldErr)
+	}
+
+	if len(errs) > 0 {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: %v", PluginName, errs))
+	}
+
+	return nil
+}
+
+func validatePodToleration(pod *api.Pod) *field.Error {
+	// Master nodes are tainted with "Dedicated=Master:NoSchedule". Only vke-system pods are allowed to tolerate
+	// this taint and to run on master nodes. A user's pod will be rejected if its spec has toleration for this taint.
+	for _, t := range pod.Spec.Tolerations {
+		reject := false
+
+		if t.Key == reservedTolerationKey && t.Value == reservedTolerationValue {
+			// Reject pod that has the reserved toleration "Dedicated=Master"
+			reject = true
+		} else if t.Operator == api.TolerationOpExists && (t.Key == reservedTolerationKey || t.Key == "") {
+			// Reject pod that has wildcard toleration matching the reserved toleration
+			reject = true
+		}
+
+		if reject {
+			return field.Invalid(field.NewPath("spec", "toleration"), fmt.Sprintf("%+v", t),
+				fmt.Sprintf("%s validation failed: should not tolerate master node taint", PluginName))
+		}
+	}
+	return nil
+}
+
+// Validate that /etc/ssl/certs if mounted using hostPath volume mount is readOnly. If not, fail.
+// This is a hack that is needed to get Wavefront pods to work.
+// TODO(ashokc): Once we have support for users to create pods using privileged mode and host path, remove this.
+func validateEtcSslCertsHostPath(pod *api.Pod) *field.Error {
+	// Get volumes which mount /etc/ssl/certs and put them in a map.
+	volumes := map[string]struct{}{}
+	for _, vol := range pod.Spec.Volumes {
+		if vol.HostPath != nil && strings.HasPrefix(vol.HostPath.Path, etcSslCerts) {
+			volumes[vol.Name] = struct{}{}
+		}
+	}
+
+	// For every initContainer, get all volumeMounts and verify if it matches any of the volumes in the volumes map.
+	// If yes, then check if they are read only. If not, return an error.
+	err := checkVolumeReadOnly(pod.Spec.InitContainers, volumes, "initContainers")
+	if err != nil {
+		return err
+	}
+
+	// For every container, get all volumeMounts and verify if it matches any of the volumes in the volumes map.
+	// If yes, then check if they are read only. If not, return an error.
+	err = checkVolumeReadOnly(pod.Spec.Containers, volumes, "containers")
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// Checks if the container has a volumeMount belonging to the volumes map. If yes, it has to be read only. If not,
+// return error.
+func checkVolumeReadOnly(containers []api.Container, volumes map[string]struct{}, containerType string) *field.Error {
+	for i, container := range containers {
+		for _, vol := range container.VolumeMounts {
+			if _, ok := volumes[vol.Name]; ok {
+				if !vol.ReadOnly {
+					return field.Invalid(field.NewPath("spec", containerType).Index(i).Child("volumeMounts"),
+						fmt.Sprintf("%+v", vol), fmt.Sprintf("%s has to be mount as readOnly", etcSslCerts))
+				}
+			}
+		}
+	}
+	return nil
+}
+
+func checkReservedPrefix(resourceName string, a admission.Attributes) error {
+	if strings.HasPrefix(resourceName, reservedPrefix) {
+		return admission.NewForbidden(a,
+			fmt.Errorf("%s validation failed: cannot modify resources with prefix %s", PluginName, reservedPrefix))
+	}
+	return nil
+}
diff --git a/plugin/pkg/admission/vke/admission_test.go b/plugin/pkg/admission/vke/admission_test.go
new file mode 100644
index 0000000000..1842253290
--- /dev/null
+++ b/plugin/pkg/admission/vke/admission_test.go
@@ -0,0 +1,995 @@
+package vke
+
+import (
+	"fmt"
+	"os"
+	"strings"
+	"testing"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	kadmission "k8s.io/apiserver/pkg/admission"
+	kapi "k8s.io/kubernetes/pkg/apis/core"
+	"k8s.io/kubernetes/pkg/apis/rbac"
+	"k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/authentication/user"
+)
+
+const (
+	testServiceAccountsGroup = "system.test\\cascade-controller-service-accounts"
+	clusterID                = "cluster-id"
+	defaultConfigFileFormat  = `
+vmwareAdmissionController:
+  privilegedGroup: %s
+  podSecurityPolicyFile: %s
+  clusterID: %s
+`
+	pspFileName   = "/tmp/psp.yaml"
+	pspConfigFile = `
+apiVersion: extensions/v1beta1
+kind: PodSecurityPolicy
+metadata:
+  name: vmware-pod-security-policy-restricted
+spec:
+  privileged: true
+  fsGroup:
+    rule: RunAsAny
+  runAsUser:
+    rule: RunAsAny
+  seLinux:
+    rule: RunAsAny
+  supplementalGroups:
+    rule: RunAsAny
+  volumes:
+  - 'emptyDir'
+  - 'secret'
+  - 'downwardAPI'
+  - 'configMap'
+  - 'persistentVolumeClaim'
+  - 'projected'
+  - 'hostPath'
+  hostPID: false
+  hostIPC: false
+  hostNetwork: true
+  hostPorts:
+  - min: 1
+    max: 65536
+`
+)
+
+func TestAdmitPrivileged(t *testing.T) {
+	tests := map[string]struct {
+		operation          kadmission.Operation
+		pod                *kapi.Pod
+		name               string
+		userInfo           user.Info
+		shouldPassValidate bool
+	}{
+		"create pod with Privileged=nil allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with Privileged=false allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withPrivileged(false).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with Privileged=true denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withPrivileged(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with multiple containers, one has Privileged=true denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withPrivileged(true).withInitContainer().withContainer().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"update pod with Privileged=true denied": {
+			operation:          kadmission.Update,
+			pod:                newTestPodBuilder().withPrivileged(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with HostNetwork=true denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostNetwork(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with HostIPC=true denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostIPC(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with HostPID=true denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostPID(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with HostPort allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostPort().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostVolume denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/", false).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with HostVolume /etc/ssl/certs in read-only mode allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/etc/ssl/certs", true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostVolume /etc/ssl/certs in read-write mode denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/etc/ssl/certs", false).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with CascadeDisk allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withCascadeDisk().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostVolume and CascadeDisk denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/", false).withCascadeDisk().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"connect pod allowed": {
+			operation:          kadmission.Connect,
+			pod:                newTestPodBuilder().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"delete pod allowed": {
+			operation:          kadmission.Delete,
+			pod:                nil,
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+	}
+
+	for k, v := range tests {
+		testPodValidation(k, v.operation, v.pod, v.name, v.userInfo, v.shouldPassValidate, t)
+	}
+}
+
+func TestAdmitPrivilegedWithCustomPSP(t *testing.T) {
+	tests := map[string]struct {
+		operation          kadmission.Operation
+		pod                *kapi.Pod
+		name               string
+		userInfo           user.Info
+		shouldPassValidate bool
+	}{
+		"create pod with Privileged=nil allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with Privileged=false allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withPrivileged(false).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with Privileged=true allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withPrivileged(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with multiple containers, one has Privileged=true allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withPrivileged(true).withInitContainer().withContainer().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"update pod with Privileged=true allowed": {
+			operation:          kadmission.Update,
+			pod:                newTestPodBuilder().withPrivileged(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostNetwork=true allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostNetwork(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostIPC=true denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostIPC(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with HostPID=true denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostPID(true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with HostPort allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostPort().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostVolume allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/", false).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostVolume /etc/ssl/certs in read-only mode allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/etc/ssl/certs", true).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostVolume /etc/ssl/certs in read-write mode denied": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/etc/ssl/certs", false).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"create pod with CascadeDisk allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withCascadeDisk().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"create pod with HostVolume and CascadeDisk allowed": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withHostVolume("/", false).withCascadeDisk().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"connect pod allowed": {
+			operation:          kadmission.Connect,
+			pod:                newTestPodBuilder().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"delete pod allowed": {
+			operation:          kadmission.Delete,
+			pod:                nil,
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+	}
+
+	// Setup custom PSP file.
+	file, err := os.Create(pspFileName)
+	if err != nil {
+		t.Errorf("TestAdmitPrivilegedWithCustomPSP: failed to open custom PSP file %v", err)
+		return
+	}
+	_, err = file.WriteString(pspConfigFile)
+	if err != nil {
+		t.Errorf("TestAdmitPrivilegedWithCustomPSP: failed to write to custom PSP file %v", err)
+		return
+	}
+
+	for k, v := range tests {
+		testPodValidation(k, v.operation, v.pod, v.name, v.userInfo, v.shouldPassValidate, t)
+	}
+
+	// Delete custom PSP file.
+	err = os.Remove(pspFileName)
+	if err != nil {
+		t.Errorf("TestAdmitPrivilegedWithCustomPSP: failed to delete custom PSP file %v", err)
+	}
+}
+
+func TestPrivilegedNamespace(t *testing.T) {
+	tests := map[string]struct {
+		operation          kadmission.Operation
+		pod                *kapi.Pod
+		name               string
+		userInfo           user.Info
+		shouldPassValidate bool
+	}{
+		"denied: regular lightwave user creates pod in vke-system namespace": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user cannot escalate privilege using service account": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).withServiceAccount(privilegedServiceAccount + "default").build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular service account creates pod in vke-system namespace": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withName("system:serviceaccount:kube-system:default").build(),
+			shouldPassValidate: false,
+		},
+		"allowed: privileged service account deletes a pod in privileged namespace": {
+			operation:          kadmission.Delete,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withName(privilegedServiceAccount + "default").build(),
+			shouldPassValidate: true,
+		},
+		"denied: privileged service account creates a pod in privileged namespace": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withName(privilegedServiceAccount + "default").build(),
+			shouldPassValidate: false,
+		},
+		"denied: privileged service account execs into a pod in privileged namespace": {
+			operation:          kadmission.Connect,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withName(privilegedServiceAccount + "default").build(),
+			shouldPassValidate: false,
+		},
+		"denied: privileged service account updates a pod in privileged namespace": {
+			operation:          kadmission.Update,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withName(privilegedServiceAccount + "default").build(),
+			shouldPassValidate: false,
+		},
+		"allowed: regular user creates pod in other namespace": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace("default").build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: Cascade Controller Service Account creates pod in vke-system namespace": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withGroup(testServiceAccountsGroup).build(),
+			shouldPassValidate: true,
+		},
+		"allowed: systemMasters group creates pod in vke-system namespace": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withGroup(systemMastersGroup).build(),
+			shouldPassValidate: true,
+		},
+		"denied: regular lightwave group does not grant privileged access": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withGroup("test1\\group1").build(),
+			shouldPassValidate: false,
+		},
+		"allowed: if user has multiple groups, any privileged group can grant privileged access": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withNamespace(privilegedNamespace).build(),
+			userInfo:           newTestUserBuilder().withGroup("test1\\group1").withGroup(testServiceAccountsGroup).build(),
+			shouldPassValidate: true,
+		},
+		"denied: worker kubelet exec into pod": {
+			operation:          kadmission.Connect,
+			pod:                newTestPodBuilder().build(),
+			userInfo:           newTestUserBuilder().withGroup("system:worker").build(),
+			shouldPassValidate: false,
+		},
+	}
+	for k, v := range tests {
+		testPodValidation(k, v.operation, v.pod, v.name, v.userInfo, v.shouldPassValidate, t)
+	}
+}
+
+func TestToleration(t *testing.T) {
+	tests := map[string]struct {
+		operation          kadmission.Operation
+		pod                *kapi.Pod
+		name               string
+		userInfo           user.Info
+		shouldPassValidate bool
+	}{
+		"allowed: create pod with no toleration": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: create pod with normal toleration key": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withToleration("mykey", reservedTolerationValue, kapi.TolerationOpEqual, kapi.TaintEffectNoSchedule).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: create pod with normal toleration value": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withToleration(reservedTolerationKey, "myval", kapi.TolerationOpEqual, kapi.TaintEffectNoSchedule).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"denied: create pod with reserved toleration": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withToleration(reservedTolerationKey, reservedTolerationValue, kapi.TolerationOpEqual, kapi.TaintEffectNoSchedule).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: create pod with wildcard toleration": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withToleration("", "", kapi.TolerationOpExists, "").build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: create pod with value wildcard toleration": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withToleration(reservedTolerationKey, "", kapi.TolerationOpExists, kapi.TaintEffectNoSchedule).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"allowed: create pod with value wildcard and normal key": {
+			operation:          kadmission.Create,
+			pod:                newTestPodBuilder().withToleration("mykey", "", kapi.TolerationOpExists, kapi.TaintEffectNoSchedule).build(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+	}
+
+	for k, v := range tests {
+		testPodValidation(k, v.operation, v.pod, v.name, v.userInfo, v.shouldPassValidate, t)
+	}
+}
+
+func TestClusterLevelResources(t *testing.T) {
+	tests := map[string]struct {
+		operation          kadmission.Operation
+		resource           string
+		subresource        string
+		name               string
+		namespace          string
+		userInfo           user.Info
+		object             runtime.Object
+		oldObject          runtime.Object
+		shouldPassValidate bool
+	}{
+		"denied: regular lightwave user update configmaps in vke-system namespace": {
+			operation:          kadmission.Update,
+			resource:           "configmaps",
+			namespace:          privilegedNamespace,
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user delete daemonsets in vke-system namespace": {
+			operation:          kadmission.Delete,
+			resource:           "daemonsets",
+			namespace:          privilegedNamespace,
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user create deployments in vke-system namespace": {
+			operation:          kadmission.Create,
+			resource:           "deployments",
+			namespace:          privilegedNamespace,
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user create rolebindings in vke-system namespace": {
+			operation:          kadmission.Create,
+			resource:           "rolebindings",
+			namespace:          privilegedNamespace,
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"allowed: regular lightwave user create rolebindings in other namespace": {
+			operation:          kadmission.Create,
+			resource:           "rolebindings",
+			namespace:          "default",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: regular lightwave user create clusterroles": {
+			operation:          kadmission.Create,
+			resource:           "clusterroles",
+			name:               "cluster-role",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"denied: regular lightwave user create clusterroles with vke: prefix": {
+			operation:          kadmission.Create,
+			resource:           "clusterroles",
+			name:               "vke:clusterrole",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user delete clusterroles with vke: prefix": {
+			operation:          kadmission.Delete,
+			resource:           "clusterroles",
+			name:               "vke:clusterrole",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"allowed: systemMasters group update clusterroles with vke: prefix": {
+			operation:          kadmission.Update,
+			resource:           "clusterroles",
+			name:               "vke:clusterrole",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().withGroup(systemMastersGroup).build(),
+			shouldPassValidate: true,
+		},
+		"allowed: regular lightwave user create clusterrolebindings": {
+			operation:          kadmission.Create,
+			resource:           "clusterrolebindings",
+			name:               "cluster-role-binding",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"denied: regular lightwave user create clusterrolebindings with vke: prefix": {
+			operation:          kadmission.Create,
+			resource:           "clusterrolebindings",
+			name:               "vke:clusterrolebinding",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user update clusterrolebindings with vke: prefix": {
+			operation:          kadmission.Delete,
+			resource:           "clusterrolebindings",
+			name:               "vke:clusterrolebinding",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"allowed: systemMastersGroup update clusterrolebindings with vke: prefix": {
+			operation:          kadmission.Update,
+			resource:           "clusterrolebindings",
+			name:               "vke:clusterrolebinding",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().withGroup(systemMastersGroup).build(),
+			shouldPassValidate: true,
+		},
+		"allowed: regular lightwave user update worker nodes": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			name:               "worker-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: regular lightwave user get worker nodes proxy subresource": {
+			operation:          kadmission.Connect,
+			resource:           "nodes",
+			subresource:        "proxy",
+			name:               "worker-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: regular lightwave user patch worker nodes proxy subresource": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			subresource:        "proxy",
+			name:               "worker-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: regular lightwave user create worker nodes proxy subresource": {
+			operation:          kadmission.Create,
+			resource:           "nodes",
+			subresource:        "proxy",
+			name:               "worker-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"allowed: regular lightwave user get master nodes proxy subresource": {
+			operation:          kadmission.Connect,
+			resource:           "nodes",
+			subresource:        "proxy",
+			name:               "master-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+		"denied: regular lightwave user patch master nodes proxy subresource": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			subresource:        "proxy",
+			name:               "master-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user create master nodes proxy subresource": {
+			operation:          kadmission.Create,
+			resource:           "nodes",
+			subresource:        "proxy",
+			name:               "master-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user update master nodes": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			name:               "master-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user delete master nodes": {
+			operation:          kadmission.Delete,
+			resource:           "nodes",
+			name:               "master-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user delete worker nodes": {
+			operation:          kadmission.Delete,
+			resource:           "nodes",
+			name:               "worker-guid",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"allowed: systemMasters group update nodes": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().withGroup(systemMastersGroup).build(),
+			shouldPassValidate: true,
+		},
+		"allowed: kubelet update node": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			namespace:          "",
+			userInfo:           newTestUserBuilder().withGroup(systemNodesGroup).build(),
+			shouldPassValidate: true,
+		},
+		"allowed: privileged service account update worker node taint": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			namespace:          "",
+			name:               "worker-guid",
+			oldObject:          newTestNodeBuilder().build(),
+			object:             newTestNodeBuilder().withTaint(nil).build(),
+			userInfo:           newTestUserBuilder().withName(privilegedServiceAccount + "default").build(),
+			shouldPassValidate: true,
+		},
+		"denied: privileged service account update master node taint": {
+			operation:          kadmission.Update,
+			resource:           "nodes",
+			namespace:          "",
+			name:               "master-guid",
+			oldObject:          newTestNodeBuilder().build(),
+			object:             newTestNodeBuilder().withTaint(nil).build(),
+			userInfo:           newTestUserBuilder().withName(privilegedServiceAccount + "default").build(),
+			shouldPassValidate: false,
+		},
+		"denied: privileged service account create a deployment": {
+			operation:          kadmission.Create,
+			resource:           "deployments",
+			namespace:          "vke-system",
+			userInfo:           newTestUserBuilder().withName(privilegedServiceAccount + "default").build(),
+			shouldPassValidate: false,
+		},
+		"denied: worker kubelet create a deployment": {
+			operation:          kadmission.Create,
+			resource:           "deployments",
+			namespace:          "vke-system",
+			userInfo:           newTestUserBuilder().withGroup(systemWorkerGroup).build(),
+			shouldPassValidate: false,
+		},
+		"denied: regular lightwave user creates a PV of type hostPath": {
+			operation:          kadmission.Create,
+			resource:           "persistentvolumes",
+			namespace:          "",
+			name:               "test-pv",
+			object:             getHostPathPV(),
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: false,
+		},
+		"allowed: regular lightwave user deletes a PV": {
+			operation:          kadmission.Delete,
+			resource:           "persistentvolumes",
+			namespace:          "",
+			name:               "test-pv",
+			userInfo:           newTestUserBuilder().build(),
+			shouldPassValidate: true,
+		},
+	}
+	for k, v := range tests {
+		testResourceValidation(k, v.operation, v.resource, v.subresource, v.name, v.namespace, v.userInfo, v.object,
+			v.oldObject, v.shouldPassValidate, t)
+	}
+}
+
+func testPodValidation(testCaseName string, op kadmission.Operation, pod *kapi.Pod, name string, userInfo user.Info,
+	shouldPassValidate bool, t *testing.T) {
+
+	defaultConfigFile := fmt.Sprintf(defaultConfigFileFormat, testServiceAccountsGroup, pspFileName, clusterID)
+	configFile := strings.NewReader(defaultConfigFile)
+	plugin, err := NewVMwareAdmissionController(configFile)
+	if err != nil {
+		t.Errorf("%s: failed to create admission controller %v", testCaseName, err)
+	}
+
+	namespace := "default"
+	if pod != nil {
+		namespace = pod.Namespace
+	}
+
+	attrs := kadmission.NewAttributesRecord(pod, nil, kapi.Kind("Pod").WithVersion("version"),
+		namespace, name, kapi.Resource("pods").WithVersion("version"), "", op, userInfo)
+
+	err = plugin.Validate(attrs)
+	if shouldPassValidate && err != nil {
+		t.Errorf("%s: expected no errors on Validate but received %v", testCaseName, err)
+	} else if !shouldPassValidate && err == nil {
+		t.Errorf("%s: expected errors on Validate but received none", testCaseName)
+	}
+}
+
+func testResourceValidation(testCaseName string, op kadmission.Operation, resource, subresource, name, namespace string,
+	userInfo user.Info, object runtime.Object, oldObject runtime.Object, shouldPassValidate bool, t *testing.T) {
+
+	defaultConfigFile := fmt.Sprintf(defaultConfigFileFormat, testServiceAccountsGroup, pspFileName, clusterID)
+	configFile := strings.NewReader(defaultConfigFile)
+	plugin, err := NewVMwareAdmissionController(configFile)
+	if err != nil {
+		t.Errorf("%s: failed to create admission controller %v", testCaseName, err)
+	}
+
+	groupResource := kapi.Resource(resource).WithVersion("version")
+	if resource == "clusterroles" || resource == "clusterrolebindings" {
+		groupResource = rbac.Resource(resource).WithVersion("version")
+	}
+
+	attrs := kadmission.NewAttributesRecord(object, oldObject, kapi.Kind("kind").WithVersion("version"),
+		namespace, name, groupResource, subresource, op, userInfo)
+
+	err = plugin.Validate(attrs)
+	if shouldPassValidate && err != nil {
+		t.Errorf("%s: expected no errors on Validate but received %v", testCaseName, err)
+	} else if !shouldPassValidate && err == nil {
+		t.Errorf("%s: expected errors on Validate but received none", testCaseName)
+	}
+}
+
+// testPodBuilder
+type testPodBuilder struct {
+	pod kapi.Pod
+}
+
+func newTestPodBuilder() *testPodBuilder {
+	builder := new(testPodBuilder)
+	return builder.init()
+}
+
+func (p *testPodBuilder) init() *testPodBuilder {
+	p.pod = kapi.Pod{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:        "pod",
+			Namespace:   "namespace",
+			Annotations: map[string]string{},
+		},
+		Spec: kapi.PodSpec{
+			ServiceAccountName: "default",
+			SecurityContext:    &kapi.PodSecurityContext{},
+			Containers: []kapi.Container{
+				{
+					Name:            "test-container-1",
+					SecurityContext: &kapi.SecurityContext{},
+				},
+			},
+		},
+	}
+	return p
+}
+
+func (p *testPodBuilder) build() *kapi.Pod {
+	return &p.pod
+}
+
+func (p *testPodBuilder) withNamespace(namespace string) *testPodBuilder {
+	p.pod.ObjectMeta.Namespace = namespace
+	return p
+}
+
+func (p *testPodBuilder) withServiceAccount(sa string) *testPodBuilder {
+	p.pod.Spec.ServiceAccountName = sa
+	return p
+}
+
+func (p *testPodBuilder) withPrivileged(v bool) *testPodBuilder {
+	p.pod.Spec.Containers[0].SecurityContext.Privileged = &v
+	return p
+}
+
+func (p *testPodBuilder) withHostNetwork(v bool) *testPodBuilder {
+	p.pod.Spec.SecurityContext.HostNetwork = v
+	return p
+}
+
+func (p *testPodBuilder) withHostIPC(v bool) *testPodBuilder {
+	p.pod.Spec.SecurityContext.HostIPC = v
+	return p
+}
+
+func (p *testPodBuilder) withHostPID(v bool) *testPodBuilder {
+	p.pod.Spec.SecurityContext.HostPID = v
+	return p
+}
+
+func (p *testPodBuilder) withHostPort() *testPodBuilder {
+	containerPorts := []kapi.ContainerPort{
+		{
+			HostPort:      3000,
+			ContainerPort: 80,
+		},
+	}
+
+	p.pod.Spec.Containers[0].Ports = containerPorts
+	return p
+}
+
+func (p *testPodBuilder) withHostVolume(hostPath string, readOnly bool) *testPodBuilder {
+	volume := kapi.Volume{
+		Name: "host",
+		VolumeSource: kapi.VolumeSource{
+			HostPath: &kapi.HostPathVolumeSource{
+				Path: hostPath,
+			},
+		},
+	}
+	volumeMount := kapi.VolumeMount{Name: "host", MountPath: "/data", ReadOnly: readOnly}
+
+	p.pod.Spec.Volumes = append(p.pod.Spec.Volumes, volume)
+	p.pod.Spec.Containers[0].VolumeMounts = append(p.pod.Spec.Containers[0].VolumeMounts, volumeMount)
+	return p
+}
+
+func (p *testPodBuilder) withCascadeDisk() *testPodBuilder {
+	volume := kapi.Volume{
+		Name: "cascadeDisk",
+		VolumeSource: kapi.VolumeSource{
+			PersistentVolumeClaim: &kapi.PersistentVolumeClaimVolumeSource{
+				ClaimName: "00000000-0000-0000-0000-000000000001",
+				ReadOnly:  false,
+			},
+		},
+	}
+	device := kapi.VolumeDevice{Name: "cascadeDisk", DevicePath: "/cascadeDisk"}
+
+	p.pod.Spec.Volumes = append(p.pod.Spec.Volumes, volume)
+	p.pod.Spec.Containers[0].VolumeDevices = append(p.pod.Spec.Containers[0].VolumeDevices, device)
+	return p
+}
+
+func (p *testPodBuilder) withContainer() *testPodBuilder {
+	container := kapi.Container{
+		Name:            "test-container-2",
+		SecurityContext: &kapi.SecurityContext{},
+	}
+
+	p.pod.Spec.Containers = append(p.pod.Spec.Containers, container)
+	return p
+}
+
+func (p *testPodBuilder) withInitContainer() *testPodBuilder {
+	container := kapi.Container{
+		Name:            "test-init-container",
+		SecurityContext: &kapi.SecurityContext{},
+	}
+
+	p.pod.Spec.Containers = append(p.pod.Spec.Containers, container)
+	return p
+}
+
+func (p *testPodBuilder) withToleration(key, value string, operator kapi.TolerationOperator, effect kapi.TaintEffect) *testPodBuilder {
+	p.pod.Spec.Tolerations = append(p.pod.Spec.Tolerations, kapi.Toleration{
+		Key:      key,
+		Value:    value,
+		Operator: operator,
+		Effect:   effect,
+	})
+	return p
+}
+
+// testUserBuilder
+type testUserBuilder struct {
+	user *user.DefaultInfo
+}
+
+func newTestUserBuilder() *testUserBuilder {
+	builder := new(testUserBuilder)
+	return builder.init()
+}
+
+func (p *testUserBuilder) init() *testUserBuilder {
+	p.user = &user.DefaultInfo{
+		Name:   "https://lightwave.cascade-cloud.com/openidconnect/00000000-0000-0000-0000-000000000001#joe@vmware.com",
+		UID:    "10001",
+		Groups: []string{},
+	}
+	return p
+}
+
+func (p *testUserBuilder) build() *user.DefaultInfo {
+	return p.user
+}
+
+func (p *testUserBuilder) withName(name string) *testUserBuilder {
+	p.user.Name = name
+	return p
+}
+
+func (p *testUserBuilder) withGroup(group string) *testUserBuilder {
+	p.user.Groups = append(p.user.Groups, group)
+	return p
+}
+
+// testNodeBuilder
+type testNodeBuilder struct {
+	node kapi.Node
+}
+
+func newTestNodeBuilder() *testNodeBuilder {
+	builder := new(testNodeBuilder)
+	return builder.init()
+}
+
+func (n *testNodeBuilder) init() *testNodeBuilder {
+	n.node = kapi.Node{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:        "node",
+			Namespace:   "",
+			Annotations: nil,
+		},
+		Spec: kapi.NodeSpec{
+			Taints: []kapi.Taint{
+				{
+					"Dedicated", "Master", "NoSchedule", nil,
+				},
+			},
+		},
+	}
+	return n
+}
+
+func (n *testNodeBuilder) build() *kapi.Node {
+	return &n.node
+}
+
+func (n *testNodeBuilder) withTaint(taints []kapi.Taint) *testNodeBuilder {
+	n.node.Spec.Taints = taints
+	return n
+}
+
+func getHostPathPV() *kapi.PersistentVolume {
+	return &kapi.PersistentVolume{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:        "test-pv",
+			Namespace:   "",
+			Annotations: nil,
+		},
+		Spec: kapi.PersistentVolumeSpec{
+			StorageClassName: "manual",
+			PersistentVolumeSource: kapi.PersistentVolumeSource{
+				HostPath: &kapi.HostPathVolumeSource{
+					Path: "/",
+				},
+			},
+		},
+	}
+}
diff --git a/plugin/pkg/auth/authorizer/vke/BUILD b/plugin/pkg/auth/authorizer/vke/BUILD
new file mode 100644
index 0000000000..4b984f14ec
--- /dev/null
+++ b/plugin/pkg/auth/authorizer/vke/BUILD
@@ -0,0 +1,40 @@
+package(default_visibility = ["//visibility:public"])
+
+load(
+    "@io_bazel_rules_go//go:def.bzl",
+    "go_library",
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = ["vke_authorizer_test.go"],
+    embed = [":go_default_library"],
+    deps = [
+        "//vendor/k8s.io/apiserver/pkg/authentication/user:go_default_library",
+        "//vendor/k8s.io/apiserver/pkg/authorization/authorizer:go_default_library",
+    ],
+)
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "vke_authorizer.go",
+    ],
+    importpath = "k8s.io/kubernetes/plugin/pkg/auth/authorizer/vke",
+    deps = [
+        "//vendor/k8s.io/apiserver/pkg/authorization/authorizer:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [":package-srcs"],
+    tags = ["automanaged"],
+)
diff --git a/plugin/pkg/auth/authorizer/vke/OWNERS b/plugin/pkg/auth/authorizer/vke/OWNERS
new file mode 100644
index 0000000000..c3a4ed77dc
--- /dev/null
+++ b/plugin/pkg/auth/authorizer/vke/OWNERS
@@ -0,0 +1,2 @@
+maintainers:
+- ashokc
diff --git a/plugin/pkg/auth/authorizer/vke/vke_authorizer.go b/plugin/pkg/auth/authorizer/vke/vke_authorizer.go
new file mode 100644
index 0000000000..6d7f9ae2b8
--- /dev/null
+++ b/plugin/pkg/auth/authorizer/vke/vke_authorizer.go
@@ -0,0 +1,125 @@
+package vke
+
+import (
+	"bufio"
+	"fmt"
+	"os"
+	"strings"
+
+	"github.com/golang/glog"
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+)
+
+const (
+	systemClusterPrefix = "system:clusterID:"
+	systemNodePrefix    = "system:node:"
+	systemWorkerGroup   = "system:worker"
+	masterPrefix        = "master-"
+)
+
+
+// VKEAuthorizer authorizes requests which comes from nodes using certificates.
+// If a request is from a node which is not a part of the cluster, reject.
+type VKEAuthorizer struct {
+	clusterID string
+}
+
+// NewAuthorizer returns a new node authorizer
+func NewAuthorizer() (authorizer.Authorizer, error) {
+	file, err := os.Open("/etc/kubernetes/cc_cloud.config")
+	if err != nil {
+		return nil, err
+	}
+	defer file.Close()
+
+	scanner := bufio.NewScanner(file)
+
+	for scanner.Scan() {
+		lineContent := scanner.Text()
+		if strings.Contains(lineContent, "clusterID = ") {
+			clusterID := strings.SplitAfter(lineContent, "= ")[1]
+			return &VKEAuthorizer{clusterID: clusterID}, nil
+		}
+	}
+
+	return nil, fmt.Errorf("Cluster ID cannot be parsed from config file successfully")
+}
+
+// Authorize authorizes requests based on the VKE authorizer.
+func (v *VKEAuthorizer) Authorize(attrs authorizer.Attributes) (authorizer.Decision, string, error) {
+	// If the request comes from a non cluster node, then deny.
+	if isNonClusterNode(attrs, v.clusterID) {
+		glog.V(2).Infof("VKE authorizer: DENY the request because it is from a different cluster")
+		return authorizer.DecisionDeny, "", nil
+	}
+
+	// If a worker node name does not have the node prefix, then deny. This is needed for the request to go through node
+	// authorizer and node restriction admission controller. If it is not set, then a user can bypass node authorizer
+	// and the node restriction admission controller and modify the master node.
+	if isWorkerWithoutNodeNameRestriction(attrs) {
+		glog.V(2).Infof("VKE authorizer: DENY the request because the node name restriction is not met")
+		return authorizer.DecisionDeny, "", nil
+	}
+
+	// If it is a proxy request to the master node to exec, run or attach to a container, then deny.
+	if isProxyRequestToMasterNode(attrs) {
+		glog.V(2).Infof("VKE authorizer: DENY the request because it tried to execute commands on master pods")
+		return authorizer.DecisionDeny, "", nil
+	}
+
+	return authorizer.DecisionNoOpinion, "", nil
+}
+
+// isNonClusterNode verifies that the request is not from a node which does not belong to this cluster. This is needed
+// to prevent cross cluster attacks where a user can use the kubelet certificate of one cluster to access the resources
+// in another cluster. The reason we have this check is because, when a certificate is presented for authentication,
+// Kubernetes just verifies that the certificate is signed by the CA that the cluster trusts. Since, in our case, the CA
+// is same for all clusters, authentication with certificate is not enough. So, we make sure that the request is not
+// from another cluster. Lightwave will make sure that any certificates generated on a worker will always have the
+// "system:clusterID:<id>" group. This way, we can just check the cluster ID in the group and reject if it is not the
+// same as this cluster's ID.
+func isNonClusterNode(attrs authorizer.Attributes, clusterID string) bool {
+	groups := attrs.GetUser().GetGroups()
+	for _, group := range groups {
+		if strings.HasPrefix(group, systemClusterPrefix) {
+			groupParts := strings.Split(group, ":")
+			if clusterID != "" && groupParts[len(groupParts)-1] != clusterID {
+				return true
+			}
+		}
+	}
+
+	return false
+}
+
+// isWorkerWithoutNodeNameRestriction verifies that the certificate presented by the worker nodes also have the
+// appropriate name "system:node:<hostname>". We need to validate this because it is possible for a user to generate
+// certificates with CN other than "system:node:<hostname>". This is because lightwave does group validation and that
+// the CNs can be one of system:node:<hostname>, kubernetes-master and etcd. When that happens, that certificate will be
+// able to bypass the NodeRestriction admission controller which will allow access to modify master node and create pods
+// on master. To prevent that from happening, we need to verify that if a request comes from a worker node, then it has
+// to have the expected name so that NodeRestriction admission controller is enforced.
+func isWorkerWithoutNodeNameRestriction(attrs authorizer.Attributes) bool {
+	groups := attrs.GetUser().GetGroups()
+	name := attrs.GetUser().GetName()
+	for _, group := range groups {
+		if group == systemWorkerGroup && !strings.HasPrefix(name, systemNodePrefix) {
+			return true
+		}
+	}
+	return false
+}
+
+// isProxyRequestToMasterNode checks if the request is made to exec, run or attach to a container on the master node. We
+// need this check because we do not want to allow a user to exec into a privileged pod on the master node.
+func isProxyRequestToMasterNode(attrs authorizer.Attributes) bool {
+	if attrs.GetResource() == "nodes" && strings.HasPrefix(attrs.GetName(), masterPrefix) {
+		if strings.Contains(attrs.GetPath(), "proxy/run") ||
+			strings.Contains(attrs.GetPath(), "proxy/exec") ||
+			strings.Contains(attrs.GetPath(), "proxy/attach") {
+			return true
+		}
+	}
+	return false
+}
+
diff --git a/plugin/pkg/auth/authorizer/vke/vke_authorizer_test.go b/plugin/pkg/auth/authorizer/vke/vke_authorizer_test.go
new file mode 100644
index 0000000000..6aba9ecec9
--- /dev/null
+++ b/plugin/pkg/auth/authorizer/vke/vke_authorizer_test.go
@@ -0,0 +1,230 @@
+package vke
+
+import (
+	"testing"
+
+	"k8s.io/apiserver/pkg/authentication/user"
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+)
+
+const (
+	masterProxyAttachPath = "/api/v1/nodes/master-0/proxy/attach/vke-system/pod-name/container-name"
+	masterProxyExecPath   = "/api/v1/nodes/master-0/proxy/exec/vke-system/pod-name/container-name"
+	masterProxyRunPath    = "/api/v1/nodes/master-0/proxy/run/vke-system/pod-name/container-name"
+	workerProxyAttachPath = "/api/v1/nodes/worker-0/proxy/attach/vke-system/pod-name/container-name"
+	workerProxyExecPath   = "/api/v1/nodes/worker-0/proxy/exec/vke-system/pod-name/container-name"
+	workerProxyRunPath    = "/api/v1/nodes/worker-0/proxy/run/vke-system/pod-name/container-name"
+)
+
+func TestAuthorizer(t *testing.T) {
+	authz := &VKEAuthorizer{clusterID: "cluster-id"}
+
+	clusterNode := &user.DefaultInfo{Name: "system:node:worker-0", Groups: []string{"system:nodes", "system:clusterID:cluster-id", "system:worker"}}
+	crossClusterNode := &user.DefaultInfo{Name: "system:node:worker-0", Groups: []string{"system:nodes", "system:clusterID:invalid", "system:worker"}}
+	invalidWorker := &user.DefaultInfo{Name: "worker-0", Groups: []string{"system:nodes", "system:clusterID:cluster-id", "system:worker"}}
+
+	tests := []struct {
+		name   string
+		attrs  authorizer.AttributesRecord
+		expect authorizer.Decision
+	}{
+		// Do not deny requests from a normal cluster node user.
+		{
+			name:   "allowed: cluster node get pod",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "get", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node list pod",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "list", Resource: "pods", Namespace: "ns"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node create pod",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node update pod",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "update", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node delete pod",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "delete", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node get node",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "get", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node list nodes",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "list", Resource: "nodes"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node create nodes",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node update nodes",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "update", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: cluster node delete nodes",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "delete", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionNoOpinion,
+		},
+
+		// Deny requests from another cluster node.
+		{
+			name:   "denied: cross cluster node get pod",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "get", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node list pod",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "list", Resource: "pods", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node create pod",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "create", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node update pod",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "update", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node delete pod",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "delete", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node get node",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "get", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node list nodes",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "list", Resource: "nodes"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node create nodes",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node update nodes",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "update", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: cross cluster node delete nodes",
+			attrs:  authorizer.AttributesRecord{User: crossClusterNode, ResourceRequest: true, Verb: "delete", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+
+		// Deny requests from invalid node.
+		{
+			name:   "denied: invalid worker get pod",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "get", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker list pod",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "list", Resource: "pods", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker create pod",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "create", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker update pod",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "update", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker delete pod",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "delete", Resource: "pods", Name: "pod", Namespace: "ns"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker get node",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "get", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker list nodes",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "list", Resource: "nodes"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker create nodes",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker update nodes",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "update", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: invalid worker delete nodes",
+			attrs:  authorizer.AttributesRecord{User: invalidWorker, ResourceRequest: true, Verb: "delete", Resource: "nodes", Name: "node"},
+			expect: authorizer.DecisionDeny,
+		},
+
+		// Deny exec, run and attach operation on master nodes using proxy resource.
+		{
+			name:   "denied: attach using proxy resource on master",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "master-0", Path: masterProxyAttachPath},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: exec using proxy resource on master",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "master-0", Path: masterProxyExecPath},
+			expect: authorizer.DecisionDeny,
+		},
+		{
+			name:   "denied: run using proxy resource on master",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "master-0", Path: masterProxyRunPath},
+			expect: authorizer.DecisionDeny,
+		},
+
+		// Do not deny exec, run and attach operation on worker nodes using proxy resource.
+		{
+			name:   "allowed: attach using proxy resource on worker",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "worker-0", Path: workerProxyAttachPath},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: exec using proxy resource on worker",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "worker-0", Path: workerProxyExecPath},
+			expect: authorizer.DecisionNoOpinion,
+		},
+		{
+			name:   "allowed: run using proxy resource on worker",
+			attrs:  authorizer.AttributesRecord{User: clusterNode, ResourceRequest: true, Verb: "create", Resource: "nodes", Name: "worker-0", Path: workerProxyRunPath},
+			expect: authorizer.DecisionNoOpinion,
+		},
+	}
+
+	for _, tc := range tests {
+		t.Run(tc.name, func(t *testing.T) {
+			decision, _, _ := authz.Authorize(tc.attrs)
+			if decision != tc.expect {
+				t.Errorf("expected %v, got %v", tc.expect, decision)
+			}
+		})
+	}
+}
diff --git a/staging/src/k8s.io/api/core/v1/generated.pb.go b/staging/src/k8s.io/api/core/v1/generated.pb.go
index a809ceb0ae..f27250e2d9 100644
--- a/staging/src/k8s.io/api/core/v1/generated.pb.go
+++ b/staging/src/k8s.io/api/core/v1/generated.pb.go
@@ -35,6 +35,7 @@ limitations under the License.
 		Binding
 		CSIPersistentVolumeSource
 		Capabilities
+		CascadeDiskVolumeSource
 		CephFSPersistentVolumeSource
 		CephFSVolumeSource
 		CinderPersistentVolumeSource
@@ -296,800 +297,806 @@ func (m *Capabilities) Reset()                    { *m = Capabilities{} }
 func (*Capabilities) ProtoMessage()               {}
 func (*Capabilities) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{9} }
 
+func (m *CascadeDiskVolumeSource) Reset()      { *m = CascadeDiskVolumeSource{} }
+func (*CascadeDiskVolumeSource) ProtoMessage() {}
+func (*CascadeDiskVolumeSource) Descriptor() ([]byte, []int) {
+	return fileDescriptorGenerated, []int{10}
+}
+
 func (m *CephFSPersistentVolumeSource) Reset()      { *m = CephFSPersistentVolumeSource{} }
 func (*CephFSPersistentVolumeSource) ProtoMessage() {}
 func (*CephFSPersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{10}
+	return fileDescriptorGenerated, []int{11}
 }
 
 func (m *CephFSVolumeSource) Reset()                    { *m = CephFSVolumeSource{} }
 func (*CephFSVolumeSource) ProtoMessage()               {}
-func (*CephFSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{11} }
+func (*CephFSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{12} }
 
 func (m *CinderPersistentVolumeSource) Reset()      { *m = CinderPersistentVolumeSource{} }
 func (*CinderPersistentVolumeSource) ProtoMessage() {}
 func (*CinderPersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{12}
+	return fileDescriptorGenerated, []int{13}
 }
 
 func (m *CinderVolumeSource) Reset()                    { *m = CinderVolumeSource{} }
 func (*CinderVolumeSource) ProtoMessage()               {}
-func (*CinderVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{13} }
+func (*CinderVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{14} }
 
 func (m *ClientIPConfig) Reset()                    { *m = ClientIPConfig{} }
 func (*ClientIPConfig) ProtoMessage()               {}
-func (*ClientIPConfig) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{14} }
+func (*ClientIPConfig) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{15} }
 
 func (m *ComponentCondition) Reset()                    { *m = ComponentCondition{} }
 func (*ComponentCondition) ProtoMessage()               {}
-func (*ComponentCondition) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{15} }
+func (*ComponentCondition) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{16} }
 
 func (m *ComponentStatus) Reset()                    { *m = ComponentStatus{} }
 func (*ComponentStatus) ProtoMessage()               {}
-func (*ComponentStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{16} }
+func (*ComponentStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{17} }
 
 func (m *ComponentStatusList) Reset()                    { *m = ComponentStatusList{} }
 func (*ComponentStatusList) ProtoMessage()               {}
-func (*ComponentStatusList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{17} }
+func (*ComponentStatusList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{18} }
 
 func (m *ConfigMap) Reset()                    { *m = ConfigMap{} }
 func (*ConfigMap) ProtoMessage()               {}
-func (*ConfigMap) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{18} }
+func (*ConfigMap) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{19} }
 
 func (m *ConfigMapEnvSource) Reset()                    { *m = ConfigMapEnvSource{} }
 func (*ConfigMapEnvSource) ProtoMessage()               {}
-func (*ConfigMapEnvSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{19} }
+func (*ConfigMapEnvSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{20} }
 
 func (m *ConfigMapKeySelector) Reset()                    { *m = ConfigMapKeySelector{} }
 func (*ConfigMapKeySelector) ProtoMessage()               {}
-func (*ConfigMapKeySelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{20} }
+func (*ConfigMapKeySelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{21} }
 
 func (m *ConfigMapList) Reset()                    { *m = ConfigMapList{} }
 func (*ConfigMapList) ProtoMessage()               {}
-func (*ConfigMapList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{21} }
+func (*ConfigMapList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{22} }
 
 func (m *ConfigMapNodeConfigSource) Reset()      { *m = ConfigMapNodeConfigSource{} }
 func (*ConfigMapNodeConfigSource) ProtoMessage() {}
 func (*ConfigMapNodeConfigSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{22}
+	return fileDescriptorGenerated, []int{23}
 }
 
 func (m *ConfigMapProjection) Reset()                    { *m = ConfigMapProjection{} }
 func (*ConfigMapProjection) ProtoMessage()               {}
-func (*ConfigMapProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{23} }
+func (*ConfigMapProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{24} }
 
 func (m *ConfigMapVolumeSource) Reset()                    { *m = ConfigMapVolumeSource{} }
 func (*ConfigMapVolumeSource) ProtoMessage()               {}
-func (*ConfigMapVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{24} }
+func (*ConfigMapVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{25} }
 
 func (m *Container) Reset()                    { *m = Container{} }
 func (*Container) ProtoMessage()               {}
-func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{25} }
+func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{26} }
 
 func (m *ContainerImage) Reset()                    { *m = ContainerImage{} }
 func (*ContainerImage) ProtoMessage()               {}
-func (*ContainerImage) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{26} }
+func (*ContainerImage) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{27} }
 
 func (m *ContainerPort) Reset()                    { *m = ContainerPort{} }
 func (*ContainerPort) ProtoMessage()               {}
-func (*ContainerPort) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{27} }
+func (*ContainerPort) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{28} }
 
 func (m *ContainerState) Reset()                    { *m = ContainerState{} }
 func (*ContainerState) ProtoMessage()               {}
-func (*ContainerState) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{28} }
+func (*ContainerState) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{29} }
 
 func (m *ContainerStateRunning) Reset()                    { *m = ContainerStateRunning{} }
 func (*ContainerStateRunning) ProtoMessage()               {}
-func (*ContainerStateRunning) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{29} }
+func (*ContainerStateRunning) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{30} }
 
 func (m *ContainerStateTerminated) Reset()      { *m = ContainerStateTerminated{} }
 func (*ContainerStateTerminated) ProtoMessage() {}
 func (*ContainerStateTerminated) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{30}
+	return fileDescriptorGenerated, []int{31}
 }
 
 func (m *ContainerStateWaiting) Reset()                    { *m = ContainerStateWaiting{} }
 func (*ContainerStateWaiting) ProtoMessage()               {}
-func (*ContainerStateWaiting) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{31} }
+func (*ContainerStateWaiting) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{32} }
 
 func (m *ContainerStatus) Reset()                    { *m = ContainerStatus{} }
 func (*ContainerStatus) ProtoMessage()               {}
-func (*ContainerStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{32} }
+func (*ContainerStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{33} }
 
 func (m *DaemonEndpoint) Reset()                    { *m = DaemonEndpoint{} }
 func (*DaemonEndpoint) ProtoMessage()               {}
-func (*DaemonEndpoint) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{33} }
+func (*DaemonEndpoint) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{34} }
 
 func (m *DownwardAPIProjection) Reset()                    { *m = DownwardAPIProjection{} }
 func (*DownwardAPIProjection) ProtoMessage()               {}
-func (*DownwardAPIProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{34} }
+func (*DownwardAPIProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{35} }
 
 func (m *DownwardAPIVolumeFile) Reset()                    { *m = DownwardAPIVolumeFile{} }
 func (*DownwardAPIVolumeFile) ProtoMessage()               {}
-func (*DownwardAPIVolumeFile) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{35} }
+func (*DownwardAPIVolumeFile) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{36} }
 
 func (m *DownwardAPIVolumeSource) Reset()      { *m = DownwardAPIVolumeSource{} }
 func (*DownwardAPIVolumeSource) ProtoMessage() {}
 func (*DownwardAPIVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{36}
+	return fileDescriptorGenerated, []int{37}
 }
 
 func (m *EmptyDirVolumeSource) Reset()                    { *m = EmptyDirVolumeSource{} }
 func (*EmptyDirVolumeSource) ProtoMessage()               {}
-func (*EmptyDirVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{37} }
+func (*EmptyDirVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{38} }
 
 func (m *EndpointAddress) Reset()                    { *m = EndpointAddress{} }
 func (*EndpointAddress) ProtoMessage()               {}
-func (*EndpointAddress) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{38} }
+func (*EndpointAddress) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{39} }
 
 func (m *EndpointPort) Reset()                    { *m = EndpointPort{} }
 func (*EndpointPort) ProtoMessage()               {}
-func (*EndpointPort) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{39} }
+func (*EndpointPort) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{40} }
 
 func (m *EndpointSubset) Reset()                    { *m = EndpointSubset{} }
 func (*EndpointSubset) ProtoMessage()               {}
-func (*EndpointSubset) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{40} }
+func (*EndpointSubset) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{41} }
 
 func (m *Endpoints) Reset()                    { *m = Endpoints{} }
 func (*Endpoints) ProtoMessage()               {}
-func (*Endpoints) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{41} }
+func (*Endpoints) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{42} }
 
 func (m *EndpointsList) Reset()                    { *m = EndpointsList{} }
 func (*EndpointsList) ProtoMessage()               {}
-func (*EndpointsList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{42} }
+func (*EndpointsList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{43} }
 
 func (m *EnvFromSource) Reset()                    { *m = EnvFromSource{} }
 func (*EnvFromSource) ProtoMessage()               {}
-func (*EnvFromSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{43} }
+func (*EnvFromSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{44} }
 
 func (m *EnvVar) Reset()                    { *m = EnvVar{} }
 func (*EnvVar) ProtoMessage()               {}
-func (*EnvVar) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{44} }
+func (*EnvVar) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{45} }
 
 func (m *EnvVarSource) Reset()                    { *m = EnvVarSource{} }
 func (*EnvVarSource) ProtoMessage()               {}
-func (*EnvVarSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{45} }
+func (*EnvVarSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{46} }
 
 func (m *Event) Reset()                    { *m = Event{} }
 func (*Event) ProtoMessage()               {}
-func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{46} }
+func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{47} }
 
 func (m *EventList) Reset()                    { *m = EventList{} }
 func (*EventList) ProtoMessage()               {}
-func (*EventList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{47} }
+func (*EventList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{48} }
 
 func (m *EventSeries) Reset()                    { *m = EventSeries{} }
 func (*EventSeries) ProtoMessage()               {}
-func (*EventSeries) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{48} }
+func (*EventSeries) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{49} }
 
 func (m *EventSource) Reset()                    { *m = EventSource{} }
 func (*EventSource) ProtoMessage()               {}
-func (*EventSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{49} }
+func (*EventSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{50} }
 
 func (m *ExecAction) Reset()                    { *m = ExecAction{} }
 func (*ExecAction) ProtoMessage()               {}
-func (*ExecAction) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{50} }
+func (*ExecAction) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{51} }
 
 func (m *FCVolumeSource) Reset()                    { *m = FCVolumeSource{} }
 func (*FCVolumeSource) ProtoMessage()               {}
-func (*FCVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{51} }
+func (*FCVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{52} }
 
 func (m *FlexPersistentVolumeSource) Reset()      { *m = FlexPersistentVolumeSource{} }
 func (*FlexPersistentVolumeSource) ProtoMessage() {}
 func (*FlexPersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{52}
+	return fileDescriptorGenerated, []int{53}
 }
 
 func (m *FlexVolumeSource) Reset()                    { *m = FlexVolumeSource{} }
 func (*FlexVolumeSource) ProtoMessage()               {}
-func (*FlexVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{53} }
+func (*FlexVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{54} }
 
 func (m *FlockerVolumeSource) Reset()                    { *m = FlockerVolumeSource{} }
 func (*FlockerVolumeSource) ProtoMessage()               {}
-func (*FlockerVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{54} }
+func (*FlockerVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{55} }
 
 func (m *GCEPersistentDiskVolumeSource) Reset()      { *m = GCEPersistentDiskVolumeSource{} }
 func (*GCEPersistentDiskVolumeSource) ProtoMessage() {}
 func (*GCEPersistentDiskVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{55}
+	return fileDescriptorGenerated, []int{56}
 }
 
 func (m *GitRepoVolumeSource) Reset()                    { *m = GitRepoVolumeSource{} }
 func (*GitRepoVolumeSource) ProtoMessage()               {}
-func (*GitRepoVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{56} }
+func (*GitRepoVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{57} }
 
 func (m *GlusterfsVolumeSource) Reset()                    { *m = GlusterfsVolumeSource{} }
 func (*GlusterfsVolumeSource) ProtoMessage()               {}
-func (*GlusterfsVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{57} }
+func (*GlusterfsVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{58} }
 
 func (m *HTTPGetAction) Reset()                    { *m = HTTPGetAction{} }
 func (*HTTPGetAction) ProtoMessage()               {}
-func (*HTTPGetAction) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{58} }
+func (*HTTPGetAction) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{59} }
 
 func (m *HTTPHeader) Reset()                    { *m = HTTPHeader{} }
 func (*HTTPHeader) ProtoMessage()               {}
-func (*HTTPHeader) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{59} }
+func (*HTTPHeader) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{60} }
 
 func (m *Handler) Reset()                    { *m = Handler{} }
 func (*Handler) ProtoMessage()               {}
-func (*Handler) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{60} }
+func (*Handler) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{61} }
 
 func (m *HostAlias) Reset()                    { *m = HostAlias{} }
 func (*HostAlias) ProtoMessage()               {}
-func (*HostAlias) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{61} }
+func (*HostAlias) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{62} }
 
 func (m *HostPathVolumeSource) Reset()                    { *m = HostPathVolumeSource{} }
 func (*HostPathVolumeSource) ProtoMessage()               {}
-func (*HostPathVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{62} }
+func (*HostPathVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{63} }
 
 func (m *ISCSIPersistentVolumeSource) Reset()      { *m = ISCSIPersistentVolumeSource{} }
 func (*ISCSIPersistentVolumeSource) ProtoMessage() {}
 func (*ISCSIPersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{63}
+	return fileDescriptorGenerated, []int{64}
 }
 
 func (m *ISCSIVolumeSource) Reset()                    { *m = ISCSIVolumeSource{} }
 func (*ISCSIVolumeSource) ProtoMessage()               {}
-func (*ISCSIVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{64} }
+func (*ISCSIVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{65} }
 
 func (m *KeyToPath) Reset()                    { *m = KeyToPath{} }
 func (*KeyToPath) ProtoMessage()               {}
-func (*KeyToPath) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{65} }
+func (*KeyToPath) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{66} }
 
 func (m *Lifecycle) Reset()                    { *m = Lifecycle{} }
 func (*Lifecycle) ProtoMessage()               {}
-func (*Lifecycle) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{66} }
+func (*Lifecycle) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{67} }
 
 func (m *LimitRange) Reset()                    { *m = LimitRange{} }
 func (*LimitRange) ProtoMessage()               {}
-func (*LimitRange) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{67} }
+func (*LimitRange) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{68} }
 
 func (m *LimitRangeItem) Reset()                    { *m = LimitRangeItem{} }
 func (*LimitRangeItem) ProtoMessage()               {}
-func (*LimitRangeItem) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{68} }
+func (*LimitRangeItem) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{69} }
 
 func (m *LimitRangeList) Reset()                    { *m = LimitRangeList{} }
 func (*LimitRangeList) ProtoMessage()               {}
-func (*LimitRangeList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{69} }
+func (*LimitRangeList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{70} }
 
 func (m *LimitRangeSpec) Reset()                    { *m = LimitRangeSpec{} }
 func (*LimitRangeSpec) ProtoMessage()               {}
-func (*LimitRangeSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{70} }
+func (*LimitRangeSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{71} }
 
 func (m *List) Reset()                    { *m = List{} }
 func (*List) ProtoMessage()               {}
-func (*List) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{71} }
+func (*List) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{72} }
 
 func (m *LoadBalancerIngress) Reset()                    { *m = LoadBalancerIngress{} }
 func (*LoadBalancerIngress) ProtoMessage()               {}
-func (*LoadBalancerIngress) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{72} }
+func (*LoadBalancerIngress) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{73} }
 
 func (m *LoadBalancerStatus) Reset()                    { *m = LoadBalancerStatus{} }
 func (*LoadBalancerStatus) ProtoMessage()               {}
-func (*LoadBalancerStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{73} }
+func (*LoadBalancerStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{74} }
 
 func (m *LocalObjectReference) Reset()                    { *m = LocalObjectReference{} }
 func (*LocalObjectReference) ProtoMessage()               {}
-func (*LocalObjectReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{74} }
+func (*LocalObjectReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{75} }
 
 func (m *LocalVolumeSource) Reset()                    { *m = LocalVolumeSource{} }
 func (*LocalVolumeSource) ProtoMessage()               {}
-func (*LocalVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{75} }
+func (*LocalVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{76} }
 
 func (m *NFSVolumeSource) Reset()                    { *m = NFSVolumeSource{} }
 func (*NFSVolumeSource) ProtoMessage()               {}
-func (*NFSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{76} }
+func (*NFSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{77} }
 
 func (m *Namespace) Reset()                    { *m = Namespace{} }
 func (*Namespace) ProtoMessage()               {}
-func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{77} }
+func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{78} }
 
 func (m *NamespaceList) Reset()                    { *m = NamespaceList{} }
 func (*NamespaceList) ProtoMessage()               {}
-func (*NamespaceList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{78} }
+func (*NamespaceList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{79} }
 
 func (m *NamespaceSpec) Reset()                    { *m = NamespaceSpec{} }
 func (*NamespaceSpec) ProtoMessage()               {}
-func (*NamespaceSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{79} }
+func (*NamespaceSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{80} }
 
 func (m *NamespaceStatus) Reset()                    { *m = NamespaceStatus{} }
 func (*NamespaceStatus) ProtoMessage()               {}
-func (*NamespaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{80} }
+func (*NamespaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{81} }
 
 func (m *Node) Reset()                    { *m = Node{} }
 func (*Node) ProtoMessage()               {}
-func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{81} }
+func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{82} }
 
 func (m *NodeAddress) Reset()                    { *m = NodeAddress{} }
 func (*NodeAddress) ProtoMessage()               {}
-func (*NodeAddress) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{82} }
+func (*NodeAddress) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{83} }
 
 func (m *NodeAffinity) Reset()                    { *m = NodeAffinity{} }
 func (*NodeAffinity) ProtoMessage()               {}
-func (*NodeAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{83} }
+func (*NodeAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{84} }
 
 func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
 func (*NodeCondition) ProtoMessage()               {}
-func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{84} }
+func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{85} }
 
 func (m *NodeConfigSource) Reset()                    { *m = NodeConfigSource{} }
 func (*NodeConfigSource) ProtoMessage()               {}
-func (*NodeConfigSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{85} }
+func (*NodeConfigSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{86} }
 
 func (m *NodeConfigStatus) Reset()                    { *m = NodeConfigStatus{} }
 func (*NodeConfigStatus) ProtoMessage()               {}
-func (*NodeConfigStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{86} }
+func (*NodeConfigStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{87} }
 
 func (m *NodeDaemonEndpoints) Reset()                    { *m = NodeDaemonEndpoints{} }
 func (*NodeDaemonEndpoints) ProtoMessage()               {}
-func (*NodeDaemonEndpoints) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{87} }
+func (*NodeDaemonEndpoints) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{88} }
 
 func (m *NodeList) Reset()                    { *m = NodeList{} }
 func (*NodeList) ProtoMessage()               {}
-func (*NodeList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{88} }
+func (*NodeList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{89} }
 
 func (m *NodeProxyOptions) Reset()                    { *m = NodeProxyOptions{} }
 func (*NodeProxyOptions) ProtoMessage()               {}
-func (*NodeProxyOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{89} }
+func (*NodeProxyOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{90} }
 
 func (m *NodeResources) Reset()                    { *m = NodeResources{} }
 func (*NodeResources) ProtoMessage()               {}
-func (*NodeResources) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{90} }
+func (*NodeResources) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{91} }
 
 func (m *NodeSelector) Reset()                    { *m = NodeSelector{} }
 func (*NodeSelector) ProtoMessage()               {}
-func (*NodeSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{91} }
+func (*NodeSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{92} }
 
 func (m *NodeSelectorRequirement) Reset()      { *m = NodeSelectorRequirement{} }
 func (*NodeSelectorRequirement) ProtoMessage() {}
 func (*NodeSelectorRequirement) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{92}
+	return fileDescriptorGenerated, []int{93}
 }
 
 func (m *NodeSelectorTerm) Reset()                    { *m = NodeSelectorTerm{} }
 func (*NodeSelectorTerm) ProtoMessage()               {}
-func (*NodeSelectorTerm) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{93} }
+func (*NodeSelectorTerm) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{94} }
 
 func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
 func (*NodeSpec) ProtoMessage()               {}
-func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{94} }
+func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{95} }
 
 func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
 func (*NodeStatus) ProtoMessage()               {}
-func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{95} }
+func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{96} }
 
 func (m *NodeSystemInfo) Reset()                    { *m = NodeSystemInfo{} }
 func (*NodeSystemInfo) ProtoMessage()               {}
-func (*NodeSystemInfo) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{96} }
+func (*NodeSystemInfo) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{97} }
 
 func (m *ObjectFieldSelector) Reset()                    { *m = ObjectFieldSelector{} }
 func (*ObjectFieldSelector) ProtoMessage()               {}
-func (*ObjectFieldSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{97} }
+func (*ObjectFieldSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{98} }
 
 func (m *ObjectReference) Reset()                    { *m = ObjectReference{} }
 func (*ObjectReference) ProtoMessage()               {}
-func (*ObjectReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{98} }
+func (*ObjectReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{99} }
 
 func (m *PersistentVolume) Reset()                    { *m = PersistentVolume{} }
 func (*PersistentVolume) ProtoMessage()               {}
-func (*PersistentVolume) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{99} }
+func (*PersistentVolume) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{100} }
 
 func (m *PersistentVolumeClaim) Reset()                    { *m = PersistentVolumeClaim{} }
 func (*PersistentVolumeClaim) ProtoMessage()               {}
-func (*PersistentVolumeClaim) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{100} }
+func (*PersistentVolumeClaim) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{101} }
 
 func (m *PersistentVolumeClaimCondition) Reset()      { *m = PersistentVolumeClaimCondition{} }
 func (*PersistentVolumeClaimCondition) ProtoMessage() {}
 func (*PersistentVolumeClaimCondition) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{101}
+	return fileDescriptorGenerated, []int{102}
 }
 
 func (m *PersistentVolumeClaimList) Reset()      { *m = PersistentVolumeClaimList{} }
 func (*PersistentVolumeClaimList) ProtoMessage() {}
 func (*PersistentVolumeClaimList) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{102}
+	return fileDescriptorGenerated, []int{103}
 }
 
 func (m *PersistentVolumeClaimSpec) Reset()      { *m = PersistentVolumeClaimSpec{} }
 func (*PersistentVolumeClaimSpec) ProtoMessage() {}
 func (*PersistentVolumeClaimSpec) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{103}
+	return fileDescriptorGenerated, []int{104}
 }
 
 func (m *PersistentVolumeClaimStatus) Reset()      { *m = PersistentVolumeClaimStatus{} }
 func (*PersistentVolumeClaimStatus) ProtoMessage() {}
 func (*PersistentVolumeClaimStatus) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{104}
+	return fileDescriptorGenerated, []int{105}
 }
 
 func (m *PersistentVolumeClaimVolumeSource) Reset()      { *m = PersistentVolumeClaimVolumeSource{} }
 func (*PersistentVolumeClaimVolumeSource) ProtoMessage() {}
 func (*PersistentVolumeClaimVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{105}
+	return fileDescriptorGenerated, []int{106}
 }
 
 func (m *PersistentVolumeList) Reset()                    { *m = PersistentVolumeList{} }
 func (*PersistentVolumeList) ProtoMessage()               {}
-func (*PersistentVolumeList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{106} }
+func (*PersistentVolumeList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{107} }
 
 func (m *PersistentVolumeSource) Reset()      { *m = PersistentVolumeSource{} }
 func (*PersistentVolumeSource) ProtoMessage() {}
 func (*PersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{107}
+	return fileDescriptorGenerated, []int{108}
 }
 
 func (m *PersistentVolumeSpec) Reset()                    { *m = PersistentVolumeSpec{} }
 func (*PersistentVolumeSpec) ProtoMessage()               {}
-func (*PersistentVolumeSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{108} }
+func (*PersistentVolumeSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{109} }
 
 func (m *PersistentVolumeStatus) Reset()      { *m = PersistentVolumeStatus{} }
 func (*PersistentVolumeStatus) ProtoMessage() {}
 func (*PersistentVolumeStatus) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{109}
+	return fileDescriptorGenerated, []int{110}
 }
 
 func (m *PhotonPersistentDiskVolumeSource) Reset()      { *m = PhotonPersistentDiskVolumeSource{} }
 func (*PhotonPersistentDiskVolumeSource) ProtoMessage() {}
 func (*PhotonPersistentDiskVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{110}
+	return fileDescriptorGenerated, []int{111}
 }
 
 func (m *Pod) Reset()                    { *m = Pod{} }
 func (*Pod) ProtoMessage()               {}
-func (*Pod) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{111} }
+func (*Pod) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{112} }
 
 func (m *PodAffinity) Reset()                    { *m = PodAffinity{} }
 func (*PodAffinity) ProtoMessage()               {}
-func (*PodAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{112} }
+func (*PodAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{113} }
 
 func (m *PodAffinityTerm) Reset()                    { *m = PodAffinityTerm{} }
 func (*PodAffinityTerm) ProtoMessage()               {}
-func (*PodAffinityTerm) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{113} }
+func (*PodAffinityTerm) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{114} }
 
 func (m *PodAntiAffinity) Reset()                    { *m = PodAntiAffinity{} }
 func (*PodAntiAffinity) ProtoMessage()               {}
-func (*PodAntiAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{114} }
+func (*PodAntiAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{115} }
 
 func (m *PodAttachOptions) Reset()                    { *m = PodAttachOptions{} }
 func (*PodAttachOptions) ProtoMessage()               {}
-func (*PodAttachOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{115} }
+func (*PodAttachOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{116} }
 
 func (m *PodCondition) Reset()                    { *m = PodCondition{} }
 func (*PodCondition) ProtoMessage()               {}
-func (*PodCondition) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{116} }
+func (*PodCondition) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{117} }
 
 func (m *PodDNSConfig) Reset()                    { *m = PodDNSConfig{} }
 func (*PodDNSConfig) ProtoMessage()               {}
-func (*PodDNSConfig) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{117} }
+func (*PodDNSConfig) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{118} }
 
 func (m *PodDNSConfigOption) Reset()                    { *m = PodDNSConfigOption{} }
 func (*PodDNSConfigOption) ProtoMessage()               {}
-func (*PodDNSConfigOption) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{118} }
+func (*PodDNSConfigOption) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{119} }
 
 func (m *PodExecOptions) Reset()                    { *m = PodExecOptions{} }
 func (*PodExecOptions) ProtoMessage()               {}
-func (*PodExecOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{119} }
+func (*PodExecOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{120} }
 
 func (m *PodList) Reset()                    { *m = PodList{} }
 func (*PodList) ProtoMessage()               {}
-func (*PodList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{120} }
+func (*PodList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{121} }
 
 func (m *PodLogOptions) Reset()                    { *m = PodLogOptions{} }
 func (*PodLogOptions) ProtoMessage()               {}
-func (*PodLogOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{121} }
+func (*PodLogOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{122} }
 
 func (m *PodPortForwardOptions) Reset()                    { *m = PodPortForwardOptions{} }
 func (*PodPortForwardOptions) ProtoMessage()               {}
-func (*PodPortForwardOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{122} }
+func (*PodPortForwardOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{123} }
 
 func (m *PodProxyOptions) Reset()                    { *m = PodProxyOptions{} }
 func (*PodProxyOptions) ProtoMessage()               {}
-func (*PodProxyOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{123} }
+func (*PodProxyOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{124} }
 
 func (m *PodReadinessGate) Reset()                    { *m = PodReadinessGate{} }
 func (*PodReadinessGate) ProtoMessage()               {}
-func (*PodReadinessGate) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{124} }
+func (*PodReadinessGate) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{125} }
 
 func (m *PodSecurityContext) Reset()                    { *m = PodSecurityContext{} }
 func (*PodSecurityContext) ProtoMessage()               {}
-func (*PodSecurityContext) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{125} }
+func (*PodSecurityContext) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{126} }
 
 func (m *PodSignature) Reset()                    { *m = PodSignature{} }
 func (*PodSignature) ProtoMessage()               {}
-func (*PodSignature) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{126} }
+func (*PodSignature) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{127} }
 
 func (m *PodSpec) Reset()                    { *m = PodSpec{} }
 func (*PodSpec) ProtoMessage()               {}
-func (*PodSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{127} }
+func (*PodSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{128} }
 
 func (m *PodStatus) Reset()                    { *m = PodStatus{} }
 func (*PodStatus) ProtoMessage()               {}
-func (*PodStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{128} }
+func (*PodStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{129} }
 
 func (m *PodStatusResult) Reset()                    { *m = PodStatusResult{} }
 func (*PodStatusResult) ProtoMessage()               {}
-func (*PodStatusResult) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{129} }
+func (*PodStatusResult) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{130} }
 
 func (m *PodTemplate) Reset()                    { *m = PodTemplate{} }
 func (*PodTemplate) ProtoMessage()               {}
-func (*PodTemplate) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{130} }
+func (*PodTemplate) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{131} }
 
 func (m *PodTemplateList) Reset()                    { *m = PodTemplateList{} }
 func (*PodTemplateList) ProtoMessage()               {}
-func (*PodTemplateList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{131} }
+func (*PodTemplateList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{132} }
 
 func (m *PodTemplateSpec) Reset()                    { *m = PodTemplateSpec{} }
 func (*PodTemplateSpec) ProtoMessage()               {}
-func (*PodTemplateSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{132} }
+func (*PodTemplateSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{133} }
 
 func (m *PortworxVolumeSource) Reset()                    { *m = PortworxVolumeSource{} }
 func (*PortworxVolumeSource) ProtoMessage()               {}
-func (*PortworxVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{133} }
+func (*PortworxVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{134} }
 
 func (m *Preconditions) Reset()                    { *m = Preconditions{} }
 func (*Preconditions) ProtoMessage()               {}
-func (*Preconditions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{134} }
+func (*Preconditions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{135} }
 
 func (m *PreferAvoidPodsEntry) Reset()                    { *m = PreferAvoidPodsEntry{} }
 func (*PreferAvoidPodsEntry) ProtoMessage()               {}
-func (*PreferAvoidPodsEntry) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{135} }
+func (*PreferAvoidPodsEntry) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{136} }
 
 func (m *PreferredSchedulingTerm) Reset()      { *m = PreferredSchedulingTerm{} }
 func (*PreferredSchedulingTerm) ProtoMessage() {}
 func (*PreferredSchedulingTerm) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{136}
+	return fileDescriptorGenerated, []int{137}
 }
 
 func (m *Probe) Reset()                    { *m = Probe{} }
 func (*Probe) ProtoMessage()               {}
-func (*Probe) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{137} }
+func (*Probe) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{138} }
 
 func (m *ProjectedVolumeSource) Reset()                    { *m = ProjectedVolumeSource{} }
 func (*ProjectedVolumeSource) ProtoMessage()               {}
-func (*ProjectedVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{138} }
+func (*ProjectedVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{139} }
 
 func (m *QuobyteVolumeSource) Reset()                    { *m = QuobyteVolumeSource{} }
 func (*QuobyteVolumeSource) ProtoMessage()               {}
-func (*QuobyteVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{139} }
+func (*QuobyteVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{140} }
 
 func (m *RBDPersistentVolumeSource) Reset()      { *m = RBDPersistentVolumeSource{} }
 func (*RBDPersistentVolumeSource) ProtoMessage() {}
 func (*RBDPersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{140}
+	return fileDescriptorGenerated, []int{141}
 }
 
 func (m *RBDVolumeSource) Reset()                    { *m = RBDVolumeSource{} }
 func (*RBDVolumeSource) ProtoMessage()               {}
-func (*RBDVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{141} }
+func (*RBDVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{142} }
 
 func (m *RangeAllocation) Reset()                    { *m = RangeAllocation{} }
 func (*RangeAllocation) ProtoMessage()               {}
-func (*RangeAllocation) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{142} }
+func (*RangeAllocation) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{143} }
 
 func (m *ReplicationController) Reset()                    { *m = ReplicationController{} }
 func (*ReplicationController) ProtoMessage()               {}
-func (*ReplicationController) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{143} }
+func (*ReplicationController) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{144} }
 
 func (m *ReplicationControllerCondition) Reset()      { *m = ReplicationControllerCondition{} }
 func (*ReplicationControllerCondition) ProtoMessage() {}
 func (*ReplicationControllerCondition) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{144}
+	return fileDescriptorGenerated, []int{145}
 }
 
 func (m *ReplicationControllerList) Reset()      { *m = ReplicationControllerList{} }
 func (*ReplicationControllerList) ProtoMessage() {}
 func (*ReplicationControllerList) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{145}
+	return fileDescriptorGenerated, []int{146}
 }
 
 func (m *ReplicationControllerSpec) Reset()      { *m = ReplicationControllerSpec{} }
 func (*ReplicationControllerSpec) ProtoMessage() {}
 func (*ReplicationControllerSpec) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{146}
+	return fileDescriptorGenerated, []int{147}
 }
 
 func (m *ReplicationControllerStatus) Reset()      { *m = ReplicationControllerStatus{} }
 func (*ReplicationControllerStatus) ProtoMessage() {}
 func (*ReplicationControllerStatus) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{147}
+	return fileDescriptorGenerated, []int{148}
 }
 
 func (m *ResourceFieldSelector) Reset()                    { *m = ResourceFieldSelector{} }
 func (*ResourceFieldSelector) ProtoMessage()               {}
-func (*ResourceFieldSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{148} }
+func (*ResourceFieldSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{149} }
 
 func (m *ResourceQuota) Reset()                    { *m = ResourceQuota{} }
 func (*ResourceQuota) ProtoMessage()               {}
-func (*ResourceQuota) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{149} }
+func (*ResourceQuota) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{150} }
 
 func (m *ResourceQuotaList) Reset()                    { *m = ResourceQuotaList{} }
 func (*ResourceQuotaList) ProtoMessage()               {}
-func (*ResourceQuotaList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{150} }
+func (*ResourceQuotaList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{151} }
 
 func (m *ResourceQuotaSpec) Reset()                    { *m = ResourceQuotaSpec{} }
 func (*ResourceQuotaSpec) ProtoMessage()               {}
-func (*ResourceQuotaSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{151} }
+func (*ResourceQuotaSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{152} }
 
 func (m *ResourceQuotaStatus) Reset()                    { *m = ResourceQuotaStatus{} }
 func (*ResourceQuotaStatus) ProtoMessage()               {}
-func (*ResourceQuotaStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{152} }
+func (*ResourceQuotaStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{153} }
 
 func (m *ResourceRequirements) Reset()                    { *m = ResourceRequirements{} }
 func (*ResourceRequirements) ProtoMessage()               {}
-func (*ResourceRequirements) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{153} }
+func (*ResourceRequirements) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{154} }
 
 func (m *SELinuxOptions) Reset()                    { *m = SELinuxOptions{} }
 func (*SELinuxOptions) ProtoMessage()               {}
-func (*SELinuxOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{154} }
+func (*SELinuxOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{155} }
 
 func (m *ScaleIOPersistentVolumeSource) Reset()      { *m = ScaleIOPersistentVolumeSource{} }
 func (*ScaleIOPersistentVolumeSource) ProtoMessage() {}
 func (*ScaleIOPersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{155}
+	return fileDescriptorGenerated, []int{156}
 }
 
 func (m *ScaleIOVolumeSource) Reset()                    { *m = ScaleIOVolumeSource{} }
 func (*ScaleIOVolumeSource) ProtoMessage()               {}
-func (*ScaleIOVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{156} }
+func (*ScaleIOVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{157} }
 
 func (m *ScopeSelector) Reset()                    { *m = ScopeSelector{} }
 func (*ScopeSelector) ProtoMessage()               {}
-func (*ScopeSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{157} }
+func (*ScopeSelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{158} }
 
 func (m *ScopedResourceSelectorRequirement) Reset()      { *m = ScopedResourceSelectorRequirement{} }
 func (*ScopedResourceSelectorRequirement) ProtoMessage() {}
 func (*ScopedResourceSelectorRequirement) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{158}
+	return fileDescriptorGenerated, []int{159}
 }
 
 func (m *Secret) Reset()                    { *m = Secret{} }
 func (*Secret) ProtoMessage()               {}
-func (*Secret) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{159} }
+func (*Secret) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{160} }
 
 func (m *SecretEnvSource) Reset()                    { *m = SecretEnvSource{} }
 func (*SecretEnvSource) ProtoMessage()               {}
-func (*SecretEnvSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{160} }
+func (*SecretEnvSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{161} }
 
 func (m *SecretKeySelector) Reset()                    { *m = SecretKeySelector{} }
 func (*SecretKeySelector) ProtoMessage()               {}
-func (*SecretKeySelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{161} }
+func (*SecretKeySelector) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{162} }
 
 func (m *SecretList) Reset()                    { *m = SecretList{} }
 func (*SecretList) ProtoMessage()               {}
-func (*SecretList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{162} }
+func (*SecretList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{163} }
 
 func (m *SecretProjection) Reset()                    { *m = SecretProjection{} }
 func (*SecretProjection) ProtoMessage()               {}
-func (*SecretProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{163} }
+func (*SecretProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{164} }
 
 func (m *SecretReference) Reset()                    { *m = SecretReference{} }
 func (*SecretReference) ProtoMessage()               {}
-func (*SecretReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{164} }
+func (*SecretReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{165} }
 
 func (m *SecretVolumeSource) Reset()                    { *m = SecretVolumeSource{} }
 func (*SecretVolumeSource) ProtoMessage()               {}
-func (*SecretVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{165} }
+func (*SecretVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{166} }
 
 func (m *SecurityContext) Reset()                    { *m = SecurityContext{} }
 func (*SecurityContext) ProtoMessage()               {}
-func (*SecurityContext) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{166} }
+func (*SecurityContext) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{167} }
 
 func (m *SerializedReference) Reset()                    { *m = SerializedReference{} }
 func (*SerializedReference) ProtoMessage()               {}
-func (*SerializedReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{167} }
+func (*SerializedReference) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{168} }
 
 func (m *Service) Reset()                    { *m = Service{} }
 func (*Service) ProtoMessage()               {}
-func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{168} }
+func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{169} }
 
 func (m *ServiceAccount) Reset()                    { *m = ServiceAccount{} }
 func (*ServiceAccount) ProtoMessage()               {}
-func (*ServiceAccount) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{169} }
+func (*ServiceAccount) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{170} }
 
 func (m *ServiceAccountList) Reset()                    { *m = ServiceAccountList{} }
 func (*ServiceAccountList) ProtoMessage()               {}
-func (*ServiceAccountList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{170} }
+func (*ServiceAccountList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{171} }
 
 func (m *ServiceAccountTokenProjection) Reset()      { *m = ServiceAccountTokenProjection{} }
 func (*ServiceAccountTokenProjection) ProtoMessage() {}
 func (*ServiceAccountTokenProjection) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{171}
+	return fileDescriptorGenerated, []int{172}
 }
 
 func (m *ServiceList) Reset()                    { *m = ServiceList{} }
 func (*ServiceList) ProtoMessage()               {}
-func (*ServiceList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{172} }
+func (*ServiceList) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{173} }
 
 func (m *ServicePort) Reset()                    { *m = ServicePort{} }
 func (*ServicePort) ProtoMessage()               {}
-func (*ServicePort) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{173} }
+func (*ServicePort) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{174} }
 
 func (m *ServiceProxyOptions) Reset()                    { *m = ServiceProxyOptions{} }
 func (*ServiceProxyOptions) ProtoMessage()               {}
-func (*ServiceProxyOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{174} }
+func (*ServiceProxyOptions) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{175} }
 
 func (m *ServiceSpec) Reset()                    { *m = ServiceSpec{} }
 func (*ServiceSpec) ProtoMessage()               {}
-func (*ServiceSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{175} }
+func (*ServiceSpec) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{176} }
 
 func (m *ServiceStatus) Reset()                    { *m = ServiceStatus{} }
 func (*ServiceStatus) ProtoMessage()               {}
-func (*ServiceStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{176} }
+func (*ServiceStatus) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{177} }
 
 func (m *SessionAffinityConfig) Reset()                    { *m = SessionAffinityConfig{} }
 func (*SessionAffinityConfig) ProtoMessage()               {}
-func (*SessionAffinityConfig) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{177} }
+func (*SessionAffinityConfig) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{178} }
 
 func (m *StorageOSPersistentVolumeSource) Reset()      { *m = StorageOSPersistentVolumeSource{} }
 func (*StorageOSPersistentVolumeSource) ProtoMessage() {}
 func (*StorageOSPersistentVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{178}
+	return fileDescriptorGenerated, []int{179}
 }
 
 func (m *StorageOSVolumeSource) Reset()                    { *m = StorageOSVolumeSource{} }
 func (*StorageOSVolumeSource) ProtoMessage()               {}
-func (*StorageOSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{179} }
+func (*StorageOSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{180} }
 
 func (m *Sysctl) Reset()                    { *m = Sysctl{} }
 func (*Sysctl) ProtoMessage()               {}
-func (*Sysctl) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{180} }
+func (*Sysctl) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{181} }
 
 func (m *TCPSocketAction) Reset()                    { *m = TCPSocketAction{} }
 func (*TCPSocketAction) ProtoMessage()               {}
-func (*TCPSocketAction) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{181} }
+func (*TCPSocketAction) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{182} }
 
 func (m *Taint) Reset()                    { *m = Taint{} }
 func (*Taint) ProtoMessage()               {}
-func (*Taint) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{182} }
+func (*Taint) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{183} }
 
 func (m *Toleration) Reset()                    { *m = Toleration{} }
 func (*Toleration) ProtoMessage()               {}
-func (*Toleration) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{183} }
+func (*Toleration) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{184} }
 
 func (m *TopologySelectorLabelRequirement) Reset()      { *m = TopologySelectorLabelRequirement{} }
 func (*TopologySelectorLabelRequirement) ProtoMessage() {}
 func (*TopologySelectorLabelRequirement) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{184}
+	return fileDescriptorGenerated, []int{185}
 }
 
 func (m *TopologySelectorTerm) Reset()                    { *m = TopologySelectorTerm{} }
 func (*TopologySelectorTerm) ProtoMessage()               {}
-func (*TopologySelectorTerm) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{185} }
+func (*TopologySelectorTerm) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{186} }
 
 func (m *Volume) Reset()                    { *m = Volume{} }
 func (*Volume) ProtoMessage()               {}
-func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{186} }
+func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{187} }
 
 func (m *VolumeDevice) Reset()                    { *m = VolumeDevice{} }
 func (*VolumeDevice) ProtoMessage()               {}
-func (*VolumeDevice) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{187} }
+func (*VolumeDevice) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{188} }
 
 func (m *VolumeMount) Reset()                    { *m = VolumeMount{} }
 func (*VolumeMount) ProtoMessage()               {}
-func (*VolumeMount) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{188} }
+func (*VolumeMount) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{189} }
 
 func (m *VolumeNodeAffinity) Reset()                    { *m = VolumeNodeAffinity{} }
 func (*VolumeNodeAffinity) ProtoMessage()               {}
-func (*VolumeNodeAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{189} }
+func (*VolumeNodeAffinity) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{190} }
 
 func (m *VolumeProjection) Reset()                    { *m = VolumeProjection{} }
 func (*VolumeProjection) ProtoMessage()               {}
-func (*VolumeProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{190} }
+func (*VolumeProjection) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{191} }
 
 func (m *VolumeSource) Reset()                    { *m = VolumeSource{} }
 func (*VolumeSource) ProtoMessage()               {}
-func (*VolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{191} }
+func (*VolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorGenerated, []int{192} }
 
 func (m *VsphereVirtualDiskVolumeSource) Reset()      { *m = VsphereVirtualDiskVolumeSource{} }
 func (*VsphereVirtualDiskVolumeSource) ProtoMessage() {}
 func (*VsphereVirtualDiskVolumeSource) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{192}
+	return fileDescriptorGenerated, []int{193}
 }
 
 func (m *WeightedPodAffinityTerm) Reset()      { *m = WeightedPodAffinityTerm{} }
 func (*WeightedPodAffinityTerm) ProtoMessage() {}
 func (*WeightedPodAffinityTerm) Descriptor() ([]byte, []int) {
-	return fileDescriptorGenerated, []int{193}
+	return fileDescriptorGenerated, []int{194}
 }
 
 func init() {
@@ -1103,6 +1110,7 @@ func init() {
 	proto.RegisterType((*Binding)(nil), "k8s.io.api.core.v1.Binding")
 	proto.RegisterType((*CSIPersistentVolumeSource)(nil), "k8s.io.api.core.v1.CSIPersistentVolumeSource")
 	proto.RegisterType((*Capabilities)(nil), "k8s.io.api.core.v1.Capabilities")
+	proto.RegisterType((*CascadeDiskVolumeSource)(nil), "k8s.io.api.core.v1.CascadeDiskVolumeSource")
 	proto.RegisterType((*CephFSPersistentVolumeSource)(nil), "k8s.io.api.core.v1.CephFSPersistentVolumeSource")
 	proto.RegisterType((*CephFSVolumeSource)(nil), "k8s.io.api.core.v1.CephFSVolumeSource")
 	proto.RegisterType((*CinderPersistentVolumeSource)(nil), "k8s.io.api.core.v1.CinderPersistentVolumeSource")
@@ -1729,6 +1737,32 @@ func (m *Capabilities) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
+func (m *CascadeDiskVolumeSource) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *CascadeDiskVolumeSource) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DiskID)))
+	i += copy(dAtA[i:], m.DiskID)
+	dAtA[i] = 0x12
+	i++
+	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FSType)))
+	i += copy(dAtA[i:], m.FSType)
+	return i, nil
+}
+
 func (m *CephFSPersistentVolumeSource) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
@@ -6404,13 +6438,13 @@ func (m *PersistentVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		}
 		i += n126
 	}
-	if m.AzureDisk != nil {
+	if m.CascadeDisk != nil {
 		dAtA[i] = 0x82
 		i++
 		dAtA[i] = 0x1
 		i++
-		i = encodeVarintGenerated(dAtA, i, uint64(m.AzureDisk.Size()))
-		n127, err := m.AzureDisk.MarshalTo(dAtA[i:])
+		i = encodeVarintGenerated(dAtA, i, uint64(m.CascadeDisk.Size()))
+		n127, err := m.CascadeDisk.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
@@ -6488,6 +6522,18 @@ func (m *PersistentVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		}
 		i += n133
 	}
+	if m.AzureDisk != nil {
+		dAtA[i] = 0xba
+		i++
+		dAtA[i] = 0x1
+		i++
+		i = encodeVarintGenerated(dAtA, i, uint64(m.AzureDisk.Size()))
+		n134, err := m.AzureDisk.MarshalTo(dAtA[i:])
+		if err != nil {
+			return 0, err
+		}
+		i += n134
+	}
 	return i, nil
 }
 
@@ -6530,21 +6576,21 @@ func (m *PersistentVolumeSpec) MarshalTo(dAtA []byte) (int, error) {
 			dAtA[i] = 0x12
 			i++
 			i = encodeVarintGenerated(dAtA, i, uint64((&v).Size()))
-			n134, err := (&v).MarshalTo(dAtA[i:])
+			n135, err := (&v).MarshalTo(dAtA[i:])
 			if err != nil {
 				return 0, err
 			}
-			i += n134
+			i += n135
 		}
 	}
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.PersistentVolumeSource.Size()))
-	n135, err := m.PersistentVolumeSource.MarshalTo(dAtA[i:])
+	n136, err := m.PersistentVolumeSource.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n135
+	i += n136
 	if len(m.AccessModes) > 0 {
 		for _, s := range m.AccessModes {
 			dAtA[i] = 0x1a
@@ -6564,11 +6610,11 @@ func (m *PersistentVolumeSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x22
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ClaimRef.Size()))
-		n136, err := m.ClaimRef.MarshalTo(dAtA[i:])
+		n137, err := m.ClaimRef.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n136
+		i += n137
 	}
 	dAtA[i] = 0x2a
 	i++
@@ -6603,11 +6649,11 @@ func (m *PersistentVolumeSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x4a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.NodeAffinity.Size()))
-		n137, err := m.NodeAffinity.MarshalTo(dAtA[i:])
+		n138, err := m.NodeAffinity.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n137
+		i += n138
 	}
 	return i, nil
 }
@@ -6686,27 +6732,27 @@ func (m *Pod) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n138, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n139, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n138
+	i += n139
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Spec.Size()))
-	n139, err := m.Spec.MarshalTo(dAtA[i:])
+	n140, err := m.Spec.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n139
+	i += n140
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Status.Size()))
-	n140, err := m.Status.MarshalTo(dAtA[i:])
+	n141, err := m.Status.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n140
+	i += n141
 	return i, nil
 }
 
@@ -6771,11 +6817,11 @@ func (m *PodAffinityTerm) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.LabelSelector.Size()))
-		n141, err := m.LabelSelector.MarshalTo(dAtA[i:])
+		n142, err := m.LabelSelector.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n141
+		i += n142
 	}
 	if len(m.Namespaces) > 0 {
 		for _, s := range m.Namespaces {
@@ -6921,19 +6967,19 @@ func (m *PodCondition) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.LastProbeTime.Size()))
-	n142, err := m.LastProbeTime.MarshalTo(dAtA[i:])
+	n143, err := m.LastProbeTime.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n142
+	i += n143
 	dAtA[i] = 0x22
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.LastTransitionTime.Size()))
-	n143, err := m.LastTransitionTime.MarshalTo(dAtA[i:])
+	n144, err := m.LastTransitionTime.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n143
+	i += n144
 	dAtA[i] = 0x2a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
@@ -7120,11 +7166,11 @@ func (m *PodList) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ListMeta.Size()))
-	n144, err := m.ListMeta.MarshalTo(dAtA[i:])
+	n145, err := m.ListMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n144
+	i += n145
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -7184,11 +7230,11 @@ func (m *PodLogOptions) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x2a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SinceTime.Size()))
-		n145, err := m.SinceTime.MarshalTo(dAtA[i:])
+		n146, err := m.SinceTime.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n145
+		i += n146
 	}
 	dAtA[i] = 0x30
 	i++
@@ -7299,11 +7345,11 @@ func (m *PodSecurityContext) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SELinuxOptions.Size()))
-		n146, err := m.SELinuxOptions.MarshalTo(dAtA[i:])
+		n147, err := m.SELinuxOptions.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n146
+		i += n147
 	}
 	if m.RunAsUser != nil {
 		dAtA[i] = 0x10
@@ -7371,11 +7417,11 @@ func (m *PodSignature) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.PodController.Size()))
-		n147, err := m.PodController.MarshalTo(dAtA[i:])
+		n148, err := m.PodController.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n147
+		i += n148
 	}
 	return i, nil
 }
@@ -7499,11 +7545,11 @@ func (m *PodSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x72
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SecurityContext.Size()))
-		n148, err := m.SecurityContext.MarshalTo(dAtA[i:])
+		n149, err := m.SecurityContext.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n148
+		i += n149
 	}
 	if len(m.ImagePullSecrets) > 0 {
 		for _, msg := range m.ImagePullSecrets {
@@ -7535,11 +7581,11 @@ func (m *PodSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Affinity.Size()))
-		n149, err := m.Affinity.MarshalTo(dAtA[i:])
+		n150, err := m.Affinity.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n149
+		i += n150
 	}
 	dAtA[i] = 0x9a
 	i++
@@ -7620,11 +7666,11 @@ func (m *PodSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.DNSConfig.Size()))
-		n150, err := m.DNSConfig.MarshalTo(dAtA[i:])
+		n151, err := m.DNSConfig.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n150
+		i += n151
 	}
 	if m.ShareProcessNamespace != nil {
 		dAtA[i] = 0xd8
@@ -7706,11 +7752,11 @@ func (m *PodStatus) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x3a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.StartTime.Size()))
-		n151, err := m.StartTime.MarshalTo(dAtA[i:])
+		n152, err := m.StartTime.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n151
+		i += n152
 	}
 	if len(m.ContainerStatuses) > 0 {
 		for _, msg := range m.ContainerStatuses {
@@ -7765,19 +7811,19 @@ func (m *PodStatusResult) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n152, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n153, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n152
+	i += n153
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Status.Size()))
-	n153, err := m.Status.MarshalTo(dAtA[i:])
+	n154, err := m.Status.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n153
+	i += n154
 	return i, nil
 }
 
@@ -7799,19 +7845,19 @@ func (m *PodTemplate) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n154, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n155, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n154
+	i += n155
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Template.Size()))
-	n155, err := m.Template.MarshalTo(dAtA[i:])
+	n156, err := m.Template.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n155
+	i += n156
 	return i, nil
 }
 
@@ -7833,11 +7879,11 @@ func (m *PodTemplateList) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ListMeta.Size()))
-	n156, err := m.ListMeta.MarshalTo(dAtA[i:])
+	n157, err := m.ListMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n156
+	i += n157
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -7871,19 +7917,19 @@ func (m *PodTemplateSpec) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n157, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n158, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n157
+	i += n158
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Spec.Size()))
-	n158, err := m.Spec.MarshalTo(dAtA[i:])
+	n159, err := m.Spec.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n158
+	i += n159
 	return i, nil
 }
 
@@ -7963,19 +8009,19 @@ func (m *PreferAvoidPodsEntry) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.PodSignature.Size()))
-	n159, err := m.PodSignature.MarshalTo(dAtA[i:])
+	n160, err := m.PodSignature.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n159
+	i += n160
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.EvictionTime.Size()))
-	n160, err := m.EvictionTime.MarshalTo(dAtA[i:])
+	n161, err := m.EvictionTime.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n160
+	i += n161
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
@@ -8008,11 +8054,11 @@ func (m *PreferredSchedulingTerm) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Preference.Size()))
-	n161, err := m.Preference.MarshalTo(dAtA[i:])
+	n162, err := m.Preference.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n161
+	i += n162
 	return i, nil
 }
 
@@ -8034,11 +8080,11 @@ func (m *Probe) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Handler.Size()))
-	n162, err := m.Handler.MarshalTo(dAtA[i:])
+	n163, err := m.Handler.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n162
+	i += n163
 	dAtA[i] = 0x10
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.InitialDelaySeconds))
@@ -8188,11 +8234,11 @@ func (m *RBDPersistentVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x3a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SecretRef.Size()))
-		n163, err := m.SecretRef.MarshalTo(dAtA[i:])
+		n164, err := m.SecretRef.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n163
+		i += n164
 	}
 	dAtA[i] = 0x40
 	i++
@@ -8259,11 +8305,11 @@ func (m *RBDVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x3a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SecretRef.Size()))
-		n164, err := m.SecretRef.MarshalTo(dAtA[i:])
+		n165, err := m.SecretRef.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n164
+		i += n165
 	}
 	dAtA[i] = 0x40
 	i++
@@ -8294,11 +8340,11 @@ func (m *RangeAllocation) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n165, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n166, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n165
+	i += n166
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Range)))
@@ -8330,27 +8376,27 @@ func (m *ReplicationController) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n166, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n167, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n166
+	i += n167
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Spec.Size()))
-	n167, err := m.Spec.MarshalTo(dAtA[i:])
+	n168, err := m.Spec.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n167
+	i += n168
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Status.Size()))
-	n168, err := m.Status.MarshalTo(dAtA[i:])
+	n169, err := m.Status.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n168
+	i += n169
 	return i, nil
 }
 
@@ -8380,11 +8426,11 @@ func (m *ReplicationControllerCondition) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.LastTransitionTime.Size()))
-	n169, err := m.LastTransitionTime.MarshalTo(dAtA[i:])
+	n170, err := m.LastTransitionTime.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n169
+	i += n170
 	dAtA[i] = 0x22
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
@@ -8414,11 +8460,11 @@ func (m *ReplicationControllerList) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ListMeta.Size()))
-	n170, err := m.ListMeta.MarshalTo(dAtA[i:])
+	n171, err := m.ListMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n170
+	i += n171
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -8480,11 +8526,11 @@ func (m *ReplicationControllerSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Template.Size()))
-		n171, err := m.Template.MarshalTo(dAtA[i:])
+		n172, err := m.Template.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n171
+		i += n172
 	}
 	dAtA[i] = 0x20
 	i++
@@ -8563,11 +8609,11 @@ func (m *ResourceFieldSelector) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Divisor.Size()))
-	n172, err := m.Divisor.MarshalTo(dAtA[i:])
+	n173, err := m.Divisor.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n172
+	i += n173
 	return i, nil
 }
 
@@ -8589,27 +8635,27 @@ func (m *ResourceQuota) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n173, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n174, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n173
+	i += n174
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Spec.Size()))
-	n174, err := m.Spec.MarshalTo(dAtA[i:])
+	n175, err := m.Spec.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n174
+	i += n175
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Status.Size()))
-	n175, err := m.Status.MarshalTo(dAtA[i:])
+	n176, err := m.Status.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n175
+	i += n176
 	return i, nil
 }
 
@@ -8631,11 +8677,11 @@ func (m *ResourceQuotaList) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ListMeta.Size()))
-	n176, err := m.ListMeta.MarshalTo(dAtA[i:])
+	n177, err := m.ListMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n176
+	i += n177
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -8690,11 +8736,11 @@ func (m *ResourceQuotaSpec) MarshalTo(dAtA []byte) (int, error) {
 			dAtA[i] = 0x12
 			i++
 			i = encodeVarintGenerated(dAtA, i, uint64((&v).Size()))
-			n177, err := (&v).MarshalTo(dAtA[i:])
+			n178, err := (&v).MarshalTo(dAtA[i:])
 			if err != nil {
 				return 0, err
 			}
-			i += n177
+			i += n178
 		}
 	}
 	if len(m.Scopes) > 0 {
@@ -8716,11 +8762,11 @@ func (m *ResourceQuotaSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ScopeSelector.Size()))
-		n178, err := m.ScopeSelector.MarshalTo(dAtA[i:])
+		n179, err := m.ScopeSelector.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n178
+		i += n179
 	}
 	return i, nil
 }
@@ -8764,11 +8810,11 @@ func (m *ResourceQuotaStatus) MarshalTo(dAtA []byte) (int, error) {
 			dAtA[i] = 0x12
 			i++
 			i = encodeVarintGenerated(dAtA, i, uint64((&v).Size()))
-			n179, err := (&v).MarshalTo(dAtA[i:])
+			n180, err := (&v).MarshalTo(dAtA[i:])
 			if err != nil {
 				return 0, err
 			}
-			i += n179
+			i += n180
 		}
 	}
 	if len(m.Used) > 0 {
@@ -8795,11 +8841,11 @@ func (m *ResourceQuotaStatus) MarshalTo(dAtA []byte) (int, error) {
 			dAtA[i] = 0x12
 			i++
 			i = encodeVarintGenerated(dAtA, i, uint64((&v).Size()))
-			n180, err := (&v).MarshalTo(dAtA[i:])
+			n181, err := (&v).MarshalTo(dAtA[i:])
 			if err != nil {
 				return 0, err
 			}
-			i += n180
+			i += n181
 		}
 	}
 	return i, nil
@@ -8844,11 +8890,11 @@ func (m *ResourceRequirements) MarshalTo(dAtA []byte) (int, error) {
 			dAtA[i] = 0x12
 			i++
 			i = encodeVarintGenerated(dAtA, i, uint64((&v).Size()))
-			n181, err := (&v).MarshalTo(dAtA[i:])
+			n182, err := (&v).MarshalTo(dAtA[i:])
 			if err != nil {
 				return 0, err
 			}
-			i += n181
+			i += n182
 		}
 	}
 	if len(m.Requests) > 0 {
@@ -8875,11 +8921,11 @@ func (m *ResourceRequirements) MarshalTo(dAtA []byte) (int, error) {
 			dAtA[i] = 0x12
 			i++
 			i = encodeVarintGenerated(dAtA, i, uint64((&v).Size()))
-			n182, err := (&v).MarshalTo(dAtA[i:])
+			n183, err := (&v).MarshalTo(dAtA[i:])
 			if err != nil {
 				return 0, err
 			}
-			i += n182
+			i += n183
 		}
 	}
 	return i, nil
@@ -8946,11 +8992,11 @@ func (m *ScaleIOPersistentVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SecretRef.Size()))
-		n183, err := m.SecretRef.MarshalTo(dAtA[i:])
+		n184, err := m.SecretRef.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n183
+		i += n184
 	}
 	dAtA[i] = 0x20
 	i++
@@ -9018,11 +9064,11 @@ func (m *ScaleIOVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SecretRef.Size()))
-		n184, err := m.SecretRef.MarshalTo(dAtA[i:])
+		n185, err := m.SecretRef.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n184
+		i += n185
 	}
 	dAtA[i] = 0x20
 	i++
@@ -9152,11 +9198,11 @@ func (m *Secret) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n185, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n186, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n185
+	i += n186
 	if len(m.Data) > 0 {
 		keysForData := make([]string, 0, len(m.Data))
 		for k := range m.Data {
@@ -9232,11 +9278,11 @@ func (m *SecretEnvSource) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.LocalObjectReference.Size()))
-	n186, err := m.LocalObjectReference.MarshalTo(dAtA[i:])
+	n187, err := m.LocalObjectReference.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n186
+	i += n187
 	if m.Optional != nil {
 		dAtA[i] = 0x10
 		i++
@@ -9268,11 +9314,11 @@ func (m *SecretKeySelector) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.LocalObjectReference.Size()))
-	n187, err := m.LocalObjectReference.MarshalTo(dAtA[i:])
+	n188, err := m.LocalObjectReference.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n187
+	i += n188
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Key)))
@@ -9308,11 +9354,11 @@ func (m *SecretList) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ListMeta.Size()))
-	n188, err := m.ListMeta.MarshalTo(dAtA[i:])
+	n189, err := m.ListMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n188
+	i += n189
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -9346,11 +9392,11 @@ func (m *SecretProjection) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.LocalObjectReference.Size()))
-	n189, err := m.LocalObjectReference.MarshalTo(dAtA[i:])
+	n190, err := m.LocalObjectReference.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n189
+	i += n190
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -9470,11 +9516,11 @@ func (m *SecurityContext) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Capabilities.Size()))
-		n190, err := m.Capabilities.MarshalTo(dAtA[i:])
+		n191, err := m.Capabilities.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n190
+		i += n191
 	}
 	if m.Privileged != nil {
 		dAtA[i] = 0x10
@@ -9490,11 +9536,11 @@ func (m *SecurityContext) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SELinuxOptions.Size()))
-		n191, err := m.SELinuxOptions.MarshalTo(dAtA[i:])
+		n192, err := m.SELinuxOptions.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n191
+		i += n192
 	}
 	if m.RunAsUser != nil {
 		dAtA[i] = 0x20
@@ -9557,11 +9603,11 @@ func (m *SerializedReference) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Reference.Size()))
-	n192, err := m.Reference.MarshalTo(dAtA[i:])
+	n193, err := m.Reference.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n192
+	i += n193
 	return i, nil
 }
 
@@ -9583,27 +9629,27 @@ func (m *Service) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n193, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n194, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n193
+	i += n194
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Spec.Size()))
-	n194, err := m.Spec.MarshalTo(dAtA[i:])
+	n195, err := m.Spec.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n194
+	i += n195
 	dAtA[i] = 0x1a
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Status.Size()))
-	n195, err := m.Status.MarshalTo(dAtA[i:])
+	n196, err := m.Status.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n195
+	i += n196
 	return i, nil
 }
 
@@ -9625,11 +9671,11 @@ func (m *ServiceAccount) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ObjectMeta.Size()))
-	n196, err := m.ObjectMeta.MarshalTo(dAtA[i:])
+	n197, err := m.ObjectMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n196
+	i += n197
 	if len(m.Secrets) > 0 {
 		for _, msg := range m.Secrets {
 			dAtA[i] = 0x12
@@ -9685,11 +9731,11 @@ func (m *ServiceAccountList) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ListMeta.Size()))
-	n197, err := m.ListMeta.MarshalTo(dAtA[i:])
+	n198, err := m.ListMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n197
+	i += n198
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -9754,11 +9800,11 @@ func (m *ServiceList) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.ListMeta.Size()))
-	n198, err := m.ListMeta.MarshalTo(dAtA[i:])
+	n199, err := m.ListMeta.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n198
+	i += n199
 	if len(m.Items) > 0 {
 		for _, msg := range m.Items {
 			dAtA[i] = 0x12
@@ -9803,11 +9849,11 @@ func (m *ServicePort) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0x22
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.TargetPort.Size()))
-	n199, err := m.TargetPort.MarshalTo(dAtA[i:])
+	n200, err := m.TargetPort.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n199
+	i += n200
 	dAtA[i] = 0x28
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.NodePort))
@@ -9954,11 +10000,11 @@ func (m *ServiceSpec) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x72
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SessionAffinityConfig.Size()))
-		n200, err := m.SessionAffinityConfig.MarshalTo(dAtA[i:])
+		n201, err := m.SessionAffinityConfig.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n200
+		i += n201
 	}
 	return i, nil
 }
@@ -9981,11 +10027,11 @@ func (m *ServiceStatus) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.LoadBalancer.Size()))
-	n201, err := m.LoadBalancer.MarshalTo(dAtA[i:])
+	n202, err := m.LoadBalancer.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n201
+	i += n202
 	return i, nil
 }
 
@@ -10008,11 +10054,11 @@ func (m *SessionAffinityConfig) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ClientIP.Size()))
-		n202, err := m.ClientIP.MarshalTo(dAtA[i:])
+		n203, err := m.ClientIP.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n202
+		i += n203
 	}
 	return i, nil
 }
@@ -10056,11 +10102,11 @@ func (m *StorageOSPersistentVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x2a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SecretRef.Size()))
-		n203, err := m.SecretRef.MarshalTo(dAtA[i:])
+		n204, err := m.SecretRef.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n203
+		i += n204
 	}
 	return i, nil
 }
@@ -10104,11 +10150,11 @@ func (m *StorageOSVolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x2a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.SecretRef.Size()))
-		n204, err := m.SecretRef.MarshalTo(dAtA[i:])
+		n205, err := m.SecretRef.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n204
+		i += n205
 	}
 	return i, nil
 }
@@ -10157,11 +10203,11 @@ func (m *TCPSocketAction) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.Port.Size()))
-	n205, err := m.Port.MarshalTo(dAtA[i:])
+	n206, err := m.Port.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n205
+	i += n206
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Host)))
@@ -10200,11 +10246,11 @@ func (m *Taint) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x22
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.TimeAdded.Size()))
-		n206, err := m.TimeAdded.MarshalTo(dAtA[i:])
+		n207, err := m.TimeAdded.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n206
+		i += n207
 	}
 	return i, nil
 }
@@ -10337,11 +10383,11 @@ func (m *Volume) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.VolumeSource.Size()))
-	n207, err := m.VolumeSource.MarshalTo(dAtA[i:])
+	n208, err := m.VolumeSource.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n207
+	i += n208
 	return i, nil
 }
 
@@ -10434,11 +10480,11 @@ func (m *VolumeNodeAffinity) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Required.Size()))
-		n208, err := m.Required.MarshalTo(dAtA[i:])
+		n209, err := m.Required.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n208
+		i += n209
 	}
 	return i, nil
 }
@@ -10462,41 +10508,41 @@ func (m *VolumeProjection) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Secret.Size()))
-		n209, err := m.Secret.MarshalTo(dAtA[i:])
+		n210, err := m.Secret.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n209
+		i += n210
 	}
 	if m.DownwardAPI != nil {
 		dAtA[i] = 0x12
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.DownwardAPI.Size()))
-		n210, err := m.DownwardAPI.MarshalTo(dAtA[i:])
+		n211, err := m.DownwardAPI.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n210
+		i += n211
 	}
 	if m.ConfigMap != nil {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ConfigMap.Size()))
-		n211, err := m.ConfigMap.MarshalTo(dAtA[i:])
+		n212, err := m.ConfigMap.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n211
+		i += n212
 	}
 	if m.ServiceAccountToken != nil {
 		dAtA[i] = 0x22
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ServiceAccountToken.Size()))
-		n212, err := m.ServiceAccountToken.MarshalTo(dAtA[i:])
+		n213, err := m.ServiceAccountToken.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n212
+		i += n213
 	}
 	return i, nil
 }
@@ -10520,151 +10566,151 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0xa
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.HostPath.Size()))
-		n213, err := m.HostPath.MarshalTo(dAtA[i:])
+		n214, err := m.HostPath.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n213
+		i += n214
 	}
 	if m.EmptyDir != nil {
 		dAtA[i] = 0x12
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.EmptyDir.Size()))
-		n214, err := m.EmptyDir.MarshalTo(dAtA[i:])
+		n215, err := m.EmptyDir.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n214
+		i += n215
 	}
 	if m.GCEPersistentDisk != nil {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.GCEPersistentDisk.Size()))
-		n215, err := m.GCEPersistentDisk.MarshalTo(dAtA[i:])
+		n216, err := m.GCEPersistentDisk.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n215
+		i += n216
 	}
 	if m.AWSElasticBlockStore != nil {
 		dAtA[i] = 0x22
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.AWSElasticBlockStore.Size()))
-		n216, err := m.AWSElasticBlockStore.MarshalTo(dAtA[i:])
+		n217, err := m.AWSElasticBlockStore.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n216
+		i += n217
 	}
 	if m.GitRepo != nil {
 		dAtA[i] = 0x2a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.GitRepo.Size()))
-		n217, err := m.GitRepo.MarshalTo(dAtA[i:])
+		n218, err := m.GitRepo.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n217
+		i += n218
 	}
 	if m.Secret != nil {
 		dAtA[i] = 0x32
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Secret.Size()))
-		n218, err := m.Secret.MarshalTo(dAtA[i:])
+		n219, err := m.Secret.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n218
+		i += n219
 	}
 	if m.NFS != nil {
 		dAtA[i] = 0x3a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.NFS.Size()))
-		n219, err := m.NFS.MarshalTo(dAtA[i:])
+		n220, err := m.NFS.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n219
+		i += n220
 	}
 	if m.ISCSI != nil {
 		dAtA[i] = 0x42
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ISCSI.Size()))
-		n220, err := m.ISCSI.MarshalTo(dAtA[i:])
+		n221, err := m.ISCSI.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n220
+		i += n221
 	}
 	if m.Glusterfs != nil {
 		dAtA[i] = 0x4a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Glusterfs.Size()))
-		n221, err := m.Glusterfs.MarshalTo(dAtA[i:])
+		n222, err := m.Glusterfs.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n221
+		i += n222
 	}
 	if m.PersistentVolumeClaim != nil {
 		dAtA[i] = 0x52
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.PersistentVolumeClaim.Size()))
-		n222, err := m.PersistentVolumeClaim.MarshalTo(dAtA[i:])
+		n223, err := m.PersistentVolumeClaim.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n222
+		i += n223
 	}
 	if m.RBD != nil {
 		dAtA[i] = 0x5a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.RBD.Size()))
-		n223, err := m.RBD.MarshalTo(dAtA[i:])
+		n224, err := m.RBD.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n223
+		i += n224
 	}
 	if m.FlexVolume != nil {
 		dAtA[i] = 0x62
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.FlexVolume.Size()))
-		n224, err := m.FlexVolume.MarshalTo(dAtA[i:])
+		n225, err := m.FlexVolume.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n224
+		i += n225
 	}
 	if m.Cinder != nil {
 		dAtA[i] = 0x6a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Cinder.Size()))
-		n225, err := m.Cinder.MarshalTo(dAtA[i:])
+		n226, err := m.Cinder.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n225
+		i += n226
 	}
 	if m.CephFS != nil {
 		dAtA[i] = 0x72
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.CephFS.Size()))
-		n226, err := m.CephFS.MarshalTo(dAtA[i:])
+		n227, err := m.CephFS.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n226
+		i += n227
 	}
 	if m.Flocker != nil {
 		dAtA[i] = 0x7a
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Flocker.Size()))
-		n227, err := m.Flocker.MarshalTo(dAtA[i:])
+		n228, err := m.Flocker.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n227
+		i += n228
 	}
 	if m.DownwardAPI != nil {
 		dAtA[i] = 0x82
@@ -10672,11 +10718,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.DownwardAPI.Size()))
-		n228, err := m.DownwardAPI.MarshalTo(dAtA[i:])
+		n229, err := m.DownwardAPI.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n228
+		i += n229
 	}
 	if m.FC != nil {
 		dAtA[i] = 0x8a
@@ -10684,11 +10730,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.FC.Size()))
-		n229, err := m.FC.MarshalTo(dAtA[i:])
+		n230, err := m.FC.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n229
+		i += n230
 	}
 	if m.AzureFile != nil {
 		dAtA[i] = 0x92
@@ -10696,11 +10742,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.AzureFile.Size()))
-		n230, err := m.AzureFile.MarshalTo(dAtA[i:])
+		n231, err := m.AzureFile.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n230
+		i += n231
 	}
 	if m.ConfigMap != nil {
 		dAtA[i] = 0x9a
@@ -10708,11 +10754,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ConfigMap.Size()))
-		n231, err := m.ConfigMap.MarshalTo(dAtA[i:])
+		n232, err := m.ConfigMap.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n231
+		i += n232
 	}
 	if m.VsphereVolume != nil {
 		dAtA[i] = 0xa2
@@ -10720,11 +10766,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.VsphereVolume.Size()))
-		n232, err := m.VsphereVolume.MarshalTo(dAtA[i:])
+		n233, err := m.VsphereVolume.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n232
+		i += n233
 	}
 	if m.Quobyte != nil {
 		dAtA[i] = 0xaa
@@ -10732,23 +10778,23 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Quobyte.Size()))
-		n233, err := m.Quobyte.MarshalTo(dAtA[i:])
+		n234, err := m.Quobyte.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n233
+		i += n234
 	}
-	if m.AzureDisk != nil {
+	if m.CascadeDisk != nil {
 		dAtA[i] = 0xb2
 		i++
 		dAtA[i] = 0x1
 		i++
-		i = encodeVarintGenerated(dAtA, i, uint64(m.AzureDisk.Size()))
-		n234, err := m.AzureDisk.MarshalTo(dAtA[i:])
+		i = encodeVarintGenerated(dAtA, i, uint64(m.CascadeDisk.Size()))
+		n235, err := m.CascadeDisk.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n234
+		i += n235
 	}
 	if m.PhotonPersistentDisk != nil {
 		dAtA[i] = 0xba
@@ -10756,11 +10802,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.PhotonPersistentDisk.Size()))
-		n235, err := m.PhotonPersistentDisk.MarshalTo(dAtA[i:])
+		n236, err := m.PhotonPersistentDisk.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n235
+		i += n236
 	}
 	if m.PortworxVolume != nil {
 		dAtA[i] = 0xc2
@@ -10768,11 +10814,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.PortworxVolume.Size()))
-		n236, err := m.PortworxVolume.MarshalTo(dAtA[i:])
+		n237, err := m.PortworxVolume.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n236
+		i += n237
 	}
 	if m.ScaleIO != nil {
 		dAtA[i] = 0xca
@@ -10780,11 +10826,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.ScaleIO.Size()))
-		n237, err := m.ScaleIO.MarshalTo(dAtA[i:])
+		n238, err := m.ScaleIO.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n237
+		i += n238
 	}
 	if m.Projected != nil {
 		dAtA[i] = 0xd2
@@ -10792,11 +10838,11 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.Projected.Size()))
-		n238, err := m.Projected.MarshalTo(dAtA[i:])
+		n239, err := m.Projected.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n238
+		i += n239
 	}
 	if m.StorageOS != nil {
 		dAtA[i] = 0xda
@@ -10804,11 +10850,23 @@ func (m *VolumeSource) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1
 		i++
 		i = encodeVarintGenerated(dAtA, i, uint64(m.StorageOS.Size()))
-		n239, err := m.StorageOS.MarshalTo(dAtA[i:])
+		n240, err := m.StorageOS.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n239
+		i += n240
+	}
+	if m.AzureDisk != nil {
+		dAtA[i] = 0xe2
+		i++
+		dAtA[i] = 0x1
+		i++
+		i = encodeVarintGenerated(dAtA, i, uint64(m.AzureDisk.Size()))
+		n241, err := m.AzureDisk.MarshalTo(dAtA[i:])
+		if err != nil {
+			return 0, err
+		}
+		i += n241
 	}
 	return i, nil
 }
@@ -10868,11 +10926,11 @@ func (m *WeightedPodAffinityTerm) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0x12
 	i++
 	i = encodeVarintGenerated(dAtA, i, uint64(m.PodAffinityTerm.Size()))
-	n240, err := m.PodAffinityTerm.MarshalTo(dAtA[i:])
+	n242, err := m.PodAffinityTerm.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n240
+	i += n242
 	return i, nil
 }
 
@@ -11067,6 +11125,16 @@ func (m *Capabilities) Size() (n int) {
 	return n
 }
 
+func (m *CascadeDiskVolumeSource) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.DiskID)
+	n += 1 + l + sovGenerated(uint64(l))
+	l = len(m.FSType)
+	n += 1 + l + sovGenerated(uint64(l))
+	return n
+}
+
 func (m *CephFSPersistentVolumeSource) Size() (n int) {
 	var l int
 	_ = l
@@ -12776,8 +12844,8 @@ func (m *PersistentVolumeSource) Size() (n int) {
 		l = m.Quobyte.Size()
 		n += 1 + l + sovGenerated(uint64(l))
 	}
-	if m.AzureDisk != nil {
-		l = m.AzureDisk.Size()
+	if m.CascadeDisk != nil {
+		l = m.CascadeDisk.Size()
 		n += 2 + l + sovGenerated(uint64(l))
 	}
 	if m.PhotonPersistentDisk != nil {
@@ -12804,6 +12872,10 @@ func (m *PersistentVolumeSource) Size() (n int) {
 		l = m.CSI.Size()
 		n += 2 + l + sovGenerated(uint64(l))
 	}
+	if m.AzureDisk != nil {
+		l = m.AzureDisk.Size()
+		n += 2 + l + sovGenerated(uint64(l))
+	}
 	return n
 }
 
@@ -14353,8 +14425,8 @@ func (m *VolumeSource) Size() (n int) {
 		l = m.Quobyte.Size()
 		n += 2 + l + sovGenerated(uint64(l))
 	}
-	if m.AzureDisk != nil {
-		l = m.AzureDisk.Size()
+	if m.CascadeDisk != nil {
+		l = m.CascadeDisk.Size()
 		n += 2 + l + sovGenerated(uint64(l))
 	}
 	if m.PhotonPersistentDisk != nil {
@@ -14377,6 +14449,10 @@ func (m *VolumeSource) Size() (n int) {
 		l = m.StorageOS.Size()
 		n += 2 + l + sovGenerated(uint64(l))
 	}
+	if m.AzureDisk != nil {
+		l = m.AzureDisk.Size()
+		n += 2 + l + sovGenerated(uint64(l))
+	}
 	return n
 }
 
@@ -14551,6 +14627,17 @@ func (this *Capabilities) String() string {
 	}, "")
 	return s
 }
+func (this *CascadeDiskVolumeSource) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&CascadeDiskVolumeSource{`,
+		`DiskID:` + fmt.Sprintf("%v", this.DiskID) + `,`,
+		`FSType:` + fmt.Sprintf("%v", this.FSType) + `,`,
+		`}`,
+	}, "")
+	return s
+}
 func (this *CephFSPersistentVolumeSource) String() string {
 	if this == nil {
 		return "nil"
@@ -15920,13 +16007,14 @@ func (this *PersistentVolumeSource) String() string {
 		`AzureFile:` + strings.Replace(fmt.Sprintf("%v", this.AzureFile), "AzureFilePersistentVolumeSource", "AzureFilePersistentVolumeSource", 1) + `,`,
 		`VsphereVolume:` + strings.Replace(fmt.Sprintf("%v", this.VsphereVolume), "VsphereVirtualDiskVolumeSource", "VsphereVirtualDiskVolumeSource", 1) + `,`,
 		`Quobyte:` + strings.Replace(fmt.Sprintf("%v", this.Quobyte), "QuobyteVolumeSource", "QuobyteVolumeSource", 1) + `,`,
-		`AzureDisk:` + strings.Replace(fmt.Sprintf("%v", this.AzureDisk), "AzureDiskVolumeSource", "AzureDiskVolumeSource", 1) + `,`,
+		`CascadeDisk:` + strings.Replace(fmt.Sprintf("%v", this.CascadeDisk), "CascadeDiskVolumeSource", "CascadeDiskVolumeSource", 1) + `,`,
 		`PhotonPersistentDisk:` + strings.Replace(fmt.Sprintf("%v", this.PhotonPersistentDisk), "PhotonPersistentDiskVolumeSource", "PhotonPersistentDiskVolumeSource", 1) + `,`,
 		`PortworxVolume:` + strings.Replace(fmt.Sprintf("%v", this.PortworxVolume), "PortworxVolumeSource", "PortworxVolumeSource", 1) + `,`,
 		`ScaleIO:` + strings.Replace(fmt.Sprintf("%v", this.ScaleIO), "ScaleIOPersistentVolumeSource", "ScaleIOPersistentVolumeSource", 1) + `,`,
 		`Local:` + strings.Replace(fmt.Sprintf("%v", this.Local), "LocalVolumeSource", "LocalVolumeSource", 1) + `,`,
 		`StorageOS:` + strings.Replace(fmt.Sprintf("%v", this.StorageOS), "StorageOSPersistentVolumeSource", "StorageOSPersistentVolumeSource", 1) + `,`,
 		`CSI:` + strings.Replace(fmt.Sprintf("%v", this.CSI), "CSIPersistentVolumeSource", "CSIPersistentVolumeSource", 1) + `,`,
+		`AzureDisk:` + strings.Replace(fmt.Sprintf("%v", this.AzureDisk), "AzureDiskVolumeSource", "AzureDiskVolumeSource", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -17137,12 +17225,13 @@ func (this *VolumeSource) String() string {
 		`ConfigMap:` + strings.Replace(fmt.Sprintf("%v", this.ConfigMap), "ConfigMapVolumeSource", "ConfigMapVolumeSource", 1) + `,`,
 		`VsphereVolume:` + strings.Replace(fmt.Sprintf("%v", this.VsphereVolume), "VsphereVirtualDiskVolumeSource", "VsphereVirtualDiskVolumeSource", 1) + `,`,
 		`Quobyte:` + strings.Replace(fmt.Sprintf("%v", this.Quobyte), "QuobyteVolumeSource", "QuobyteVolumeSource", 1) + `,`,
-		`AzureDisk:` + strings.Replace(fmt.Sprintf("%v", this.AzureDisk), "AzureDiskVolumeSource", "AzureDiskVolumeSource", 1) + `,`,
+		`CascadeDisk:` + strings.Replace(fmt.Sprintf("%v", this.CascadeDisk), "CascadeDiskVolumeSource", "CascadeDiskVolumeSource", 1) + `,`,
 		`PhotonPersistentDisk:` + strings.Replace(fmt.Sprintf("%v", this.PhotonPersistentDisk), "PhotonPersistentDiskVolumeSource", "PhotonPersistentDiskVolumeSource", 1) + `,`,
 		`PortworxVolume:` + strings.Replace(fmt.Sprintf("%v", this.PortworxVolume), "PortworxVolumeSource", "PortworxVolumeSource", 1) + `,`,
 		`ScaleIO:` + strings.Replace(fmt.Sprintf("%v", this.ScaleIO), "ScaleIOVolumeSource", "ScaleIOVolumeSource", 1) + `,`,
 		`Projected:` + strings.Replace(fmt.Sprintf("%v", this.Projected), "ProjectedVolumeSource", "ProjectedVolumeSource", 1) + `,`,
 		`StorageOS:` + strings.Replace(fmt.Sprintf("%v", this.StorageOS), "StorageOSVolumeSource", "StorageOSVolumeSource", 1) + `,`,
+		`AzureDisk:` + strings.Replace(fmt.Sprintf("%v", this.AzureDisk), "AzureDiskVolumeSource", "AzureDiskVolumeSource", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -18759,6 +18848,114 @@ func (m *Capabilities) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *CascadeDiskVolumeSource) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowGenerated
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: CascadeDiskVolumeSource: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: CascadeDiskVolumeSource: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowGenerated
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthGenerated
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.DiskID = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FSType", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowGenerated
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthGenerated
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FSType = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipGenerated(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthGenerated
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func (m *CephFSPersistentVolumeSource) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
@@ -35229,7 +35426,7 @@ func (m *PersistentVolumeSource) Unmarshal(dAtA []byte) error {
 			iNdEx = postIndex
 		case 16:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AzureDisk", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field CascadeDisk", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -35253,10 +35450,10 @@ func (m *PersistentVolumeSource) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.AzureDisk == nil {
-				m.AzureDisk = &AzureDiskVolumeSource{}
+			if m.CascadeDisk == nil {
+				m.CascadeDisk = &CascadeDiskVolumeSource{}
 			}
-			if err := m.AzureDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.CascadeDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -35458,6 +35655,39 @@ func (m *PersistentVolumeSource) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 23:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AzureDisk", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowGenerated
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthGenerated
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.AzureDisk == nil {
+				m.AzureDisk = &AzureDiskVolumeSource{}
+			}
+			if err := m.AzureDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipGenerated(dAtA[iNdEx:])
@@ -50377,7 +50607,7 @@ func (m *VolumeSource) Unmarshal(dAtA []byte) error {
 			iNdEx = postIndex
 		case 22:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AzureDisk", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field CascadeDisk", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -50401,10 +50631,10 @@ func (m *VolumeSource) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.AzureDisk == nil {
-				m.AzureDisk = &AzureDiskVolumeSource{}
+			if m.CascadeDisk == nil {
+				m.CascadeDisk = &CascadeDiskVolumeSource{}
 			}
-			if err := m.AzureDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.CascadeDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -50573,6 +50803,39 @@ func (m *VolumeSource) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 28:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AzureDisk", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowGenerated
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthGenerated
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.AzureDisk == nil {
+				m.AzureDisk = &AzureDiskVolumeSource{}
+			}
+			if err := m.AzureDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipGenerated(dAtA[iNdEx:])
@@ -50969,797 +51232,802 @@ func init() {
 }
 
 var fileDescriptorGenerated = []byte{
-	// 12669 bytes of a gzipped FileDescriptorProto
+	// 12751 bytes of a gzipped FileDescriptorProto
 	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x6b, 0x6c, 0x24, 0x57,
-	0x76, 0x18, 0xbc, 0xd5, 0xdd, 0x7c, 0xf4, 0xe1, 0xfb, 0xce, 0x43, 0x1c, 0x4a, 0x33, 0x3d, 0x2a,
-	0xed, 0x8e, 0x46, 0x2b, 0x89, 0xb3, 0x1a, 0x49, 0x2b, 0x79, 0xb5, 0x2b, 0x9b, 0x64, 0x93, 0x33,
-	0xd4, 0x0c, 0x39, 0xad, 0xdb, 0x9c, 0xd1, 0xae, 0xac, 0x5d, 0x6f, 0xb1, 0xfb, 0xb2, 0x59, 0x62,
-	0xb1, 0xaa, 0x55, 0x55, 0xcd, 0x19, 0xea, 0xb3, 0x81, 0x2f, 0xeb, 0xd8, 0x89, 0x1f, 0x08, 0x16,
-	0xb1, 0x91, 0x87, 0x6d, 0x38, 0x80, 0xe3, 0xc0, 0x76, 0x9c, 0x04, 0x71, 0xec, 0xd8, 0xce, 0xae,
-	0x9d, 0x38, 0x4e, 0x7e, 0x38, 0x7f, 0x36, 0x4e, 0x80, 0x60, 0x0d, 0x18, 0x61, 0x6c, 0xda, 0x49,
-	0xe0, 0x1f, 0x79, 0x20, 0xce, 0x1f, 0x33, 0x46, 0x1c, 0xdc, 0x67, 0xdd, 0x5b, 0x5d, 0xd5, 0xdd,
-	0x1c, 0x71, 0x28, 0xd9, 0xd8, 0x7f, 0xdd, 0xf7, 0x9c, 0x7b, 0xee, 0xad, 0xfb, 0x3c, 0xe7, 0xdc,
-	0xf3, 0x80, 0xd7, 0x76, 0x5e, 0x8d, 0xe6, 0xdd, 0xe0, 0xda, 0x4e, 0x67, 0x93, 0x84, 0x3e, 0x89,
-	0x49, 0x74, 0x6d, 0x8f, 0xf8, 0xcd, 0x20, 0xbc, 0x26, 0x00, 0x4e, 0xdb, 0xbd, 0xd6, 0x08, 0x42,
-	0x72, 0x6d, 0xef, 0x85, 0x6b, 0x2d, 0xe2, 0x93, 0xd0, 0x89, 0x49, 0x73, 0xbe, 0x1d, 0x06, 0x71,
-	0x80, 0x10, 0xc7, 0x99, 0x77, 0xda, 0xee, 0x3c, 0xc5, 0x99, 0xdf, 0x7b, 0x61, 0xee, 0xf9, 0x96,
-	0x1b, 0x6f, 0x77, 0x36, 0xe7, 0x1b, 0xc1, 0xee, 0xb5, 0x56, 0xd0, 0x0a, 0xae, 0x31, 0xd4, 0xcd,
-	0xce, 0x16, 0xfb, 0xc7, 0xfe, 0xb0, 0x5f, 0x9c, 0xc4, 0xdc, 0x4b, 0x49, 0x33, 0xbb, 0x4e, 0x63,
-	0xdb, 0xf5, 0x49, 0xb8, 0x7f, 0xad, 0xbd, 0xd3, 0x62, 0xed, 0x86, 0x24, 0x0a, 0x3a, 0x61, 0x83,
-	0xa4, 0x1b, 0xee, 0x59, 0x2b, 0xba, 0xb6, 0x4b, 0x62, 0x27, 0xa3, 0xbb, 0x73, 0xd7, 0xf2, 0x6a,
-	0x85, 0x1d, 0x3f, 0x76, 0x77, 0xbb, 0x9b, 0xf9, 0x74, 0xbf, 0x0a, 0x51, 0x63, 0x9b, 0xec, 0x3a,
-	0x5d, 0xf5, 0x5e, 0xcc, 0xab, 0xd7, 0x89, 0x5d, 0xef, 0x9a, 0xeb, 0xc7, 0x51, 0x1c, 0xa6, 0x2b,
-	0xd9, 0xdf, 0xb4, 0xe0, 0xf2, 0xc2, 0x5b, 0xf5, 0x65, 0xcf, 0x89, 0x62, 0xb7, 0xb1, 0xe8, 0x05,
-	0x8d, 0x9d, 0x7a, 0x1c, 0x84, 0xe4, 0x5e, 0xe0, 0x75, 0x76, 0x49, 0x9d, 0x0d, 0x04, 0x7a, 0x0e,
-	0x46, 0xf7, 0xd8, 0xff, 0xd5, 0xea, 0xac, 0x75, 0xd9, 0xba, 0x5a, 0x5e, 0x9c, 0xfe, 0xad, 0x83,
-	0xca, 0xc7, 0x0e, 0x0f, 0x2a, 0xa3, 0xf7, 0x44, 0x39, 0x56, 0x18, 0xe8, 0x0a, 0x0c, 0x6f, 0x45,
-	0x1b, 0xfb, 0x6d, 0x32, 0x5b, 0x60, 0xb8, 0x93, 0x02, 0x77, 0x78, 0xa5, 0x4e, 0x4b, 0xb1, 0x80,
-	0xa2, 0x6b, 0x50, 0x6e, 0x3b, 0x61, 0xec, 0xc6, 0x6e, 0xe0, 0xcf, 0x16, 0x2f, 0x5b, 0x57, 0x87,
-	0x16, 0x67, 0x04, 0x6a, 0xb9, 0x26, 0x01, 0x38, 0xc1, 0xa1, 0xdd, 0x08, 0x89, 0xd3, 0xbc, 0xe3,
-	0x7b, 0xfb, 0xb3, 0xa5, 0xcb, 0xd6, 0xd5, 0xd1, 0xa4, 0x1b, 0x58, 0x94, 0x63, 0x85, 0x61, 0xff,
-	0x58, 0x01, 0x46, 0x17, 0xb6, 0xb6, 0x5c, 0xdf, 0x8d, 0xf7, 0xd1, 0x3d, 0x18, 0xf7, 0x83, 0x26,
-	0x91, 0xff, 0xd9, 0x57, 0x8c, 0x5d, 0xbf, 0x3c, 0xdf, 0xbd, 0x94, 0xe6, 0xd7, 0x35, 0xbc, 0xc5,
-	0xe9, 0xc3, 0x83, 0xca, 0xb8, 0x5e, 0x82, 0x0d, 0x3a, 0x08, 0xc3, 0x58, 0x3b, 0x68, 0x2a, 0xb2,
-	0x05, 0x46, 0xb6, 0x92, 0x45, 0xb6, 0x96, 0xa0, 0x2d, 0x4e, 0x1d, 0x1e, 0x54, 0xc6, 0xb4, 0x02,
-	0xac, 0x13, 0x41, 0x9b, 0x30, 0x45, 0xff, 0xfa, 0xb1, 0xab, 0xe8, 0x16, 0x19, 0xdd, 0xa7, 0xf2,
-	0xe8, 0x6a, 0xa8, 0x8b, 0x67, 0x0e, 0x0f, 0x2a, 0x53, 0xa9, 0x42, 0x9c, 0x26, 0x68, 0xbf, 0x0f,
-	0x93, 0x0b, 0x71, 0xec, 0x34, 0xb6, 0x49, 0x93, 0xcf, 0x20, 0x7a, 0x09, 0x4a, 0xbe, 0xb3, 0x4b,
-	0xc4, 0xfc, 0x5e, 0x16, 0x03, 0x5b, 0x5a, 0x77, 0x76, 0xc9, 0xd1, 0x41, 0x65, 0xfa, 0xae, 0xef,
-	0xbe, 0xd7, 0x11, 0xab, 0x82, 0x96, 0x61, 0x86, 0x8d, 0xae, 0x03, 0x34, 0xc9, 0x9e, 0xdb, 0x20,
-	0x35, 0x27, 0xde, 0x16, 0xf3, 0x8d, 0x44, 0x5d, 0xa8, 0x2a, 0x08, 0xd6, 0xb0, 0xec, 0x07, 0x50,
-	0x5e, 0xd8, 0x0b, 0xdc, 0x66, 0x2d, 0x68, 0x46, 0x68, 0x07, 0xa6, 0xda, 0x21, 0xd9, 0x22, 0xa1,
-	0x2a, 0x9a, 0xb5, 0x2e, 0x17, 0xaf, 0x8e, 0x5d, 0xbf, 0x9a, 0xf9, 0xb1, 0x26, 0xea, 0xb2, 0x1f,
-	0x87, 0xfb, 0x8b, 0x8f, 0x89, 0xf6, 0xa6, 0x52, 0x50, 0x9c, 0xa6, 0x6c, 0xff, 0xeb, 0x02, 0x9c,
-	0x5b, 0x78, 0xbf, 0x13, 0x92, 0xaa, 0x1b, 0xed, 0xa4, 0x57, 0x78, 0xd3, 0x8d, 0x76, 0xd6, 0x93,
-	0x11, 0x50, 0x4b, 0xab, 0x2a, 0xca, 0xb1, 0xc2, 0x40, 0xcf, 0xc3, 0x08, 0xfd, 0x7d, 0x17, 0xaf,
-	0x8a, 0x4f, 0x3e, 0x23, 0x90, 0xc7, 0xaa, 0x4e, 0xec, 0x54, 0x39, 0x08, 0x4b, 0x1c, 0xb4, 0x06,
-	0x63, 0x0d, 0xb6, 0x21, 0x5b, 0x6b, 0x41, 0x93, 0xb0, 0xc9, 0x2c, 0x2f, 0x3e, 0x4b, 0xd1, 0x97,
-	0x92, 0xe2, 0xa3, 0x83, 0xca, 0x2c, 0xef, 0x9b, 0x20, 0xa1, 0xc1, 0xb0, 0x5e, 0x1f, 0xd9, 0x6a,
-	0x7f, 0x95, 0x18, 0x25, 0xc8, 0xd8, 0x5b, 0x57, 0xb5, 0xad, 0x32, 0xc4, 0xb6, 0xca, 0x78, 0xf6,
-	0x36, 0x41, 0x2f, 0x40, 0x69, 0xc7, 0xf5, 0x9b, 0xb3, 0xc3, 0x8c, 0xd6, 0x45, 0x3a, 0xe7, 0xb7,
-	0x5c, 0xbf, 0x79, 0x74, 0x50, 0x99, 0x31, 0xba, 0x43, 0x0b, 0x31, 0x43, 0xb5, 0xff, 0xd8, 0x82,
-	0x0a, 0x83, 0xad, 0xb8, 0x1e, 0xa9, 0x91, 0x30, 0x72, 0xa3, 0x98, 0xf8, 0xb1, 0x31, 0xa0, 0xd7,
-	0x01, 0x22, 0xd2, 0x08, 0x49, 0xac, 0x0d, 0xa9, 0x5a, 0x18, 0x75, 0x05, 0xc1, 0x1a, 0x16, 0x3d,
-	0x10, 0xa2, 0x6d, 0x27, 0x64, 0xeb, 0x4b, 0x0c, 0xac, 0x3a, 0x10, 0xea, 0x12, 0x80, 0x13, 0x1c,
-	0xe3, 0x40, 0x28, 0xf6, 0x3b, 0x10, 0xd0, 0xe7, 0x60, 0x2a, 0x69, 0x2c, 0x6a, 0x3b, 0x0d, 0x39,
-	0x80, 0x6c, 0xcb, 0xd4, 0x4d, 0x10, 0x4e, 0xe3, 0xda, 0x7f, 0xdf, 0x12, 0x8b, 0x87, 0x7e, 0xf5,
-	0x47, 0xfc, 0x5b, 0xed, 0x5f, 0xb5, 0x60, 0x64, 0xd1, 0xf5, 0x9b, 0xae, 0xdf, 0x42, 0x5f, 0x86,
-	0x51, 0x7a, 0x37, 0x35, 0x9d, 0xd8, 0x11, 0xe7, 0xde, 0xa7, 0xb4, 0xbd, 0xa5, 0xae, 0x8a, 0xf9,
-	0xf6, 0x4e, 0x8b, 0x16, 0x44, 0xf3, 0x14, 0x9b, 0xee, 0xb6, 0x3b, 0x9b, 0xef, 0x92, 0x46, 0xbc,
-	0x46, 0x62, 0x27, 0xf9, 0x9c, 0xa4, 0x0c, 0x2b, 0xaa, 0xe8, 0x16, 0x0c, 0xc7, 0x4e, 0xd8, 0x22,
-	0xb1, 0x38, 0x00, 0x33, 0x0f, 0x2a, 0x5e, 0x13, 0xd3, 0x1d, 0x49, 0xfc, 0x06, 0x49, 0xae, 0x85,
-	0x0d, 0x56, 0x15, 0x0b, 0x12, 0xf6, 0x0f, 0x0e, 0xc3, 0x85, 0xa5, 0xfa, 0x6a, 0xce, 0xba, 0xba,
-	0x02, 0xc3, 0xcd, 0xd0, 0xdd, 0x23, 0xa1, 0x18, 0x67, 0x45, 0xa5, 0xca, 0x4a, 0xb1, 0x80, 0xa2,
-	0x57, 0x61, 0x9c, 0x5f, 0x48, 0x37, 0x1d, 0xbf, 0xe9, 0xc9, 0x21, 0x3e, 0x2b, 0xb0, 0xc7, 0xef,
-	0x69, 0x30, 0x6c, 0x60, 0x1e, 0x73, 0x51, 0x5d, 0x49, 0x6d, 0xc6, 0xbc, 0xcb, 0xee, 0x07, 0x2c,
-	0x98, 0xe6, 0xcd, 0x2c, 0xc4, 0x71, 0xe8, 0x6e, 0x76, 0x62, 0x12, 0xcd, 0x0e, 0xb1, 0x93, 0x6e,
-	0x29, 0x6b, 0xb4, 0x72, 0x47, 0x60, 0xfe, 0x5e, 0x8a, 0x0a, 0x3f, 0x04, 0x67, 0x45, 0xbb, 0xd3,
-	0x69, 0x30, 0xee, 0x6a, 0x16, 0x7d, 0xaf, 0x05, 0x73, 0x8d, 0xc0, 0x8f, 0xc3, 0xc0, 0xf3, 0x48,
-	0x58, 0xeb, 0x6c, 0x7a, 0x6e, 0xb4, 0xcd, 0xd7, 0x29, 0x26, 0x5b, 0xec, 0x24, 0xc8, 0x99, 0x43,
-	0x85, 0x24, 0xe6, 0xf0, 0xd2, 0xe1, 0x41, 0x65, 0x6e, 0x29, 0x97, 0x14, 0xee, 0xd1, 0x0c, 0xda,
-	0x01, 0x44, 0xaf, 0xd2, 0x7a, 0xec, 0xb4, 0x48, 0xd2, 0xf8, 0xc8, 0xe0, 0x8d, 0x9f, 0x3f, 0x3c,
-	0xa8, 0xa0, 0xf5, 0x2e, 0x12, 0x38, 0x83, 0x2c, 0x7a, 0x0f, 0xce, 0xd2, 0xd2, 0xae, 0x6f, 0x1d,
-	0x1d, 0xbc, 0xb9, 0xd9, 0xc3, 0x83, 0xca, 0xd9, 0xf5, 0x0c, 0x22, 0x38, 0x93, 0xf4, 0xdc, 0x12,
-	0x9c, 0xcb, 0x9c, 0x2a, 0x34, 0x0d, 0xc5, 0x1d, 0xc2, 0x59, 0x90, 0x32, 0xa6, 0x3f, 0xd1, 0x59,
-	0x18, 0xda, 0x73, 0xbc, 0x8e, 0x58, 0xa5, 0x98, 0xff, 0xf9, 0x4c, 0xe1, 0x55, 0xcb, 0x6e, 0xc0,
-	0xf8, 0x92, 0xd3, 0x76, 0x36, 0x5d, 0xcf, 0x8d, 0x5d, 0x12, 0xa1, 0xa7, 0xa1, 0xe8, 0x34, 0x9b,
-	0xec, 0x8a, 0x2c, 0x2f, 0x9e, 0x3b, 0x3c, 0xa8, 0x14, 0x17, 0x9a, 0xf4, 0xac, 0x06, 0x85, 0xb5,
-	0x8f, 0x29, 0x06, 0xfa, 0x24, 0x94, 0x9a, 0x61, 0xd0, 0x9e, 0x2d, 0x30, 0x4c, 0x3a, 0x54, 0xa5,
-	0x6a, 0x18, 0xb4, 0x53, 0xa8, 0x0c, 0xc7, 0xfe, 0x8d, 0x02, 0x3c, 0xb1, 0x44, 0xda, 0xdb, 0x2b,
-	0xf5, 0x9c, 0x4d, 0x77, 0x15, 0x46, 0x77, 0x03, 0xdf, 0x8d, 0x83, 0x30, 0x12, 0x4d, 0xb3, 0xdb,
-	0x64, 0x4d, 0x94, 0x61, 0x05, 0x45, 0x97, 0xa1, 0xd4, 0x4e, 0x38, 0x81, 0x71, 0xc9, 0x45, 0x30,
-	0x1e, 0x80, 0x41, 0x28, 0x46, 0x27, 0x22, 0xa1, 0xb8, 0x05, 0x15, 0xc6, 0xdd, 0x88, 0x84, 0x98,
-	0x41, 0x92, 0xe3, 0x94, 0x1e, 0xb4, 0x62, 0x5b, 0xa5, 0x8e, 0x53, 0x0a, 0xc1, 0x1a, 0x16, 0xaa,
-	0x41, 0x39, 0x52, 0x93, 0x3a, 0x34, 0xf8, 0xa4, 0x4e, 0xb0, 0xf3, 0x56, 0xcd, 0x64, 0x42, 0xc4,
-	0x38, 0x06, 0x86, 0xfb, 0x9e, 0xb7, 0x5f, 0x2f, 0x00, 0xe2, 0x43, 0xf8, 0xe7, 0x6c, 0xe0, 0xee,
-	0x76, 0x0f, 0x5c, 0x26, 0xe7, 0x75, 0x3b, 0x68, 0x38, 0x5e, 0xfa, 0x08, 0x3f, 0xa9, 0xd1, 0xfb,
-	0xdf, 0x16, 0x3c, 0xb1, 0xe4, 0xfa, 0x4d, 0x12, 0xe6, 0x2c, 0xc0, 0x47, 0x23, 0x80, 0x1c, 0xef,
-	0xa4, 0x37, 0x96, 0x58, 0xe9, 0x04, 0x96, 0x98, 0xfd, 0x3f, 0x2c, 0x40, 0xfc, 0xb3, 0x3f, 0x72,
-	0x1f, 0x7b, 0xb7, 0xfb, 0x63, 0x4f, 0x60, 0x59, 0xd8, 0xb7, 0x61, 0x72, 0xc9, 0x73, 0x89, 0x1f,
-	0xaf, 0xd6, 0x96, 0x02, 0x7f, 0xcb, 0x6d, 0xa1, 0xcf, 0xc0, 0x24, 0x95, 0x69, 0x83, 0x4e, 0x5c,
-	0x27, 0x8d, 0xc0, 0x67, 0xec, 0x3f, 0x95, 0x04, 0xd1, 0xe1, 0x41, 0x65, 0x72, 0xc3, 0x80, 0xe0,
-	0x14, 0xa6, 0xfd, 0xbb, 0x74, 0xfc, 0x82, 0xdd, 0x76, 0xe0, 0x13, 0x3f, 0x5e, 0x0a, 0xfc, 0x26,
-	0x17, 0x13, 0x3f, 0x03, 0xa5, 0x98, 0x8e, 0x07, 0x1f, 0xbb, 0x2b, 0x72, 0xa3, 0xd0, 0x51, 0x38,
-	0x3a, 0xa8, 0x9c, 0xef, 0xae, 0xc1, 0xc6, 0x89, 0xd5, 0x41, 0xdf, 0x06, 0xc3, 0x51, 0xec, 0xc4,
-	0x9d, 0x48, 0x8c, 0xe6, 0x93, 0x72, 0x34, 0xeb, 0xac, 0xf4, 0xe8, 0xa0, 0x32, 0xa5, 0xaa, 0xf1,
-	0x22, 0x2c, 0x2a, 0xa0, 0x67, 0x60, 0x64, 0x97, 0x44, 0x91, 0xd3, 0x92, 0x1c, 0xfe, 0x94, 0xa8,
-	0x3b, 0xb2, 0xc6, 0x8b, 0xb1, 0x84, 0xa3, 0xa7, 0x60, 0x88, 0x84, 0x61, 0x10, 0x8a, 0x3d, 0x3a,
-	0x21, 0x10, 0x87, 0x96, 0x69, 0x21, 0xe6, 0x30, 0xfb, 0xdf, 0x5a, 0x30, 0xa5, 0xfa, 0xca, 0xdb,
-	0x3a, 0x05, 0x56, 0xee, 0x6d, 0x80, 0x86, 0xfc, 0xc0, 0x88, 0xdd, 0x1e, 0x63, 0xd7, 0xaf, 0x64,
-	0x32, 0x28, 0x5d, 0xc3, 0x98, 0x50, 0x56, 0x45, 0x11, 0xd6, 0xa8, 0xd9, 0xbf, 0x6e, 0xc1, 0x99,
-	0xd4, 0x17, 0xdd, 0x76, 0xa3, 0x18, 0xbd, 0xd3, 0xf5, 0x55, 0xf3, 0x83, 0x7d, 0x15, 0xad, 0xcd,
-	0xbe, 0x49, 0x2d, 0x65, 0x59, 0xa2, 0x7d, 0xd1, 0x4d, 0x18, 0x72, 0x63, 0xb2, 0x2b, 0x3f, 0xe6,
-	0xa9, 0x9e, 0x1f, 0xc3, 0x7b, 0x95, 0xcc, 0xc8, 0x2a, 0xad, 0x89, 0x39, 0x01, 0xfb, 0x47, 0x8a,
-	0x50, 0xe6, 0xcb, 0x76, 0xcd, 0x69, 0x9f, 0xc2, 0x5c, 0xac, 0x42, 0x89, 0x51, 0xe7, 0x1d, 0x7f,
-	0x3a, 0xbb, 0xe3, 0xa2, 0x3b, 0xf3, 0x54, 0x4e, 0xe3, 0xac, 0xa0, 0xba, 0x1a, 0x68, 0x11, 0x66,
-	0x24, 0x90, 0x03, 0xb0, 0xe9, 0xfa, 0x4e, 0xb8, 0x4f, 0xcb, 0x66, 0x8b, 0x8c, 0xe0, 0xf3, 0xbd,
-	0x09, 0x2e, 0x2a, 0x7c, 0x4e, 0x56, 0xf5, 0x35, 0x01, 0x60, 0x8d, 0xe8, 0xdc, 0x2b, 0x50, 0x56,
-	0xc8, 0xc7, 0xe1, 0x71, 0xe6, 0x3e, 0x07, 0x53, 0xa9, 0xb6, 0xfa, 0x55, 0x1f, 0xd7, 0x59, 0xa4,
-	0xaf, 0xb1, 0x53, 0x40, 0xf4, 0x7a, 0xd9, 0xdf, 0x13, 0xa7, 0xe8, 0xfb, 0x70, 0xd6, 0xcb, 0x38,
-	0x9c, 0xc4, 0x54, 0x0d, 0x7e, 0x98, 0x3d, 0x21, 0x3e, 0xfb, 0x6c, 0x16, 0x14, 0x67, 0xb6, 0x41,
-	0xaf, 0xfd, 0xa0, 0x4d, 0xd7, 0xbc, 0xe3, 0xb1, 0xfe, 0x0a, 0xe9, 0xfb, 0x8e, 0x28, 0xc3, 0x0a,
-	0x4a, 0x8f, 0xb0, 0xb3, 0xaa, 0xf3, 0xb7, 0xc8, 0x7e, 0x9d, 0x78, 0xa4, 0x11, 0x07, 0xe1, 0x87,
-	0xda, 0xfd, 0x8b, 0x7c, 0xf4, 0xf9, 0x09, 0x38, 0x26, 0x08, 0x14, 0x6f, 0x91, 0x7d, 0x3e, 0x15,
-	0xfa, 0xd7, 0x15, 0x7b, 0x7e, 0xdd, 0x2f, 0x58, 0x30, 0xa1, 0xbe, 0xee, 0x14, 0xb6, 0xfa, 0xa2,
-	0xb9, 0xd5, 0x2f, 0xf6, 0x5c, 0xe0, 0x39, 0x9b, 0xfc, 0xeb, 0x05, 0xb8, 0xa0, 0x70, 0x28, 0xbb,
-	0xcf, 0xff, 0x88, 0x55, 0x75, 0x0d, 0xca, 0xbe, 0xd2, 0x1e, 0x58, 0xa6, 0xd8, 0x9e, 0xe8, 0x0e,
-	0x12, 0x1c, 0xca, 0xb5, 0xf9, 0x89, 0x88, 0x3f, 0xae, 0xab, 0xd5, 0x84, 0x0a, 0x6d, 0x11, 0x8a,
-	0x1d, 0xb7, 0x29, 0xee, 0x8c, 0x4f, 0xc9, 0xd1, 0xbe, 0xbb, 0x5a, 0x3d, 0x3a, 0xa8, 0x3c, 0x99,
-	0xa7, 0xd2, 0xa5, 0x97, 0x55, 0x34, 0x7f, 0x77, 0xb5, 0x8a, 0x69, 0x65, 0xb4, 0x00, 0x53, 0x52,
-	0x6b, 0x7d, 0x8f, 0x72, 0x50, 0x81, 0x2f, 0xae, 0x16, 0xa5, 0x1b, 0xc3, 0x26, 0x18, 0xa7, 0xf1,
-	0x51, 0x15, 0xa6, 0x77, 0x3a, 0x9b, 0xc4, 0x23, 0x31, 0xff, 0xe0, 0x5b, 0x84, 0x6b, 0x8e, 0xca,
-	0x89, 0x68, 0x79, 0x2b, 0x05, 0xc7, 0x5d, 0x35, 0xec, 0x3f, 0x63, 0x47, 0xbc, 0x18, 0xbd, 0x5a,
-	0x18, 0xd0, 0x85, 0x45, 0xa9, 0x7f, 0x98, 0xcb, 0x79, 0x90, 0x55, 0x71, 0x8b, 0xec, 0x6f, 0x04,
-	0x94, 0xd9, 0xce, 0x5e, 0x15, 0xc6, 0x9a, 0x2f, 0xf5, 0x5c, 0xf3, 0xbf, 0x54, 0x80, 0x73, 0x6a,
-	0x04, 0x0c, 0xbe, 0xee, 0xcf, 0xfb, 0x18, 0xbc, 0x00, 0x63, 0x4d, 0xb2, 0xe5, 0x74, 0xbc, 0x58,
-	0xa9, 0x31, 0x87, 0xb8, 0x2a, 0xbb, 0x9a, 0x14, 0x63, 0x1d, 0xe7, 0x18, 0xc3, 0xf6, 0xd3, 0x63,
-	0xec, 0x6e, 0x8d, 0x1d, 0xba, 0xc6, 0xd5, 0xae, 0xb1, 0x72, 0x77, 0xcd, 0x53, 0x30, 0xe4, 0xee,
-	0x52, 0x5e, 0xab, 0x60, 0xb2, 0x50, 0xab, 0xb4, 0x10, 0x73, 0x18, 0xfa, 0x04, 0x8c, 0x34, 0x82,
-	0xdd, 0x5d, 0xc7, 0x6f, 0xb2, 0x2b, 0xaf, 0xbc, 0x38, 0x46, 0xd9, 0xb1, 0x25, 0x5e, 0x84, 0x25,
-	0x0c, 0x3d, 0x01, 0x25, 0x27, 0x6c, 0x45, 0xb3, 0x25, 0x86, 0x33, 0x4a, 0x5b, 0x5a, 0x08, 0x5b,
-	0x11, 0x66, 0xa5, 0x54, 0xaa, 0xba, 0x1f, 0x84, 0x3b, 0xae, 0xdf, 0xaa, 0xba, 0xa1, 0xd8, 0x12,
-	0xea, 0x2e, 0x7c, 0x4b, 0x41, 0xb0, 0x86, 0x85, 0x56, 0x60, 0xa8, 0x1d, 0x84, 0x71, 0x34, 0x3b,
-	0xcc, 0x86, 0xfb, 0xc9, 0x9c, 0x83, 0x88, 0x7f, 0x6d, 0x2d, 0x08, 0xe3, 0xe4, 0x03, 0xe8, 0xbf,
-	0x08, 0xf3, 0xea, 0xe8, 0xdb, 0xa0, 0x48, 0xfc, 0xbd, 0xd9, 0x11, 0x46, 0x65, 0x2e, 0x8b, 0xca,
-	0xb2, 0xbf, 0x77, 0xcf, 0x09, 0x93, 0x53, 0x7a, 0xd9, 0xdf, 0xc3, 0xb4, 0x0e, 0xfa, 0x02, 0x94,
-	0xe5, 0x16, 0x8f, 0x84, 0x9a, 0x23, 0x73, 0x89, 0xc9, 0x83, 0x01, 0x93, 0xf7, 0x3a, 0x6e, 0x48,
-	0x76, 0x89, 0x1f, 0x47, 0xc9, 0x99, 0x26, 0xa1, 0x11, 0x4e, 0xa8, 0xa1, 0x2f, 0x48, 0xdd, 0xda,
-	0x5a, 0xd0, 0xf1, 0xe3, 0x68, 0xb6, 0xcc, 0xba, 0x97, 0xf9, 0xea, 0x71, 0x2f, 0xc1, 0x4b, 0x2b,
-	0xdf, 0x78, 0x65, 0x6c, 0x90, 0x42, 0x18, 0x26, 0x3c, 0x77, 0x8f, 0xf8, 0x24, 0x8a, 0x6a, 0x61,
-	0xb0, 0x49, 0x66, 0x81, 0xf5, 0xfc, 0x42, 0xf6, 0x63, 0x40, 0xb0, 0x49, 0x16, 0x67, 0x0e, 0x0f,
-	0x2a, 0x13, 0xb7, 0xf5, 0x3a, 0xd8, 0x24, 0x81, 0xee, 0xc2, 0x24, 0x95, 0x6b, 0xdc, 0x84, 0xe8,
-	0x58, 0x3f, 0xa2, 0x4c, 0xfa, 0xc0, 0x46, 0x25, 0x9c, 0x22, 0x82, 0xde, 0x80, 0xb2, 0xe7, 0x6e,
-	0x91, 0xc6, 0x7e, 0xc3, 0x23, 0xb3, 0xe3, 0x8c, 0x62, 0xe6, 0xb6, 0xba, 0x2d, 0x91, 0xb8, 0x5c,
-	0xa4, 0xfe, 0xe2, 0xa4, 0x3a, 0xba, 0x07, 0xe7, 0x63, 0x12, 0xee, 0xba, 0xbe, 0x43, 0xb7, 0x83,
-	0x90, 0x17, 0xd8, 0x93, 0xca, 0x04, 0x5b, 0x6f, 0x97, 0xc4, 0xd0, 0x9d, 0xdf, 0xc8, 0xc4, 0xc2,
-	0x39, 0xb5, 0xd1, 0x1d, 0x98, 0x62, 0x3b, 0xa1, 0xd6, 0xf1, 0xbc, 0x5a, 0xe0, 0xb9, 0x8d, 0xfd,
-	0xd9, 0x49, 0x46, 0xf0, 0x13, 0xf2, 0x5e, 0x58, 0x35, 0xc1, 0x47, 0x07, 0x15, 0x48, 0xfe, 0xe1,
-	0x74, 0x6d, 0xb4, 0xc9, 0x74, 0xe8, 0x9d, 0xd0, 0x8d, 0xf7, 0xe9, 0xfa, 0x25, 0x0f, 0xe2, 0xd9,
-	0xa9, 0x9e, 0xa2, 0xb0, 0x8e, 0xaa, 0x14, 0xed, 0x7a, 0x21, 0x4e, 0x13, 0xa4, 0x5b, 0x3b, 0x8a,
-	0x9b, 0xae, 0x3f, 0x3b, 0xcd, 0x4e, 0x0c, 0xb5, 0x33, 0xea, 0xb4, 0x10, 0x73, 0x18, 0xd3, 0x9f,
-	0xd3, 0x1f, 0x77, 0xe8, 0x09, 0x3a, 0xc3, 0x10, 0x13, 0xfd, 0xb9, 0x04, 0xe0, 0x04, 0x87, 0x32,
-	0x35, 0x71, 0xbc, 0x3f, 0x8b, 0x18, 0xaa, 0xda, 0x2e, 0x1b, 0x1b, 0x5f, 0xc0, 0xb4, 0x1c, 0xdd,
-	0x86, 0x11, 0xe2, 0xef, 0xad, 0x84, 0xc1, 0xee, 0xec, 0x99, 0xfc, 0x3d, 0xbb, 0xcc, 0x51, 0xf8,
-	0x81, 0x9e, 0x08, 0x78, 0xa2, 0x18, 0x4b, 0x12, 0xe8, 0x01, 0xcc, 0x66, 0xcc, 0x08, 0x9f, 0x80,
-	0xb3, 0x6c, 0x02, 0x3e, 0x2b, 0xea, 0xce, 0x6e, 0xe4, 0xe0, 0x1d, 0xf5, 0x80, 0xe1, 0x5c, 0xea,
-	0xe8, 0x8b, 0x30, 0xc1, 0x37, 0x14, 0x7f, 0x7c, 0x8b, 0x66, 0xcf, 0xb1, 0xaf, 0xb9, 0x9c, 0xbf,
-	0x39, 0x39, 0xe2, 0xe2, 0x39, 0xd1, 0xa1, 0x09, 0xbd, 0x34, 0xc2, 0x26, 0x35, 0x7b, 0x13, 0x26,
-	0xd5, 0xb9, 0xc5, 0x96, 0x0e, 0xaa, 0xc0, 0x10, 0xe3, 0x76, 0x84, 0x7e, 0xab, 0x4c, 0x67, 0x8a,
-	0x71, 0x42, 0x98, 0x97, 0xb3, 0x99, 0x72, 0xdf, 0x27, 0x8b, 0xfb, 0x31, 0xe1, 0x52, 0x75, 0x51,
-	0x9b, 0x29, 0x09, 0xc0, 0x09, 0x8e, 0xfd, 0x7f, 0x39, 0xd7, 0x98, 0x1c, 0x8e, 0x03, 0x5c, 0x07,
-	0xcf, 0xc1, 0xe8, 0x76, 0x10, 0xc5, 0x14, 0x9b, 0xb5, 0x31, 0x94, 0xf0, 0x89, 0x37, 0x45, 0x39,
-	0x56, 0x18, 0xe8, 0x35, 0x98, 0x68, 0xe8, 0x0d, 0x88, 0xbb, 0x4c, 0x0d, 0x81, 0xd1, 0x3a, 0x36,
-	0x71, 0xd1, 0xab, 0x30, 0xca, 0x9e, 0xce, 0x1b, 0x81, 0x27, 0x98, 0x2c, 0x79, 0x21, 0x8f, 0xd6,
-	0x44, 0xf9, 0x91, 0xf6, 0x1b, 0x2b, 0x6c, 0x74, 0x05, 0x86, 0x69, 0x17, 0x56, 0x6b, 0xe2, 0x16,
-	0x51, 0xaa, 0x9a, 0x9b, 0xac, 0x14, 0x0b, 0xa8, 0xfd, 0xd7, 0x0b, 0xda, 0x28, 0x53, 0x89, 0x94,
-	0xa0, 0x1a, 0x8c, 0xdc, 0x77, 0xdc, 0xd8, 0xf5, 0x5b, 0x82, 0x5d, 0x78, 0xa6, 0xe7, 0x95, 0xc2,
-	0x2a, 0xbd, 0xc5, 0x2b, 0xf0, 0x4b, 0x4f, 0xfc, 0xc1, 0x92, 0x0c, 0xa5, 0x18, 0x76, 0x7c, 0x9f,
-	0x52, 0x2c, 0x0c, 0x4a, 0x11, 0xf3, 0x0a, 0x9c, 0xa2, 0xf8, 0x83, 0x25, 0x19, 0xf4, 0x0e, 0x80,
-	0x5c, 0x96, 0xa4, 0x29, 0x9e, 0xac, 0x9f, 0xeb, 0x4f, 0x74, 0x43, 0xd5, 0x59, 0x9c, 0xa4, 0x57,
-	0x6a, 0xf2, 0x1f, 0x6b, 0xf4, 0xec, 0x98, 0xb1, 0x55, 0xdd, 0x9d, 0x41, 0xdf, 0x49, 0x4f, 0x02,
-	0x27, 0x8c, 0x49, 0x73, 0x21, 0x16, 0x83, 0xf3, 0xc9, 0xc1, 0x64, 0x8a, 0x0d, 0x77, 0x97, 0xe8,
-	0xa7, 0x86, 0x20, 0x82, 0x13, 0x7a, 0xf6, 0xaf, 0x14, 0x61, 0x36, 0xaf, 0xbb, 0x74, 0xd1, 0x91,
-	0x07, 0x6e, 0xbc, 0x44, 0xb9, 0x21, 0xcb, 0x5c, 0x74, 0xcb, 0xa2, 0x1c, 0x2b, 0x0c, 0x3a, 0xfb,
-	0x91, 0xdb, 0x92, 0x22, 0xe1, 0x50, 0x32, 0xfb, 0x75, 0x56, 0x8a, 0x05, 0x94, 0xe2, 0x85, 0xc4,
-	0x89, 0x84, 0x4d, 0x84, 0xb6, 0x4a, 0x30, 0x2b, 0xc5, 0x02, 0xaa, 0xeb, 0x9b, 0x4a, 0x7d, 0xf4,
-	0x4d, 0xc6, 0x10, 0x0d, 0x9d, 0xec, 0x10, 0xa1, 0x2f, 0x01, 0x6c, 0xb9, 0xbe, 0x1b, 0x6d, 0x33,
-	0xea, 0xc3, 0xc7, 0xa6, 0xae, 0x78, 0xa9, 0x15, 0x45, 0x05, 0x6b, 0x14, 0xd1, 0xcb, 0x30, 0xa6,
-	0x36, 0xe0, 0x6a, 0x95, 0x3d, 0x10, 0x69, 0x0f, 0xee, 0xc9, 0x69, 0x54, 0xc5, 0x3a, 0x9e, 0xfd,
-	0x6e, 0x7a, 0xbd, 0x88, 0x1d, 0xa0, 0x8d, 0xaf, 0x35, 0xe8, 0xf8, 0x16, 0x7a, 0x8f, 0xaf, 0xfd,
-	0x9b, 0x45, 0x98, 0x32, 0x1a, 0xeb, 0x44, 0x03, 0x9c, 0x59, 0x37, 0xe8, 0x3d, 0xe7, 0xc4, 0x44,
-	0xec, 0x3f, 0xbb, 0xff, 0x56, 0xd1, 0xef, 0x42, 0xba, 0x03, 0x78, 0x7d, 0xf4, 0x25, 0x28, 0x7b,
-	0x4e, 0xc4, 0x74, 0x57, 0x44, 0xec, 0xbb, 0x41, 0x88, 0x25, 0x72, 0x84, 0x13, 0xc5, 0xda, 0x55,
-	0xc3, 0x69, 0x27, 0x24, 0xe9, 0x85, 0x4c, 0x79, 0x1f, 0x69, 0x74, 0xa3, 0x3a, 0x41, 0x19, 0xa4,
-	0x7d, 0xcc, 0x61, 0xe8, 0x55, 0x18, 0x0f, 0x09, 0x5b, 0x15, 0x4b, 0x94, 0x95, 0x63, 0xcb, 0x6c,
-	0x28, 0xe1, 0xf9, 0xb0, 0x06, 0xc3, 0x06, 0x66, 0xc2, 0xca, 0x0f, 0xf7, 0x60, 0xe5, 0x9f, 0x81,
-	0x11, 0xf6, 0x43, 0xad, 0x00, 0x35, 0x1b, 0xab, 0xbc, 0x18, 0x4b, 0x78, 0x7a, 0xc1, 0x8c, 0x0e,
-	0xb8, 0x60, 0x3e, 0x09, 0x93, 0x55, 0x87, 0xec, 0x06, 0xfe, 0xb2, 0xdf, 0x6c, 0x07, 0xae, 0x1f,
-	0xa3, 0x59, 0x28, 0xb1, 0xdb, 0x81, 0xef, 0xed, 0x12, 0xa5, 0x80, 0x4b, 0x94, 0x31, 0xb7, 0x5b,
-	0x70, 0xae, 0x1a, 0xdc, 0xf7, 0xef, 0x3b, 0x61, 0x73, 0xa1, 0xb6, 0xaa, 0xc9, 0xb9, 0xeb, 0x52,
-	0xce, 0xe2, 0x46, 0x2c, 0x99, 0x67, 0xaa, 0x56, 0x93, 0xdf, 0xb5, 0x2b, 0xae, 0x47, 0x72, 0xb4,
-	0x11, 0x7f, 0xb3, 0x60, 0xb4, 0x94, 0xe0, 0xab, 0x07, 0x23, 0x2b, 0xf7, 0xc1, 0xe8, 0x4d, 0x18,
-	0xdd, 0x72, 0x89, 0xd7, 0xc4, 0x64, 0x4b, 0x2c, 0xb1, 0xa7, 0xf3, 0xdf, 0xe5, 0x57, 0x28, 0xa6,
-	0xd4, 0x3e, 0x71, 0x29, 0x6d, 0x45, 0x54, 0xc6, 0x8a, 0x0c, 0xda, 0x81, 0x69, 0x29, 0x06, 0x48,
-	0xa8, 0x58, 0x70, 0xcf, 0xf4, 0x92, 0x2d, 0x4c, 0xe2, 0x67, 0x0f, 0x0f, 0x2a, 0xd3, 0x38, 0x45,
-	0x06, 0x77, 0x11, 0xa6, 0x62, 0xd9, 0x2e, 0x3d, 0x5a, 0x4b, 0x6c, 0xf8, 0x99, 0x58, 0xc6, 0x24,
-	0x4c, 0x56, 0x6a, 0xff, 0x84, 0x05, 0x8f, 0x75, 0x8d, 0x8c, 0x90, 0xb4, 0x4f, 0x78, 0x16, 0xd2,
-	0x92, 0x6f, 0xa1, 0xbf, 0xe4, 0x6b, 0xff, 0x03, 0x0b, 0xce, 0x2e, 0xef, 0xb6, 0xe3, 0xfd, 0xaa,
-	0x6b, 0xbe, 0xee, 0xbc, 0x02, 0xc3, 0xbb, 0xa4, 0xe9, 0x76, 0x76, 0xc5, 0xcc, 0x55, 0xe4, 0xf1,
-	0xb3, 0xc6, 0x4a, 0x8f, 0x0e, 0x2a, 0x13, 0xf5, 0x38, 0x08, 0x9d, 0x16, 0xe1, 0x05, 0x58, 0xa0,
-	0xb3, 0x43, 0xdc, 0x7d, 0x9f, 0xdc, 0x76, 0x77, 0x5d, 0x69, 0x67, 0xd1, 0x53, 0x77, 0x36, 0x2f,
-	0x07, 0x74, 0xfe, 0xcd, 0x8e, 0xe3, 0xc7, 0x6e, 0xbc, 0x2f, 0x1e, 0x66, 0x24, 0x11, 0x9c, 0xd0,
-	0xb3, 0xbf, 0x69, 0xc1, 0x94, 0x5c, 0xf7, 0x0b, 0xcd, 0x66, 0x48, 0xa2, 0x08, 0xcd, 0x41, 0xc1,
-	0x6d, 0x8b, 0x5e, 0x82, 0xe8, 0x65, 0x61, 0xb5, 0x86, 0x0b, 0x6e, 0x1b, 0xd5, 0xa0, 0xcc, 0xcd,
-	0x35, 0x92, 0xc5, 0x35, 0x90, 0xd1, 0x07, 0xeb, 0xc1, 0x86, 0xac, 0x89, 0x13, 0x22, 0x92, 0x83,
-	0x63, 0x67, 0x66, 0xd1, 0x7c, 0xf5, 0xba, 0x29, 0xca, 0xb1, 0xc2, 0x40, 0x57, 0x61, 0xd4, 0x0f,
-	0x9a, 0xdc, 0x7a, 0x86, 0xdf, 0x7e, 0x6c, 0xc9, 0xae, 0x8b, 0x32, 0xac, 0xa0, 0xf6, 0x0f, 0x5b,
-	0x30, 0x2e, 0xbf, 0x6c, 0x40, 0x66, 0x92, 0x6e, 0xad, 0x84, 0x91, 0x4c, 0xb6, 0x16, 0x65, 0x06,
-	0x19, 0xc4, 0xe0, 0x01, 0x8b, 0xc7, 0xe1, 0x01, 0xed, 0x1f, 0x2f, 0xc0, 0xa4, 0xec, 0x4e, 0xbd,
-	0xb3, 0x19, 0x91, 0x18, 0x6d, 0x40, 0xd9, 0xe1, 0x43, 0x4e, 0xe4, 0x8a, 0x7d, 0x2a, 0x5b, 0xf8,
-	0x30, 0xe6, 0x27, 0xb9, 0x96, 0x17, 0x64, 0x6d, 0x9c, 0x10, 0x42, 0x1e, 0xcc, 0xf8, 0x41, 0xcc,
-	0x8e, 0x68, 0x05, 0xef, 0xf5, 0x04, 0x92, 0xa6, 0x7e, 0x41, 0x50, 0x9f, 0x59, 0x4f, 0x53, 0xc1,
-	0xdd, 0x84, 0xd1, 0xb2, 0x54, 0x78, 0x14, 0xf3, 0xc5, 0x0d, 0x7d, 0x16, 0xb2, 0xf5, 0x1d, 0xf6,
-	0xaf, 0x59, 0x50, 0x96, 0x68, 0xa7, 0xf1, 0xda, 0xb5, 0x06, 0x23, 0x11, 0x9b, 0x04, 0x39, 0x34,
-	0x76, 0xaf, 0x8e, 0xf3, 0xf9, 0x4a, 0x6e, 0x1e, 0xfe, 0x3f, 0xc2, 0x92, 0x06, 0xd3, 0x77, 0xab,
-	0xee, 0x7f, 0x44, 0xf4, 0xdd, 0xaa, 0x3f, 0x39, 0x37, 0xcc, 0x7f, 0x65, 0x7d, 0xd6, 0xc4, 0x5a,
-	0xca, 0x20, 0xb5, 0x43, 0xb2, 0xe5, 0x3e, 0x48, 0x33, 0x48, 0x35, 0x56, 0x8a, 0x05, 0x14, 0xbd,
-	0x03, 0xe3, 0x0d, 0xa9, 0xe8, 0x4c, 0x8e, 0x81, 0x2b, 0x3d, 0x95, 0xee, 0xea, 0x7d, 0x86, 0x5b,
-	0xd6, 0x2e, 0x69, 0xf5, 0xb1, 0x41, 0xcd, 0x7c, 0x6e, 0x2f, 0xf6, 0x7b, 0x6e, 0x4f, 0xe8, 0xe6,
-	0x3f, 0x3e, 0xff, 0xa4, 0x05, 0xc3, 0x5c, 0x5d, 0x36, 0x98, 0x7e, 0x51, 0x7b, 0xae, 0x4a, 0xc6,
-	0xee, 0x1e, 0x2d, 0x14, 0xcf, 0x4f, 0x68, 0x0d, 0xca, 0xec, 0x07, 0x53, 0x1b, 0x14, 0xf3, 0x4d,
-	0x8a, 0x79, 0xab, 0x7a, 0x07, 0xef, 0xc9, 0x6a, 0x38, 0xa1, 0x60, 0xff, 0x68, 0x91, 0x1e, 0x55,
-	0x09, 0xaa, 0x71, 0x83, 0x5b, 0x8f, 0xee, 0x06, 0x2f, 0x3c, 0xaa, 0x1b, 0xbc, 0x05, 0x53, 0x0d,
-	0xed, 0x71, 0x2b, 0x99, 0xc9, 0xab, 0x3d, 0x17, 0x89, 0xf6, 0x0e, 0xc6, 0x55, 0x46, 0x4b, 0x26,
-	0x11, 0x9c, 0xa6, 0x8a, 0xbe, 0x13, 0xc6, 0xf9, 0x3c, 0x8b, 0x56, 0xb8, 0xc5, 0xc2, 0x27, 0xf2,
-	0xd7, 0x8b, 0xde, 0x04, 0x5b, 0x89, 0x75, 0xad, 0x3a, 0x36, 0x88, 0xd9, 0xbf, 0x32, 0x0a, 0x43,
-	0xcb, 0x7b, 0xc4, 0x8f, 0x4f, 0xe1, 0x40, 0x6a, 0xc0, 0xa4, 0xeb, 0xef, 0x05, 0xde, 0x1e, 0x69,
-	0x72, 0xf8, 0x71, 0x2e, 0xd7, 0xf3, 0x82, 0xf4, 0xe4, 0xaa, 0x41, 0x02, 0xa7, 0x48, 0x3e, 0x0a,
-	0x09, 0xf3, 0x06, 0x0c, 0xf3, 0xb9, 0x17, 0xe2, 0x65, 0xa6, 0x32, 0x98, 0x0d, 0xa2, 0xd8, 0x05,
-	0x89, 0xf4, 0xcb, 0xb5, 0xcf, 0xa2, 0x3a, 0x7a, 0x17, 0x26, 0xb7, 0xdc, 0x30, 0x8a, 0xa9, 0x68,
-	0x18, 0xc5, 0xce, 0x6e, 0xfb, 0x21, 0x24, 0x4a, 0x35, 0x0e, 0x2b, 0x06, 0x25, 0x9c, 0xa2, 0x8c,
-	0x5a, 0x30, 0x41, 0x85, 0x9c, 0xa4, 0xa9, 0x91, 0x63, 0x37, 0xa5, 0x54, 0x46, 0xb7, 0x75, 0x42,
-	0xd8, 0xa4, 0x4b, 0x0f, 0x93, 0x06, 0x13, 0x8a, 0x46, 0x19, 0x47, 0xa1, 0x0e, 0x13, 0x2e, 0x0d,
-	0x71, 0x18, 0x3d, 0x93, 0x98, 0xd9, 0x4a, 0xd9, 0x3c, 0x93, 0x34, 0xe3, 0x94, 0x2f, 0x43, 0x99,
-	0xd0, 0x21, 0xa4, 0x84, 0x85, 0x62, 0xfc, 0xda, 0x60, 0x7d, 0x5d, 0x73, 0x1b, 0x61, 0x60, 0xca,
-	0xf2, 0xcb, 0x92, 0x12, 0x4e, 0x88, 0xa2, 0x25, 0x18, 0x8e, 0x48, 0xe8, 0x92, 0x48, 0xa8, 0xc8,
-	0x7b, 0x4c, 0x23, 0x43, 0xe3, 0xb6, 0xe7, 0xfc, 0x37, 0x16, 0x55, 0xe9, 0xf2, 0x72, 0x98, 0x34,
-	0xc4, 0xb4, 0xe2, 0xda, 0xf2, 0x5a, 0x60, 0xa5, 0x58, 0x40, 0xd1, 0x1b, 0x30, 0x12, 0x12, 0x8f,
-	0x29, 0x8b, 0x26, 0x06, 0x5f, 0xe4, 0x5c, 0xf7, 0xc4, 0xeb, 0x61, 0x49, 0x00, 0xdd, 0x02, 0x14,
-	0x12, 0xca, 0x43, 0xb8, 0x7e, 0x4b, 0x19, 0x73, 0x08, 0x5d, 0xf7, 0xe3, 0xa2, 0xfd, 0x33, 0x38,
-	0xc1, 0x90, 0x56, 0xa9, 0x38, 0xa3, 0x1a, 0xba, 0x01, 0x33, 0xaa, 0x74, 0xd5, 0x8f, 0x62, 0xc7,
-	0x6f, 0x10, 0xa6, 0xe6, 0x2e, 0x27, 0x5c, 0x11, 0x4e, 0x23, 0xe0, 0xee, 0x3a, 0xf6, 0xcf, 0x51,
-	0x76, 0x86, 0x8e, 0xd6, 0x29, 0xf0, 0x02, 0xaf, 0x9b, 0xbc, 0xc0, 0x85, 0xdc, 0x99, 0xcb, 0xe1,
-	0x03, 0x0e, 0x2d, 0x18, 0xd3, 0x66, 0x36, 0x59, 0xb3, 0x56, 0x8f, 0x35, 0xdb, 0x81, 0x69, 0xba,
-	0xd2, 0xef, 0x6c, 0x46, 0x24, 0xdc, 0x23, 0x4d, 0xb6, 0x30, 0x0b, 0x0f, 0xb7, 0x30, 0xd5, 0x2b,
-	0xf3, 0xed, 0x14, 0x41, 0xdc, 0xd5, 0x04, 0x7a, 0x45, 0x6a, 0x4e, 0x8a, 0x86, 0x91, 0x16, 0xd7,
-	0x8a, 0x1c, 0x1d, 0x54, 0xa6, 0xb5, 0x0f, 0xd1, 0x35, 0x25, 0xf6, 0x97, 0xe5, 0x37, 0xaa, 0xd7,
-	0xfc, 0x86, 0x5a, 0x2c, 0xa9, 0xd7, 0x7c, 0xb5, 0x1c, 0x70, 0x82, 0x43, 0xf7, 0x28, 0x15, 0x41,
-	0xd2, 0xaf, 0xf9, 0x54, 0x40, 0xc1, 0x0c, 0x62, 0xbf, 0x08, 0xb0, 0xfc, 0x80, 0x34, 0xf8, 0x52,
-	0xd7, 0x1f, 0x20, 0xad, 0xfc, 0x07, 0x48, 0xfb, 0xdf, 0x5b, 0x30, 0xb9, 0xb2, 0x64, 0x88, 0x89,
-	0xf3, 0x00, 0x5c, 0x36, 0x7a, 0xeb, 0xad, 0x75, 0xa9, 0x5b, 0xe7, 0xea, 0x51, 0x55, 0x8a, 0x35,
-	0x0c, 0x74, 0x01, 0x8a, 0x5e, 0xc7, 0x17, 0x22, 0xcb, 0xc8, 0xe1, 0x41, 0xa5, 0x78, 0xbb, 0xe3,
-	0x63, 0x5a, 0xa6, 0x59, 0x08, 0x16, 0x07, 0xb6, 0x10, 0xec, 0xeb, 0x5e, 0x85, 0x2a, 0x30, 0x74,
-	0xff, 0xbe, 0xdb, 0xe4, 0x46, 0xec, 0x42, 0xef, 0xff, 0xd6, 0x5b, 0xab, 0xd5, 0x08, 0xf3, 0x72,
-	0xfb, 0xab, 0x45, 0x98, 0x5b, 0xf1, 0xc8, 0x83, 0x0f, 0x68, 0xc8, 0x3f, 0xa8, 0x7d, 0xe3, 0xf1,
-	0xf8, 0xc5, 0xe3, 0xda, 0xb0, 0xf6, 0x1f, 0x8f, 0x2d, 0x18, 0xe1, 0x8f, 0xd9, 0xd2, 0xac, 0xff,
-	0xb5, 0xac, 0xd6, 0xf3, 0x07, 0x64, 0x9e, 0x3f, 0x8a, 0x0b, 0x73, 0x7e, 0x75, 0xd3, 0x8a, 0x52,
-	0x2c, 0x89, 0xcf, 0x7d, 0x06, 0xc6, 0x75, 0xcc, 0x63, 0x59, 0x93, 0xff, 0xa5, 0x22, 0x4c, 0xd3,
-	0x1e, 0x3c, 0xd2, 0x89, 0xb8, 0xdb, 0x3d, 0x11, 0x27, 0x6d, 0x51, 0xdc, 0x7f, 0x36, 0xde, 0x49,
-	0xcf, 0xc6, 0x0b, 0x79, 0xb3, 0x71, 0xda, 0x73, 0xf0, 0xbd, 0x16, 0x9c, 0x59, 0xf1, 0x82, 0xc6,
-	0x4e, 0xca, 0xea, 0xf7, 0x65, 0x18, 0xa3, 0xe7, 0x78, 0x64, 0x78, 0x11, 0x19, 0x7e, 0x65, 0x02,
-	0x84, 0x75, 0x3c, 0xad, 0xda, 0xdd, 0xbb, 0xab, 0xd5, 0x2c, 0x77, 0x34, 0x01, 0xc2, 0x3a, 0x9e,
-	0xfd, 0x0d, 0x0b, 0x2e, 0xde, 0x58, 0x5a, 0x4e, 0x96, 0x62, 0x97, 0x47, 0x1c, 0x95, 0x02, 0x9b,
-	0x5a, 0x57, 0x12, 0x29, 0xb0, 0xca, 0x7a, 0x21, 0xa0, 0x1f, 0x15, 0x6f, 0xcf, 0x9f, 0xb5, 0xe0,
-	0xcc, 0x0d, 0x37, 0xa6, 0xd7, 0x72, 0xda, 0x37, 0x8b, 0xde, 0xcb, 0x91, 0x1b, 0x07, 0xe1, 0x7e,
-	0xda, 0x37, 0x0b, 0x2b, 0x08, 0xd6, 0xb0, 0x78, 0xcb, 0x7b, 0x2e, 0x33, 0xa3, 0x2a, 0x98, 0xaa,
-	0x28, 0x2c, 0xca, 0xb1, 0xc2, 0xa0, 0x1f, 0xd6, 0x74, 0x43, 0x26, 0x4a, 0xec, 0x8b, 0x13, 0x56,
-	0x7d, 0x58, 0x55, 0x02, 0x70, 0x82, 0x63, 0xff, 0x84, 0x05, 0xe7, 0x6e, 0x78, 0x9d, 0x28, 0x26,
-	0xe1, 0x56, 0x64, 0x74, 0xf6, 0x45, 0x28, 0x13, 0x29, 0xae, 0x8b, 0xbe, 0x2a, 0x06, 0x53, 0xc9,
-	0xf1, 0xdc, 0x31, 0x4c, 0xe1, 0x0d, 0xe0, 0x39, 0x70, 0x3c, 0xd7, 0xb1, 0x5f, 0x2c, 0xc0, 0xc4,
-	0xcd, 0x8d, 0x8d, 0xda, 0x0d, 0x12, 0x8b, 0x5b, 0xac, 0xbf, 0xaa, 0x19, 0x6b, 0x1a, 0xb3, 0x5e,
-	0x42, 0x51, 0x27, 0x76, 0xbd, 0x79, 0xee, 0x89, 0x3c, 0xbf, 0xea, 0xc7, 0x77, 0xc2, 0x7a, 0x1c,
-	0xba, 0x7e, 0x2b, 0x53, 0xc7, 0x26, 0xef, 0xda, 0x62, 0xde, 0x5d, 0x8b, 0x5e, 0x84, 0x61, 0xe6,
-	0x0a, 0x2d, 0xc5, 0x93, 0xc7, 0x95, 0x4c, 0xc1, 0x4a, 0x8f, 0x0e, 0x2a, 0xe5, 0xbb, 0x78, 0x95,
-	0xff, 0xc1, 0x02, 0x15, 0xdd, 0x85, 0xb1, 0xed, 0x38, 0x6e, 0xdf, 0x24, 0x4e, 0x93, 0x84, 0xf2,
-	0x74, 0xb8, 0x94, 0x75, 0x3a, 0xd0, 0x41, 0xe0, 0x68, 0xc9, 0x86, 0x4a, 0xca, 0x22, 0xac, 0xd3,
-	0xb1, 0xeb, 0x00, 0x09, 0xec, 0x84, 0xf4, 0x0b, 0xf6, 0x1f, 0x58, 0x30, 0xc2, 0xbd, 0xd2, 0x42,
-	0xf4, 0x59, 0x28, 0x91, 0x07, 0xa4, 0x21, 0x38, 0xc7, 0xcc, 0x0e, 0x27, 0x8c, 0x07, 0xd7, 0x96,
-	0xd3, 0xff, 0x98, 0xd5, 0x42, 0x37, 0x61, 0x84, 0xf6, 0xf6, 0x86, 0x72, 0xd1, 0x7b, 0x32, 0xef,
-	0x8b, 0xd5, 0xb4, 0x73, 0x5e, 0x45, 0x14, 0x61, 0x59, 0x9d, 0x69, 0x7e, 0x1b, 0xed, 0x3a, 0x3d,
-	0xc0, 0xe2, 0x5e, 0xf7, 0xec, 0xc6, 0x52, 0x8d, 0x23, 0x09, 0x6a, 0x5c, 0xf3, 0x2b, 0x0b, 0x71,
-	0x42, 0xc4, 0xde, 0x80, 0x32, 0x9d, 0xd4, 0x05, 0xcf, 0x75, 0x7a, 0x2b, 0x9d, 0x9f, 0x85, 0xb2,
-	0x54, 0x00, 0x47, 0xc2, 0xb1, 0x89, 0x51, 0x95, 0xfa, 0xe1, 0x08, 0x27, 0x70, 0x7b, 0x0b, 0xce,
-	0xb2, 0x97, 0x7f, 0x27, 0xde, 0x36, 0xf6, 0x58, 0xff, 0xc5, 0xfc, 0x9c, 0x10, 0xc4, 0xf8, 0xcc,
-	0xcc, 0x6a, 0xbe, 0x03, 0xe3, 0x92, 0x62, 0x22, 0x94, 0xd9, 0x7f, 0x54, 0x82, 0xc7, 0x57, 0xeb,
-	0xf9, 0x0e, 0x8b, 0xaf, 0xc2, 0x38, 0x67, 0xd3, 0xe8, 0xd2, 0x76, 0x3c, 0xd1, 0xae, 0x7a, 0x17,
-	0xdb, 0xd0, 0x60, 0xd8, 0xc0, 0x44, 0x17, 0xa1, 0xe8, 0xbe, 0xe7, 0xa7, 0xcd, 0x70, 0x57, 0xdf,
-	0x5c, 0xc7, 0xb4, 0x9c, 0x82, 0x29, 0xc7, 0xc7, 0x8f, 0x52, 0x05, 0x56, 0x5c, 0xdf, 0xeb, 0x30,
-	0xe9, 0x46, 0x8d, 0xc8, 0x5d, 0xf5, 0xe9, 0x39, 0x93, 0x38, 0xbb, 0x26, 0x4a, 0x02, 0xda, 0x69,
-	0x05, 0xc5, 0x29, 0x6c, 0xed, 0x5c, 0x1f, 0x1a, 0x98, 0x6b, 0xec, 0xeb, 0xe9, 0x43, 0x19, 0xe2,
-	0x36, 0xfb, 0xba, 0x88, 0x19, 0xb5, 0x09, 0x86, 0x98, 0x7f, 0x70, 0x84, 0x25, 0x8c, 0x4a, 0x60,
-	0x8d, 0x6d, 0xa7, 0xbd, 0xd0, 0x89, 0xb7, 0xab, 0x6e, 0xd4, 0x08, 0xf6, 0x48, 0xb8, 0xcf, 0x84,
-	0xe7, 0xd1, 0x44, 0x02, 0x53, 0x80, 0xa5, 0x9b, 0x0b, 0x35, 0x8a, 0x89, 0xbb, 0xeb, 0x98, 0x5c,
-	0x21, 0x9c, 0x04, 0x57, 0xb8, 0x00, 0x53, 0xb2, 0x99, 0x3a, 0x89, 0xd8, 0x1d, 0x31, 0xc6, 0x3a,
-	0xa6, 0x4c, 0x6d, 0x45, 0xb1, 0xea, 0x56, 0x1a, 0x1f, 0xbd, 0x02, 0x13, 0xae, 0xef, 0xc6, 0xae,
-	0x13, 0x07, 0x21, 0xbb, 0x61, 0xb9, 0x9c, 0xcc, 0x2c, 0xd9, 0x56, 0x75, 0x00, 0x36, 0xf1, 0xec,
-	0x3f, 0x2c, 0xc1, 0x0c, 0x9b, 0xb6, 0x6f, 0xad, 0xb0, 0x8f, 0xcc, 0x0a, 0xbb, 0xdb, 0xbd, 0xc2,
-	0x4e, 0x82, 0xdd, 0xfd, 0x30, 0x97, 0xd9, 0xbb, 0x50, 0x56, 0xb6, 0xc0, 0xd2, 0x19, 0xc0, 0xca,
-	0x71, 0x06, 0xe8, 0xcf, 0x7d, 0xc8, 0x67, 0xdc, 0x62, 0xe6, 0x33, 0xee, 0xdf, 0xb6, 0x20, 0x31,
-	0x89, 0x44, 0x37, 0xa1, 0xdc, 0x0e, 0x98, 0xd9, 0x41, 0x28, 0x6d, 0x79, 0x1e, 0xcf, 0xbc, 0xa8,
-	0xf8, 0xa5, 0xc8, 0xc7, 0xaf, 0x26, 0x6b, 0xe0, 0xa4, 0x32, 0x5a, 0x84, 0x91, 0x76, 0x48, 0xea,
-	0x31, 0x73, 0x81, 0xed, 0x4b, 0x87, 0xaf, 0x11, 0x8e, 0x8f, 0x65, 0x45, 0xfb, 0x97, 0x2c, 0x00,
-	0xfe, 0x52, 0xea, 0xf8, 0x2d, 0x72, 0x0a, 0xda, 0xdf, 0x2a, 0x94, 0xa2, 0x36, 0x69, 0xf4, 0x32,
-	0x08, 0x49, 0xfa, 0x53, 0x6f, 0x93, 0x46, 0x32, 0xe0, 0xf4, 0x1f, 0x66, 0xb5, 0xed, 0xef, 0x03,
-	0x98, 0x4c, 0xd0, 0x56, 0x63, 0xb2, 0x8b, 0x9e, 0x37, 0x5c, 0xe2, 0x2e, 0xa4, 0x5c, 0xe2, 0xca,
-	0x0c, 0x5b, 0x53, 0x34, 0xbe, 0x0b, 0xc5, 0x5d, 0xe7, 0x81, 0xd0, 0x24, 0x3d, 0xdb, 0xbb, 0x1b,
-	0x94, 0xfe, 0xfc, 0x9a, 0xf3, 0x80, 0xcb, 0x4c, 0xcf, 0xca, 0x05, 0xb2, 0xe6, 0x3c, 0x38, 0xe2,
-	0x66, 0x1f, 0xec, 0x90, 0xba, 0xed, 0x46, 0xf1, 0x57, 0xfe, 0x53, 0xf2, 0x9f, 0x2d, 0x3b, 0xda,
-	0x08, 0x6b, 0xcb, 0xf5, 0xc5, 0xbb, 0xe1, 0x40, 0x6d, 0xb9, 0x7e, 0xba, 0x2d, 0xd7, 0x1f, 0xa0,
-	0x2d, 0xd7, 0x47, 0xef, 0xc3, 0x88, 0x78, 0xa3, 0x67, 0xb6, 0xde, 0xa6, 0x96, 0x2a, 0xaf, 0x3d,
-	0xf1, 0xc4, 0xcf, 0xdb, 0xbc, 0x26, 0x65, 0x42, 0x51, 0xda, 0xb7, 0x5d, 0xd9, 0x20, 0xfa, 0x1b,
-	0x16, 0x4c, 0x8a, 0xdf, 0x98, 0xbc, 0xd7, 0x21, 0x51, 0x2c, 0x78, 0xcf, 0x4f, 0x0f, 0xde, 0x07,
-	0x51, 0x91, 0x77, 0xe5, 0xd3, 0xf2, 0x98, 0x35, 0x81, 0x7d, 0x7b, 0x94, 0xea, 0x05, 0xfa, 0x47,
-	0x16, 0x9c, 0xdd, 0x75, 0x1e, 0xf0, 0x16, 0x79, 0x19, 0x76, 0x62, 0x37, 0x10, 0xb6, 0xeb, 0x9f,
-	0x1d, 0x6c, 0xfa, 0xbb, 0xaa, 0xf3, 0x4e, 0x4a, 0x33, 0xd7, 0xb3, 0x59, 0x28, 0x7d, 0xbb, 0x9a,
-	0xd9, 0xaf, 0xb9, 0x2d, 0x18, 0x95, 0xeb, 0x2d, 0x43, 0xf2, 0xae, 0xea, 0x8c, 0xf5, 0xb1, 0x4d,
-	0x24, 0x74, 0xbf, 0x34, 0xda, 0x8e, 0x58, 0x6b, 0x8f, 0xb4, 0x9d, 0x77, 0x61, 0x5c, 0x5f, 0x63,
-	0x8f, 0xb4, 0xad, 0xf7, 0xe0, 0x4c, 0xc6, 0x5a, 0x7a, 0xa4, 0x4d, 0xde, 0x87, 0x0b, 0xb9, 0xeb,
-	0xe3, 0x51, 0x36, 0x6c, 0xff, 0xa2, 0xa5, 0x9f, 0x83, 0xa7, 0xa0, 0x82, 0x5f, 0x32, 0x55, 0xf0,
-	0x97, 0x7a, 0xef, 0x9c, 0x1c, 0x3d, 0xfc, 0x3b, 0x7a, 0xa7, 0xe9, 0xa9, 0x8e, 0xde, 0x80, 0x61,
-	0x8f, 0x96, 0x48, 0xe3, 0x10, 0xbb, 0xff, 0x8e, 0x4c, 0x78, 0x29, 0x56, 0x1e, 0x61, 0x41, 0xc1,
-	0xfe, 0x55, 0x0b, 0x4a, 0xa7, 0x30, 0x12, 0xd8, 0x1c, 0x89, 0xe7, 0x73, 0x49, 0x8b, 0x90, 0x66,
-	0xf3, 0xd8, 0xb9, 0xbf, 0xfc, 0x20, 0x26, 0x7e, 0xc4, 0x44, 0xc5, 0xcc, 0x81, 0xf9, 0x2e, 0x38,
-	0x73, 0x3b, 0x70, 0x9a, 0x8b, 0x8e, 0xe7, 0xf8, 0x0d, 0x12, 0xae, 0xfa, 0xad, 0xbe, 0x56, 0x4a,
-	0xba, 0x4d, 0x51, 0xa1, 0x9f, 0x4d, 0x91, 0xbd, 0x0d, 0x48, 0x6f, 0x40, 0xd8, 0x71, 0x62, 0x18,
-	0x71, 0x79, 0x53, 0x62, 0xf8, 0x9f, 0xce, 0xe6, 0xee, 0xba, 0x7a, 0xa6, 0x59, 0x28, 0xf2, 0x02,
-	0x2c, 0x09, 0xd9, 0xaf, 0x42, 0xa6, 0xef, 0x56, 0x7f, 0xb5, 0x81, 0xfd, 0x32, 0xcc, 0xb0, 0x9a,
-	0xc7, 0x13, 0x69, 0xed, 0x1f, 0xb0, 0x60, 0x6a, 0x3d, 0x15, 0x9b, 0xe2, 0x0a, 0x7b, 0xeb, 0xcb,
-	0xd0, 0xfb, 0xd6, 0x59, 0x29, 0x16, 0xd0, 0x13, 0xd7, 0x2f, 0xfd, 0x99, 0x05, 0x89, 0xab, 0xe4,
-	0x29, 0x30, 0x55, 0x4b, 0x06, 0x53, 0x95, 0xa9, 0xf7, 0x50, 0xdd, 0xc9, 0xe3, 0xa9, 0xd0, 0x2d,
-	0x15, 0x17, 0xa0, 0x87, 0xca, 0x23, 0x21, 0xc3, 0xbd, 0xc8, 0x27, 0xcd, 0xe0, 0x01, 0x32, 0x52,
-	0x00, 0x33, 0x13, 0x52, 0xb8, 0x1f, 0x11, 0x33, 0x21, 0xd5, 0x9f, 0x9c, 0xdd, 0x57, 0xd3, 0xba,
-	0xcc, 0x4e, 0xa5, 0x6f, 0x67, 0x66, 0xdf, 0x8e, 0xe7, 0xbe, 0x4f, 0x54, 0x70, 0x93, 0x8a, 0x30,
-	0xe3, 0x16, 0xa5, 0x47, 0x07, 0x95, 0x09, 0xf5, 0x8f, 0x47, 0xc0, 0x4a, 0xaa, 0xd8, 0x37, 0x61,
-	0x2a, 0x35, 0x60, 0xe8, 0x65, 0x18, 0x6a, 0x6f, 0x3b, 0x11, 0x49, 0x99, 0x46, 0x0e, 0xd5, 0x68,
-	0xe1, 0xd1, 0x41, 0x65, 0x52, 0x55, 0x60, 0x25, 0x98, 0x63, 0xdb, 0xff, 0xd3, 0x82, 0xd2, 0x7a,
-	0xd0, 0x3c, 0x8d, 0xc5, 0xf4, 0xba, 0xb1, 0x98, 0x9e, 0xc8, 0x8b, 0x1f, 0x98, 0xbb, 0x8e, 0x56,
-	0x52, 0xeb, 0xe8, 0x52, 0x2e, 0x85, 0xde, 0x4b, 0x68, 0x17, 0xc6, 0x58, 0x54, 0x42, 0x61, 0xaa,
-	0xf9, 0xa2, 0xc1, 0xdf, 0x57, 0x52, 0xfc, 0xfd, 0x94, 0x86, 0xaa, 0x71, 0xf9, 0xcf, 0xc0, 0x88,
-	0x30, 0x17, 0x4c, 0x1b, 0xb8, 0x0b, 0x5c, 0x2c, 0xe1, 0xf6, 0x4f, 0x16, 0xc1, 0x88, 0x82, 0x88,
-	0x7e, 0xcd, 0x82, 0xf9, 0x90, 0x7b, 0x0c, 0x36, 0xab, 0x9d, 0xd0, 0xf5, 0x5b, 0xf5, 0xc6, 0x36,
-	0x69, 0x76, 0x3c, 0xd7, 0x6f, 0xad, 0xb6, 0xfc, 0x40, 0x15, 0x2f, 0x3f, 0x20, 0x8d, 0x0e, 0xd3,
-	0xf9, 0xf7, 0x09, 0xb9, 0xa8, 0xcc, 0x71, 0xae, 0x1f, 0x1e, 0x54, 0xe6, 0xf1, 0xb1, 0x68, 0xe3,
-	0x63, 0xf6, 0x05, 0x7d, 0xc3, 0x82, 0x6b, 0x3c, 0x38, 0xe0, 0xe0, 0xfd, 0xef, 0x21, 0x0d, 0xd5,
-	0x24, 0xa9, 0x84, 0xc8, 0x06, 0x09, 0x77, 0x17, 0x5f, 0x11, 0x03, 0x7a, 0xad, 0x76, 0xbc, 0xb6,
-	0xf0, 0x71, 0x3b, 0x67, 0xff, 0xcb, 0x22, 0x4c, 0x08, 0x67, 0x75, 0x11, 0x05, 0xe5, 0x65, 0x63,
-	0x49, 0x3c, 0x99, 0x5a, 0x12, 0x33, 0x06, 0xf2, 0xc9, 0x04, 0x40, 0x89, 0x60, 0xc6, 0x73, 0xa2,
-	0xf8, 0x26, 0x71, 0xc2, 0x78, 0x93, 0x38, 0xdc, 0x4c, 0xa5, 0x78, 0x6c, 0x93, 0x1a, 0xa5, 0x7e,
-	0xb9, 0x9d, 0x26, 0x86, 0xbb, 0xe9, 0xa3, 0x3d, 0x40, 0xcc, 0xd6, 0x26, 0x74, 0xfc, 0x88, 0x7f,
-	0x8b, 0x2b, 0xde, 0x03, 0x8e, 0xd7, 0xea, 0x9c, 0x68, 0x15, 0xdd, 0xee, 0xa2, 0x86, 0x33, 0x5a,
-	0xd0, 0x6c, 0xa8, 0x86, 0x06, 0xb5, 0xa1, 0x1a, 0xee, 0xe3, 0x45, 0xe2, 0xc3, 0x74, 0x57, 0xbc,
-	0x81, 0xb7, 0xa1, 0xac, 0x6c, 0xdd, 0xc4, 0xa1, 0xd3, 0x3b, 0x6c, 0x47, 0x9a, 0x02, 0x57, 0x91,
-	0x24, 0x76, 0x96, 0x09, 0x39, 0xfb, 0x1f, 0x17, 0x8c, 0x06, 0xf9, 0x24, 0xae, 0xc3, 0xa8, 0x13,
-	0x45, 0x6e, 0xcb, 0x27, 0x4d, 0xb1, 0x63, 0x3f, 0x9e, 0xb7, 0x63, 0x8d, 0x66, 0x98, 0xbd, 0xe1,
-	0x82, 0xa8, 0x89, 0x15, 0x0d, 0x74, 0x93, 0x1b, 0x03, 0xed, 0x49, 0x7e, 0x7e, 0x30, 0x6a, 0x20,
-	0xcd, 0x85, 0xf6, 0x08, 0x16, 0xf5, 0xd1, 0x17, 0xb9, 0xb5, 0xd6, 0x2d, 0x3f, 0xb8, 0xef, 0xdf,
-	0x08, 0x02, 0xe9, 0x61, 0x36, 0x18, 0xc1, 0x19, 0x69, 0xa3, 0xa5, 0xaa, 0x63, 0x93, 0xda, 0x60,
-	0x31, 0x79, 0xbe, 0x1b, 0xce, 0x50, 0xd2, 0xa6, 0x9f, 0x48, 0x84, 0x08, 0x4c, 0x89, 0x48, 0x08,
-	0xb2, 0x4c, 0x8c, 0x5d, 0x26, 0xab, 0x6e, 0xd6, 0x4e, 0x14, 0x7a, 0xb7, 0x4c, 0x12, 0x38, 0x4d,
-	0xd3, 0xfe, 0x19, 0x0b, 0x98, 0x85, 0xfb, 0x29, 0xb0, 0x0c, 0x9f, 0x33, 0x59, 0x86, 0xd9, 0xbc,
-	0x41, 0xce, 0xe1, 0x16, 0x5e, 0xe2, 0x2b, 0xab, 0x16, 0x06, 0x0f, 0xf6, 0xc5, 0x4b, 0xf9, 0x00,
-	0x5c, 0xea, 0xff, 0xb1, 0xf8, 0x21, 0xa6, 0x9c, 0xce, 0xd1, 0xf7, 0xc0, 0x68, 0xc3, 0x69, 0x3b,
-	0x0d, 0x1e, 0xb2, 0x37, 0x57, 0x63, 0x63, 0x54, 0x9a, 0x5f, 0x12, 0x35, 0xb8, 0x06, 0x42, 0x46,
-	0xd4, 0x18, 0x95, 0xc5, 0x7d, 0xb5, 0x0e, 0xaa, 0xc9, 0xb9, 0x1d, 0x98, 0x30, 0x88, 0x3d, 0x52,
-	0x71, 0xf5, 0x7b, 0xf8, 0x15, 0xab, 0x22, 0xc0, 0xec, 0xc2, 0x8c, 0xaf, 0xfd, 0xa7, 0x17, 0x8a,
-	0x14, 0x41, 0x3e, 0xde, 0xef, 0x12, 0x65, 0xb7, 0x8f, 0x66, 0xc1, 0x9f, 0x22, 0x83, 0xbb, 0x29,
-	0xdb, 0x3f, 0x65, 0xc1, 0x63, 0x3a, 0xa2, 0x16, 0x0f, 0xa0, 0x9f, 0x0e, 0xb8, 0x0a, 0xa3, 0x41,
-	0x9b, 0x84, 0x4e, 0x1c, 0x84, 0xe2, 0xd6, 0xb8, 0x2a, 0x07, 0xfd, 0x8e, 0x28, 0x3f, 0x12, 0xb1,
-	0x13, 0x25, 0x75, 0x59, 0x8e, 0x55, 0x4d, 0x64, 0xc3, 0x30, 0x1b, 0x8c, 0x48, 0xc4, 0x6a, 0x60,
-	0x67, 0x00, 0x7b, 0x0e, 0x8d, 0xb0, 0x80, 0xd8, 0x7f, 0x64, 0xf1, 0x85, 0xa5, 0x77, 0x1d, 0xbd,
-	0x07, 0xd3, 0xbb, 0x4e, 0xdc, 0xd8, 0x5e, 0x7e, 0xd0, 0x0e, 0xb9, 0xea, 0x5b, 0x8e, 0xd3, 0xb3,
-	0xfd, 0xc6, 0x49, 0xfb, 0xc8, 0xc4, 0x00, 0x6d, 0x2d, 0x45, 0x0c, 0x77, 0x91, 0x47, 0x9b, 0x30,
-	0xc6, 0xca, 0x98, 0xa5, 0x73, 0xd4, 0x8b, 0x35, 0xc8, 0x6b, 0x4d, 0xbd, 0x28, 0xaf, 0x25, 0x74,
-	0xb0, 0x4e, 0xd4, 0xfe, 0x4a, 0x91, 0xef, 0x76, 0xc6, 0x6d, 0x3f, 0x03, 0x23, 0xed, 0xa0, 0xb9,
-	0xb4, 0x5a, 0xc5, 0x62, 0x16, 0xd4, 0x35, 0x52, 0xe3, 0xc5, 0x58, 0xc2, 0xd1, 0x6b, 0x00, 0xe4,
-	0x41, 0x4c, 0x42, 0xdf, 0xf1, 0x94, 0x41, 0x88, 0x32, 0x81, 0xac, 0x06, 0xeb, 0x41, 0x7c, 0x37,
-	0x22, 0xdf, 0xb5, 0xac, 0x50, 0xb0, 0x86, 0x8e, 0xae, 0x03, 0xb4, 0xc3, 0x60, 0xcf, 0x6d, 0x32,
-	0xd7, 0xb9, 0xa2, 0x69, 0x2e, 0x51, 0x53, 0x10, 0xac, 0x61, 0xa1, 0xd7, 0x60, 0xa2, 0xe3, 0x47,
-	0x9c, 0x43, 0x71, 0x36, 0x45, 0xe4, 0xc1, 0xd1, 0xc4, 0x72, 0xe1, 0xae, 0x0e, 0xc4, 0x26, 0x2e,
-	0x5a, 0x80, 0xe1, 0xd8, 0x61, 0xf6, 0x0e, 0x43, 0xf9, 0x76, 0x8b, 0x1b, 0x14, 0x43, 0x0f, 0x18,
-	0x4b, 0x2b, 0x60, 0x51, 0x11, 0xbd, 0x2d, 0xfd, 0x10, 0xf8, 0x59, 0x2f, 0x0c, 0x86, 0x07, 0xbb,
-	0x17, 0x34, 0x2f, 0x04, 0x61, 0x88, 0x6c, 0xd0, 0xb2, 0xbf, 0x51, 0x06, 0x48, 0xd8, 0x71, 0xf4,
-	0x7e, 0xd7, 0x79, 0xf4, 0x5c, 0x6f, 0x06, 0xfe, 0xe4, 0x0e, 0x23, 0xf4, 0xfd, 0x16, 0x8c, 0x39,
-	0x9e, 0x17, 0x34, 0x9c, 0x98, 0x8d, 0x72, 0xa1, 0xf7, 0x79, 0x28, 0xda, 0x5f, 0x48, 0x6a, 0xf0,
-	0x2e, 0xbc, 0x28, 0x17, 0x9e, 0x06, 0xe9, 0xdb, 0x0b, 0xbd, 0x61, 0xf4, 0x29, 0x29, 0xa5, 0xf1,
-	0xe5, 0x31, 0x97, 0x96, 0xd2, 0xca, 0xec, 0xe8, 0xd7, 0x04, 0x34, 0x74, 0xd7, 0x08, 0x2a, 0x57,
-	0xca, 0x8f, 0xaf, 0x60, 0x70, 0xa5, 0xfd, 0xe2, 0xc9, 0xa1, 0x9a, 0xee, 0x38, 0x35, 0x94, 0x1f,
-	0x84, 0x44, 0x13, 0x7f, 0xfa, 0x38, 0x4d, 0xbd, 0x0b, 0x53, 0x4d, 0xf3, 0x6e, 0x17, 0xab, 0xe9,
-	0xe9, 0x3c, 0xba, 0x29, 0x56, 0x20, 0xb9, 0xcd, 0x53, 0x00, 0x9c, 0x26, 0x8c, 0x6a, 0xdc, 0x85,
-	0x6d, 0xd5, 0xdf, 0x0a, 0x84, 0xe1, 0xb9, 0x9d, 0x3b, 0x97, 0xfb, 0x51, 0x4c, 0x76, 0x29, 0x66,
-	0x72, 0x69, 0xaf, 0x8b, 0xba, 0x58, 0x51, 0x41, 0x6f, 0xc0, 0x30, 0xf3, 0x81, 0x8d, 0x66, 0x47,
-	0xf3, 0x15, 0x85, 0x66, 0xf8, 0x86, 0x64, 0x53, 0xb1, 0xbf, 0x11, 0x16, 0x14, 0xd0, 0x4d, 0x19,
-	0xe3, 0x25, 0x5a, 0xf5, 0xef, 0x46, 0x84, 0xc5, 0x78, 0x29, 0x2f, 0x7e, 0x3c, 0x09, 0xdf, 0xc2,
-	0xcb, 0x33, 0x43, 0xc3, 0x1b, 0x35, 0x29, 0x73, 0x24, 0xfe, 0xcb, 0x88, 0xf3, 0xb3, 0x90, 0xdf,
-	0x3d, 0x33, 0x2a, 0x7d, 0x32, 0x9c, 0xf7, 0x4c, 0x12, 0x38, 0x4d, 0x93, 0x32, 0x9a, 0x7c, 0xe7,
-	0x0a, 0xd3, 0xf5, 0x7e, 0xfb, 0x9f, 0xcb, 0xd7, 0xec, 0x92, 0xe1, 0x25, 0x58, 0xd4, 0x3f, 0xd5,
-	0x5b, 0x7f, 0xce, 0x87, 0xe9, 0xf4, 0x16, 0x7d, 0xa4, 0x5c, 0xc6, 0x1f, 0x94, 0x60, 0xd2, 0x5c,
-	0x52, 0xe8, 0x1a, 0x94, 0x05, 0x11, 0x15, 0x70, 0x54, 0xed, 0x92, 0x35, 0x09, 0xc0, 0x09, 0x0e,
-	0x8b, 0x33, 0xcb, 0xaa, 0x6b, 0x26, 0x87, 0x49, 0x9c, 0x59, 0x05, 0xc1, 0x1a, 0x16, 0x95, 0x97,
-	0x36, 0x83, 0x20, 0x56, 0x97, 0x8a, 0x5a, 0x77, 0x8b, 0xac, 0x14, 0x0b, 0x28, 0xbd, 0x4c, 0x76,
-	0x48, 0xe8, 0x13, 0xcf, 0x8c, 0x63, 0xa6, 0x2e, 0x93, 0x5b, 0x3a, 0x10, 0x9b, 0xb8, 0xf4, 0x96,
-	0x0c, 0x22, 0xb6, 0x90, 0x85, 0x54, 0x96, 0x98, 0x70, 0xd6, 0xb9, 0x37, 0xb9, 0x84, 0xa3, 0x2f,
-	0xc0, 0x63, 0xca, 0xf9, 0x1b, 0x73, 0x25, 0xb4, 0x6c, 0x71, 0xd8, 0x50, 0xa2, 0x3c, 0xb6, 0x94,
-	0x8d, 0x86, 0xf3, 0xea, 0xa3, 0xd7, 0x61, 0x52, 0x70, 0xee, 0x92, 0xe2, 0x88, 0x69, 0x17, 0x71,
-	0xcb, 0x80, 0xe2, 0x14, 0xb6, 0x8c, 0xc4, 0xc6, 0x98, 0x67, 0x49, 0x61, 0xb4, 0x3b, 0x12, 0x9b,
-	0x0e, 0xc7, 0x5d, 0x35, 0xd0, 0x02, 0x4c, 0x71, 0xd6, 0xca, 0xf5, 0x5b, 0x7c, 0x4e, 0x84, 0x67,
-	0x89, 0xda, 0x52, 0x77, 0x4c, 0x30, 0x4e, 0xe3, 0xa3, 0x57, 0x61, 0xdc, 0x09, 0x1b, 0xdb, 0x6e,
-	0x4c, 0x1a, 0x71, 0x27, 0xe4, 0x2e, 0x27, 0x9a, 0x61, 0xc9, 0x82, 0x06, 0xc3, 0x06, 0xa6, 0xfd,
-	0x3e, 0x9c, 0xc9, 0x70, 0x4a, 0xa3, 0x0b, 0xc7, 0x69, 0xbb, 0xf2, 0x9b, 0x52, 0xc6, 0x98, 0x0b,
-	0xb5, 0x55, 0xf9, 0x35, 0x1a, 0x16, 0x5d, 0x9d, 0xcc, 0x79, 0x4d, 0x4b, 0x30, 0xa1, 0x56, 0xe7,
-	0x8a, 0x04, 0xe0, 0x04, 0xc7, 0xfe, 0x5f, 0x05, 0x98, 0xca, 0x50, 0xac, 0xb3, 0x24, 0x07, 0x29,
-	0xd9, 0x23, 0xc9, 0x69, 0x60, 0x06, 0xf6, 0x2b, 0x1c, 0x23, 0xb0, 0x5f, 0xb1, 0x5f, 0x60, 0xbf,
-	0xd2, 0x07, 0x09, 0xec, 0x67, 0x8e, 0xd8, 0xd0, 0x40, 0x23, 0x96, 0x11, 0x0c, 0x70, 0xf8, 0x98,
-	0xc1, 0x00, 0x8d, 0x41, 0x1f, 0x19, 0x60, 0xd0, 0x7f, 0xb4, 0x00, 0xd3, 0x69, 0x03, 0xb8, 0x53,
-	0x50, 0xc7, 0xbe, 0x61, 0xa8, 0x63, 0xb3, 0x53, 0x86, 0xa4, 0xcd, 0xf2, 0xf2, 0x54, 0xb3, 0x38,
-	0xa5, 0x9a, 0xfd, 0xe4, 0x40, 0xd4, 0x7a, 0xab, 0x69, 0xff, 0x6e, 0x01, 0xce, 0xa5, 0xab, 0x2c,
-	0x79, 0x8e, 0xbb, 0x7b, 0x0a, 0x63, 0x73, 0xc7, 0x18, 0x9b, 0xe7, 0x07, 0xf9, 0x1a, 0xd6, 0xb5,
-	0xdc, 0x01, 0x7a, 0x2b, 0x35, 0x40, 0xd7, 0x06, 0x27, 0xd9, 0x7b, 0x94, 0xbe, 0x59, 0x84, 0x4b,
-	0x99, 0xf5, 0x12, 0x6d, 0xe6, 0x8a, 0xa1, 0xcd, 0xbc, 0x9e, 0xd2, 0x66, 0xda, 0xbd, 0x6b, 0x9f,
-	0x8c, 0x7a, 0x53, 0x78, 0x0b, 0xb2, 0xe0, 0x6f, 0x0f, 0xa9, 0xda, 0x34, 0xbc, 0x05, 0x15, 0x21,
-	0x6c, 0xd2, 0xfd, 0x8b, 0xa4, 0xd2, 0xfc, 0x37, 0x16, 0x5c, 0xc8, 0x9c, 0x9b, 0x53, 0x50, 0x61,
-	0xad, 0x9b, 0x2a, 0xac, 0x67, 0x06, 0x5e, 0xad, 0x39, 0x3a, 0xad, 0x3f, 0x2c, 0xe6, 0x7c, 0x0b,
-	0x13, 0xd0, 0xef, 0xc0, 0x98, 0xd3, 0x68, 0x90, 0x28, 0x5a, 0x0b, 0x9a, 0x2a, 0x18, 0xda, 0xf3,
-	0x4c, 0xce, 0x4a, 0x8a, 0x8f, 0x0e, 0x2a, 0x73, 0x69, 0x12, 0x09, 0x18, 0xeb, 0x14, 0xcc, 0xf8,
-	0x8d, 0x85, 0x13, 0x8d, 0xdf, 0x78, 0x1d, 0x60, 0x4f, 0x71, 0xeb, 0x69, 0x21, 0x5f, 0xe3, 0xe3,
-	0x35, 0x2c, 0xf4, 0x45, 0x18, 0x8d, 0xc4, 0x35, 0x2e, 0x96, 0xe2, 0x8b, 0x03, 0xce, 0x95, 0xb3,
-	0x49, 0x3c, 0xd3, 0x2d, 0x5d, 0xe9, 0x43, 0x14, 0x49, 0xf4, 0x1d, 0x30, 0x1d, 0xf1, 0xa8, 0x27,
-	0x4b, 0x9e, 0x13, 0x31, 0x1f, 0x07, 0xb1, 0x0a, 0x99, 0xaf, 0x79, 0x3d, 0x05, 0xc3, 0x5d, 0xd8,
-	0x68, 0x45, 0x7e, 0x14, 0x0b, 0xd1, 0xc2, 0x17, 0xe6, 0x95, 0xe4, 0x83, 0x44, 0x8a, 0xa5, 0xb3,
-	0xe9, 0xe1, 0x67, 0x03, 0xaf, 0xd5, 0xb4, 0x7f, 0xb4, 0x04, 0x8f, 0xf7, 0x38, 0xc4, 0xd0, 0x82,
-	0xf9, 0x46, 0xf9, 0x6c, 0x5a, 0xfa, 0x9d, 0xcb, 0xac, 0x6c, 0x88, 0xc3, 0xa9, 0xb5, 0x52, 0xf8,
-	0xc0, 0x6b, 0xe5, 0x87, 0x2c, 0x4d, 0x2f, 0xc1, 0x2d, 0xe9, 0x3e, 0x77, 0xcc, 0xc3, 0xf9, 0x04,
-	0x15, 0x15, 0x5b, 0x19, 0xd2, 0xfe, 0xf5, 0x81, 0xbb, 0x33, 0xb0, 0xf8, 0x7f, 0xba, 0xda, 0xd9,
-	0xaf, 0x58, 0xf0, 0x64, 0x66, 0x7f, 0x0d, 0x9b, 0x8a, 0x6b, 0x50, 0x6e, 0xd0, 0x42, 0xcd, 0x6f,
-	0x2a, 0x71, 0x28, 0x95, 0x00, 0x9c, 0xe0, 0x18, 0xa6, 0x13, 0x85, 0xbe, 0xa6, 0x13, 0xff, 0xc2,
-	0x82, 0xae, 0x05, 0x7c, 0x0a, 0x27, 0xe9, 0xaa, 0x79, 0x92, 0x7e, 0x7c, 0x90, 0xb9, 0xcc, 0x39,
-	0x44, 0xff, 0xf3, 0x14, 0x9c, 0xcf, 0x71, 0x94, 0xd8, 0x83, 0x99, 0x56, 0x83, 0x98, 0x1e, 0x69,
-	0xe2, 0x63, 0x32, 0x9d, 0xf7, 0x7a, 0xba, 0xaf, 0xb1, 0xdc, 0x38, 0x33, 0x5d, 0x28, 0xb8, 0xbb,
-	0x09, 0xf4, 0x15, 0x0b, 0xce, 0x3a, 0xf7, 0xa3, 0xae, 0x0c, 0x88, 0x62, 0xcd, 0xbc, 0x94, 0xa9,
-	0xa5, 0xe8, 0x93, 0x31, 0x91, 0x27, 0x0b, 0xca, 0xc2, 0xc2, 0x99, 0x6d, 0x21, 0x2c, 0xe2, 0x57,
-	0x52, 0x7e, 0xbb, 0x87, 0xcf, 0x64, 0x96, 0x47, 0x0b, 0x3f, 0x53, 0x25, 0x04, 0x2b, 0x3a, 0xe8,
-	0x1e, 0x94, 0x5b, 0xd2, 0xcd, 0x4c, 0x9c, 0xd9, 0x99, 0x97, 0x60, 0xa6, 0x2f, 0x1a, 0x7f, 0x37,
-	0x54, 0x20, 0x9c, 0x90, 0x42, 0xaf, 0x43, 0xd1, 0xdf, 0x8a, 0x7a, 0x65, 0xd9, 0x49, 0x99, 0x1a,
-	0x71, 0x7f, 0xe4, 0xf5, 0x95, 0x3a, 0xa6, 0x15, 0xd1, 0x4d, 0x28, 0x86, 0x9b, 0x4d, 0xa1, 0x58,
-	0xcb, 0xe4, 0x4b, 0xf1, 0x62, 0x35, 0x7b, 0x91, 0x70, 0x4a, 0x78, 0xb1, 0x8a, 0x29, 0x09, 0x54,
-	0x83, 0x21, 0xe6, 0x53, 0x20, 0xf4, 0x67, 0x99, 0x0c, 0x69, 0x0f, 0xdf, 0x1c, 0xee, 0xb4, 0xcc,
-	0x10, 0x30, 0x27, 0x84, 0x36, 0x60, 0xb8, 0xc1, 0x32, 0xb2, 0x88, 0x90, 0xc9, 0x9f, 0xca, 0x54,
-	0xa1, 0xf5, 0x48, 0x55, 0x23, 0x34, 0x4a, 0x0c, 0x03, 0x0b, 0x5a, 0x8c, 0x2a, 0x69, 0x6f, 0x6f,
-	0x45, 0x4c, 0x04, 0xcf, 0xa3, 0xda, 0x23, 0x03, 0x93, 0xa0, 0xca, 0x30, 0xb0, 0xa0, 0x85, 0x3e,
-	0x03, 0x85, 0xad, 0x86, 0x70, 0x39, 0xc8, 0xd4, 0xa5, 0x99, 0x2e, 0xe5, 0x8b, 0xc3, 0x87, 0x07,
-	0x95, 0xc2, 0xca, 0x12, 0x2e, 0x6c, 0x35, 0xd0, 0x3a, 0x8c, 0x6c, 0x71, 0x27, 0x54, 0xa1, 0x2e,
-	0x7b, 0x3a, 0xdb, 0x3f, 0xb6, 0xcb, 0x4f, 0x95, 0x9b, 0xca, 0x0b, 0x00, 0x96, 0x44, 0x58, 0x10,
-	0x48, 0xe5, 0x4c, 0x2b, 0xa2, 0x21, 0xcf, 0x1f, 0xcf, 0x01, 0x9a, 0xbb, 0xb7, 0x27, 0x2e, 0xb9,
-	0x58, 0xa3, 0x88, 0xbe, 0x0c, 0x65, 0x47, 0xe6, 0xde, 0x13, 0xd1, 0x22, 0x5e, 0xcc, 0xdc, 0x98,
-	0xbd, 0xd3, 0x12, 0xf2, 0x55, 0xad, 0x90, 0x70, 0x42, 0x14, 0xed, 0xc0, 0xc4, 0x5e, 0xd4, 0xde,
-	0x26, 0x72, 0x23, 0xb3, 0xe0, 0x11, 0x39, 0x17, 0xd7, 0x3d, 0x81, 0xe8, 0x86, 0x71, 0xc7, 0xf1,
-	0xba, 0xce, 0x1e, 0xf6, 0xd8, 0x7c, 0x4f, 0x27, 0x86, 0x4d, 0xda, 0x74, 0xf8, 0xdf, 0xeb, 0x04,
-	0x9b, 0xfb, 0x31, 0x11, 0xe1, 0x93, 0x33, 0x87, 0xff, 0x4d, 0x8e, 0xd2, 0x3d, 0xfc, 0x02, 0x80,
-	0x25, 0x11, 0xba, 0xd5, 0x1d, 0x99, 0xd7, 0x92, 0x85, 0x4d, 0xce, 0xd9, 0xea, 0x99, 0xc9, 0x2f,
-	0xb5, 0x41, 0x61, 0x67, 0x64, 0x42, 0x8a, 0x9d, 0x8d, 0xed, 0xed, 0x20, 0x0e, 0xfc, 0xd4, 0xb9,
-	0x3c, 0x93, 0x7f, 0x36, 0xd6, 0x32, 0xf0, 0xbb, 0xcf, 0xc6, 0x2c, 0x2c, 0x9c, 0xd9, 0x16, 0x6a,
-	0xc2, 0x64, 0x3b, 0x08, 0xe3, 0xfb, 0x41, 0x28, 0xd7, 0x17, 0xea, 0x21, 0xee, 0x1b, 0x98, 0xa2,
-	0x45, 0x16, 0xce, 0xdb, 0x84, 0xe0, 0x14, 0x4d, 0xf4, 0x79, 0x18, 0x89, 0x1a, 0x8e, 0x47, 0x56,
-	0xef, 0xcc, 0x9e, 0xc9, 0xbf, 0x74, 0xea, 0x1c, 0x25, 0x67, 0x75, 0xb1, 0xc9, 0x11, 0x28, 0x58,
-	0x92, 0x43, 0x2b, 0x30, 0xc4, 0x62, 0xf2, 0xb3, 0xc8, 0xcf, 0x39, 0x51, 0x89, 0xba, 0x8c, 0x3a,
-	0xf9, 0xd9, 0xc4, 0x8a, 0x31, 0xaf, 0x4e, 0xf7, 0x80, 0xe0, 0x7a, 0x83, 0x68, 0xf6, 0x5c, 0xfe,
-	0x1e, 0x10, 0xcc, 0xf2, 0x9d, 0x7a, 0xaf, 0x3d, 0xa0, 0x90, 0x70, 0x42, 0x94, 0x9e, 0xcc, 0xf4,
-	0x34, 0x3d, 0xdf, 0xc3, 0xce, 0x24, 0xf7, 0x2c, 0x65, 0x27, 0x33, 0x3d, 0x49, 0x29, 0x09, 0xfb,
-	0xf7, 0x46, 0xba, 0x39, 0x15, 0x26, 0x27, 0xfd, 0x65, 0xab, 0xeb, 0x09, 0xed, 0xd3, 0x83, 0xaa,
-	0x6d, 0x4e, 0x90, 0x47, 0xfd, 0x8a, 0x05, 0xe7, 0xdb, 0x99, 0x1f, 0x22, 0xae, 0xfd, 0xc1, 0xb4,
-	0x3f, 0xfc, 0xd3, 0x55, 0x74, 0xf6, 0x6c, 0x38, 0xce, 0x69, 0x29, 0x2d, 0x07, 0x14, 0x3f, 0xb0,
-	0x1c, 0xb0, 0x06, 0xa3, 0x8c, 0xb5, 0xec, 0x93, 0xa1, 0x2c, 0xed, 0x85, 0xc6, 0x18, 0x88, 0x25,
-	0x51, 0x11, 0x2b, 0x12, 0xe8, 0x87, 0x2d, 0xb8, 0x98, 0xee, 0x3a, 0x26, 0x0c, 0x2c, 0x62, 0x99,
-	0x73, 0x11, 0x6d, 0x45, 0x7c, 0xff, 0xc5, 0x5a, 0x2f, 0xe4, 0xa3, 0x7e, 0x08, 0xb8, 0x77, 0x63,
-	0xa8, 0x9a, 0x21, 0x23, 0x0e, 0x9b, 0x7a, 0xf1, 0x01, 0xe4, 0xc4, 0x97, 0x60, 0x7c, 0x37, 0xe8,
-	0xf8, 0xb1, 0x30, 0x4b, 0x11, 0x4e, 0x82, 0xec, 0x1d, 0x78, 0x4d, 0x2b, 0xc7, 0x06, 0x56, 0x4a,
-	0xba, 0x1c, 0x7d, 0x58, 0xe9, 0x12, 0xbd, 0x93, 0xca, 0x43, 0x5d, 0xce, 0x8f, 0x99, 0x27, 0x04,
-	0xf1, 0x63, 0x64, 0xa3, 0x3e, 0x5d, 0x89, 0xe8, 0xe7, 0xac, 0x0c, 0x56, 0x9e, 0xcb, 0xc8, 0x9f,
-	0x35, 0x65, 0xe4, 0x2b, 0x69, 0x19, 0xb9, 0x4b, 0x27, 0x6a, 0x88, 0xc7, 0x83, 0x07, 0x5e, 0x1e,
-	0x34, 0x92, 0x99, 0xed, 0xc1, 0xe5, 0x7e, 0xd7, 0x12, 0xb3, 0x4f, 0x6a, 0xaa, 0x17, 0xb0, 0xc4,
-	0x3e, 0xa9, 0xb9, 0x5a, 0xc5, 0x0c, 0x32, 0x68, 0xa8, 0x0b, 0xfb, 0xbf, 0x59, 0x50, 0xac, 0x05,
-	0xcd, 0x53, 0xd0, 0xf1, 0x7e, 0xce, 0xd0, 0xf1, 0x3e, 0x9e, 0x93, 0x1f, 0x3c, 0x57, 0xa3, 0xbb,
-	0x9c, 0xd2, 0xe8, 0x5e, 0xcc, 0x23, 0xd0, 0x5b, 0x7f, 0xfb, 0xd3, 0x45, 0xd0, 0xb3, 0x99, 0xa3,
-	0x7f, 0xf5, 0x30, 0xc6, 0xc1, 0xc5, 0x5e, 0x09, 0xce, 0x05, 0x65, 0x66, 0xd6, 0x24, 0xfd, 0xde,
-	0xfe, 0x9c, 0xd9, 0x08, 0xbf, 0x45, 0xdc, 0xd6, 0x76, 0x4c, 0x9a, 0xe9, 0xcf, 0x39, 0x3d, 0x1b,
-	0xe1, 0xff, 0x62, 0xc1, 0x54, 0xaa, 0x75, 0xe4, 0xc1, 0x84, 0xa7, 0x2b, 0xe8, 0xc4, 0x3a, 0x7d,
-	0x28, 0xdd, 0x9e, 0xb0, 0xb1, 0xd4, 0x8a, 0xb0, 0x49, 0x1c, 0xcd, 0x03, 0xa8, 0x07, 0x34, 0xa9,
-	0xf7, 0x62, 0x5c, 0xbf, 0x7a, 0x61, 0x8b, 0xb0, 0x86, 0x81, 0x5e, 0x86, 0xb1, 0x38, 0x68, 0x07,
-	0x5e, 0xd0, 0xda, 0xbf, 0x45, 0x64, 0x70, 0x15, 0x65, 0x39, 0xb5, 0x91, 0x80, 0xb0, 0x8e, 0x67,
-	0xff, 0x6c, 0x11, 0xd2, 0x19, 0xf0, 0xbf, 0xb5, 0x26, 0x3f, 0x9a, 0x6b, 0xf2, 0x9b, 0x16, 0x4c,
-	0xd3, 0xd6, 0x99, 0x15, 0x87, 0xbc, 0x6c, 0x55, 0x02, 0x18, 0xab, 0x47, 0x02, 0x98, 0x2b, 0xf4,
-	0xec, 0x6a, 0x06, 0x9d, 0x58, 0xe8, 0xcd, 0xb4, 0xc3, 0x89, 0x96, 0x62, 0x01, 0x15, 0x78, 0x24,
-	0x0c, 0x85, 0x6b, 0x92, 0x8e, 0x47, 0xc2, 0x10, 0x0b, 0xa8, 0xcc, 0x0f, 0x53, 0xca, 0xc9, 0x0f,
-	0xc3, 0x42, 0xc5, 0x89, 0xf7, 0x7e, 0xc1, 0xf6, 0x68, 0xa1, 0xe2, 0xa4, 0x21, 0x40, 0x82, 0x63,
-	0xff, 0x62, 0x11, 0xc6, 0x6b, 0x41, 0x33, 0x79, 0xc2, 0x7a, 0xc9, 0x78, 0xc2, 0xba, 0x9c, 0x7a,
-	0xc2, 0x9a, 0xd6, 0x71, 0xbf, 0xf5, 0x60, 0xf5, 0x61, 0x3d, 0x58, 0xfd, 0x73, 0x8b, 0xcd, 0x5a,
-	0x75, 0xbd, 0x2e, 0xf2, 0xd3, 0xbe, 0x00, 0x63, 0xec, 0x40, 0x62, 0xbe, 0x70, 0xf2, 0x5d, 0x87,
-	0x85, 0x7e, 0x5f, 0x4f, 0x8a, 0xb1, 0x8e, 0x83, 0xae, 0xc2, 0x68, 0x44, 0x9c, 0xb0, 0xb1, 0xad,
-	0xce, 0x38, 0xf1, 0xea, 0xc1, 0xcb, 0xb0, 0x82, 0xa2, 0x37, 0x93, 0x28, 0x65, 0xc5, 0xfc, 0x4c,
-	0xab, 0x7a, 0x7f, 0xf8, 0x16, 0xc9, 0x0f, 0x4d, 0x66, 0xbf, 0x05, 0xa8, 0x1b, 0x7f, 0x80, 0x78,
-	0x44, 0x15, 0x33, 0x1e, 0x51, 0xb9, 0x2b, 0x16, 0xd1, 0x9f, 0x5a, 0x30, 0x59, 0x0b, 0x9a, 0x74,
-	0xeb, 0xfe, 0x45, 0xda, 0xa7, 0x7a, 0x88, 0xc6, 0xe1, 0x1e, 0x21, 0x1a, 0xff, 0x9e, 0x05, 0x23,
-	0xb5, 0xa0, 0x79, 0x0a, 0xda, 0xf6, 0xcf, 0x9a, 0xda, 0xf6, 0xc7, 0x72, 0x96, 0x44, 0x8e, 0x82,
-	0xfd, 0x97, 0x8b, 0x30, 0x41, 0xfb, 0x19, 0xb4, 0xe4, 0x2c, 0x19, 0x23, 0x62, 0x0d, 0x30, 0x22,
-	0x94, 0xcd, 0x0d, 0x3c, 0x2f, 0xb8, 0x9f, 0x9e, 0xb1, 0x15, 0x56, 0x8a, 0x05, 0x14, 0x3d, 0x07,
-	0xa3, 0xed, 0x90, 0xec, 0xb9, 0x81, 0xe0, 0x1f, 0xb5, 0xb7, 0x8b, 0x9a, 0x28, 0xc7, 0x0a, 0x83,
-	0xca, 0x5d, 0x91, 0xeb, 0x37, 0x88, 0x4c, 0xf3, 0x5c, 0x62, 0x99, 0xa0, 0x78, 0xec, 0x65, 0xad,
-	0x1c, 0x1b, 0x58, 0xe8, 0x2d, 0x28, 0xb3, 0xff, 0xec, 0x44, 0x39, 0x7e, 0xe6, 0x1a, 0x91, 0xf0,
-	0x40, 0x10, 0xc0, 0x09, 0x2d, 0x74, 0x1d, 0x20, 0x96, 0xf1, 0x79, 0x23, 0x11, 0x56, 0x46, 0xf1,
-	0xda, 0x2a, 0x72, 0x6f, 0x84, 0x35, 0x2c, 0xf4, 0x2c, 0x94, 0x63, 0xc7, 0xf5, 0x6e, 0xbb, 0x3e,
-	0x89, 0x98, 0xca, 0xb9, 0x28, 0xf3, 0x19, 0x88, 0x42, 0x9c, 0xc0, 0x29, 0xaf, 0xc3, 0x7c, 0xae,
-	0x79, 0xde, 0xab, 0x51, 0x86, 0xcd, 0x78, 0x9d, 0xdb, 0xaa, 0x14, 0x6b, 0x18, 0xf6, 0xab, 0x70,
-	0xae, 0x16, 0x34, 0x6b, 0x41, 0x18, 0xaf, 0x04, 0xe1, 0x7d, 0x27, 0x6c, 0xca, 0xf9, 0xab, 0xc8,
-	0xd0, 0xfa, 0xf4, 0xec, 0x19, 0xe2, 0x3b, 0xd3, 0x08, 0x9a, 0xff, 0x22, 0xe3, 0x76, 0x8e, 0xe9,
-	0x6b, 0xd1, 0x60, 0xf7, 0xae, 0x4a, 0x71, 0x77, 0xc3, 0x89, 0x09, 0xba, 0xc3, 0xd2, 0x62, 0x25,
-	0x57, 0x90, 0xa8, 0xfe, 0x8c, 0x96, 0x16, 0x2b, 0x01, 0x66, 0xde, 0x59, 0x66, 0x7d, 0xfb, 0xd7,
-	0x8b, 0xec, 0x34, 0x4a, 0x65, 0x7c, 0x43, 0x5f, 0x82, 0xc9, 0x88, 0xdc, 0x76, 0xfd, 0xce, 0x03,
-	0x29, 0x84, 0xf7, 0xf0, 0x96, 0xa9, 0x2f, 0xeb, 0x98, 0x5c, 0x95, 0x67, 0x96, 0xe1, 0x14, 0x35,
-	0x3a, 0x4f, 0x61, 0xc7, 0x5f, 0x88, 0xee, 0x46, 0x24, 0x14, 0x19, 0xc7, 0xd8, 0x3c, 0x61, 0x59,
-	0x88, 0x13, 0x38, 0x5d, 0x97, 0xec, 0xcf, 0x7a, 0xe0, 0xe3, 0x20, 0x88, 0xe5, 0x4a, 0x66, 0x39,
-	0x6b, 0xb4, 0x72, 0x6c, 0x60, 0xa1, 0x15, 0x40, 0x51, 0xa7, 0xdd, 0xf6, 0xd8, 0x7b, 0xbb, 0xe3,
-	0xdd, 0x08, 0x83, 0x4e, 0x9b, 0xbf, 0x75, 0x16, 0x17, 0xcf, 0xd3, 0x2b, 0xac, 0xde, 0x05, 0xc5,
-	0x19, 0x35, 0xe8, 0xe9, 0xb3, 0x15, 0xb1, 0xdf, 0x6c, 0x75, 0x17, 0x85, 0x7a, 0xbd, 0xce, 0x8a,
-	0xb0, 0x84, 0xd1, 0xc5, 0xc4, 0x9a, 0xe7, 0x98, 0xc3, 0xc9, 0x62, 0xc2, 0xaa, 0x14, 0x6b, 0x18,
-	0x68, 0x19, 0x46, 0xa2, 0xfd, 0xa8, 0x11, 0x8b, 0x20, 0x48, 0x39, 0xb9, 0x23, 0xeb, 0x0c, 0x45,
-	0xcb, 0x67, 0xc0, 0xab, 0x60, 0x59, 0xd7, 0xfe, 0x1e, 0x76, 0x19, 0xb2, 0xfc, 0x54, 0x71, 0x27,
-	0x24, 0x68, 0x17, 0x26, 0xda, 0x6c, 0xca, 0x45, 0xf4, 0x64, 0x31, 0x6f, 0x2f, 0x0d, 0x28, 0xd5,
-	0xde, 0xa7, 0x07, 0x8d, 0xd2, 0x3a, 0x31, 0x71, 0xa1, 0xa6, 0x93, 0xc3, 0x26, 0x75, 0xfb, 0x07,
-	0x67, 0xd8, 0x99, 0x5b, 0xe7, 0xa2, 0xea, 0x88, 0xb0, 0xf8, 0x15, 0x7c, 0xf9, 0x5c, 0xbe, 0xce,
-	0x24, 0xf9, 0x22, 0x61, 0x35, 0x8c, 0x65, 0x5d, 0xf4, 0x26, 0x7b, 0x9b, 0xe6, 0x07, 0x5d, 0xbf,
-	0x34, 0xc1, 0x1c, 0xcb, 0x78, 0x86, 0x16, 0x15, 0xb1, 0x46, 0x04, 0xdd, 0x86, 0x09, 0x91, 0xce,
-	0x48, 0x28, 0xc5, 0x8a, 0x86, 0xd2, 0x63, 0x02, 0xeb, 0xc0, 0xa3, 0x74, 0x01, 0x36, 0x2b, 0xa3,
-	0x16, 0x5c, 0xd4, 0x72, 0xfb, 0xdd, 0x08, 0x1d, 0xf6, 0x5e, 0xe9, 0xb2, 0x4d, 0xa4, 0x9d, 0x9b,
-	0x4f, 0x1e, 0x1e, 0x54, 0x2e, 0x6e, 0xf4, 0x42, 0xc4, 0xbd, 0xe9, 0xa0, 0x3b, 0x70, 0x8e, 0x3b,
-	0xd6, 0x55, 0x89, 0xd3, 0xf4, 0x5c, 0x5f, 0x1d, 0xcc, 0x7c, 0x1d, 0x5e, 0x38, 0x3c, 0xa8, 0x9c,
-	0x5b, 0xc8, 0x42, 0xc0, 0xd9, 0xf5, 0xd0, 0x67, 0xa1, 0xdc, 0xf4, 0x23, 0x31, 0x06, 0xc3, 0x46,
-	0xda, 0xca, 0x72, 0x75, 0xbd, 0xae, 0xbe, 0x3f, 0xf9, 0x83, 0x93, 0x0a, 0xa8, 0xc5, 0x15, 0x63,
-	0x4a, 0x0e, 0x1d, 0xc9, 0x4f, 0x51, 0x2e, 0x96, 0x84, 0xe1, 0x5a, 0xc3, 0x35, 0xc2, 0xca, 0x34,
-	0xd5, 0xf0, 0xba, 0x31, 0x08, 0xa3, 0x37, 0x00, 0x51, 0x46, 0xcd, 0x6d, 0x90, 0x85, 0x06, 0x0b,
-	0x62, 0xcd, 0xf4, 0x88, 0xa3, 0x86, 0x2b, 0x03, 0xaa, 0x77, 0x61, 0xe0, 0x8c, 0x5a, 0xe8, 0x26,
-	0x3d, 0xc8, 0xf4, 0x52, 0x61, 0x62, 0x2b, 0x99, 0xfb, 0xd9, 0x2a, 0x69, 0x87, 0xa4, 0xe1, 0xc4,
-	0xa4, 0x69, 0x52, 0xc4, 0xa9, 0x7a, 0xf4, 0x2e, 0x55, 0xf9, 0x6c, 0xc0, 0x8c, 0x54, 0xd1, 0x9d,
-	0xd3, 0x86, 0xca, 0xc5, 0xdb, 0x41, 0x14, 0xaf, 0x93, 0xf8, 0x7e, 0x10, 0xee, 0x88, 0xc0, 0x60,
-	0x49, 0x8c, 0xca, 0x04, 0x84, 0x75, 0x3c, 0xca, 0x07, 0xb3, 0xc7, 0xe1, 0xd5, 0x2a, 0x7b, 0xa1,
-	0x1b, 0x4d, 0xf6, 0xc9, 0x4d, 0x5e, 0x8c, 0x25, 0x5c, 0xa2, 0xae, 0xd6, 0x96, 0xd8, 0x6b, 0x5b,
-	0x0a, 0x75, 0xb5, 0xb6, 0x84, 0x25, 0x1c, 0x91, 0xee, 0x94, 0xa0, 0x93, 0xf9, 0x5a, 0xcd, 0xee,
-	0xeb, 0x60, 0xc0, 0xac, 0xa0, 0x3e, 0x4c, 0xab, 0x64, 0xa4, 0x3c, 0x62, 0x5a, 0x34, 0x3b, 0xc5,
-	0x16, 0xc9, 0xe0, 0xe1, 0xd6, 0x94, 0x9e, 0x78, 0x35, 0x45, 0x09, 0x77, 0xd1, 0x36, 0x62, 0x87,
-	0x4c, 0xf7, 0xcd, 0x47, 0x74, 0x0d, 0xca, 0x51, 0x67, 0xb3, 0x19, 0xec, 0x3a, 0xae, 0xcf, 0x1e,
-	0xc7, 0x34, 0x26, 0xab, 0x2e, 0x01, 0x38, 0xc1, 0x41, 0x2b, 0x30, 0xea, 0x48, 0x25, 0x30, 0xca,
-	0x0f, 0x26, 0xa0, 0x54, 0xbf, 0xdc, 0xbf, 0x56, 0xaa, 0x7d, 0x55, 0x5d, 0xf4, 0x1a, 0x4c, 0x08,
-	0x77, 0x2a, 0x1e, 0x62, 0x81, 0x3d, 0x5e, 0x69, 0xf6, 0xf2, 0x75, 0x1d, 0x88, 0x4d, 0x5c, 0xf4,
-	0x45, 0x98, 0xa4, 0x54, 0x92, 0x83, 0x6d, 0xf6, 0xec, 0x20, 0x27, 0xa2, 0x96, 0x67, 0x42, 0xaf,
-	0x8c, 0x53, 0xc4, 0x50, 0x13, 0x9e, 0x70, 0x3a, 0x71, 0xc0, 0x14, 0xe9, 0xe6, 0xfa, 0xdf, 0x08,
-	0x76, 0x88, 0xcf, 0xde, 0xb0, 0x46, 0x17, 0x2f, 0x1f, 0x1e, 0x54, 0x9e, 0x58, 0xe8, 0x81, 0x87,
-	0x7b, 0x52, 0x41, 0x77, 0x61, 0x2c, 0x0e, 0x3c, 0x66, 0xb9, 0x4e, 0x59, 0x89, 0xf3, 0xf9, 0xb1,
-	0x77, 0x36, 0x14, 0x9a, 0xae, 0x44, 0x52, 0x55, 0xb1, 0x4e, 0x07, 0x6d, 0xf0, 0x3d, 0xc6, 0xa2,
-	0x92, 0x92, 0x68, 0xf6, 0xb1, 0xfc, 0x81, 0x51, 0xc1, 0x4b, 0xcd, 0x2d, 0x28, 0x6a, 0x62, 0x9d,
-	0x0c, 0xba, 0x01, 0x33, 0xed, 0xd0, 0x0d, 0xd8, 0xc2, 0x56, 0x8f, 0x18, 0xb3, 0x66, 0x6a, 0x81,
-	0x5a, 0x1a, 0x01, 0x77, 0xd7, 0xa1, 0x42, 0xa6, 0x2c, 0x9c, 0xbd, 0xc0, 0xf3, 0x54, 0x71, 0xc6,
-	0x9b, 0x97, 0x61, 0x05, 0x45, 0x6b, 0xec, 0x5c, 0xe6, 0xe2, 0xe0, 0xec, 0x5c, 0x7e, 0x10, 0x06,
-	0x5d, 0x6c, 0xe4, 0xfc, 0x92, 0xfa, 0x8b, 0x13, 0x0a, 0xf4, 0xde, 0x88, 0xb6, 0x9d, 0x90, 0xd4,
-	0xc2, 0xa0, 0x41, 0x78, 0x67, 0xb8, 0xd1, 0xfc, 0xe3, 0x3c, 0x78, 0x22, 0xbd, 0x37, 0xea, 0x59,
-	0x08, 0x38, 0xbb, 0x1e, 0x6a, 0x6a, 0xe9, 0x99, 0x29, 0x1b, 0x1a, 0xcd, 0x3e, 0xd1, 0xc3, 0xcc,
-	0x28, 0xc5, 0xb3, 0x26, 0x6b, 0xd1, 0x28, 0x8e, 0x70, 0x8a, 0xe6, 0xdc, 0xb7, 0xc3, 0x4c, 0xd7,
-	0x7d, 0x71, 0xac, 0xb8, 0xdd, 0x7f, 0x32, 0x04, 0x65, 0xa5, 0x0a, 0x47, 0xd7, 0xcc, 0x17, 0x8e,
-	0x0b, 0xe9, 0x17, 0x8e, 0x51, 0xca, 0x91, 0xeb, 0x8f, 0x1a, 0x1b, 0x86, 0x51, 0x5c, 0x21, 0x3f,
-	0x4b, 0x96, 0xce, 0x53, 0xf7, 0xf5, 0x80, 0xd3, 0x34, 0x1b, 0xc5, 0x81, 0x9f, 0x4a, 0x4a, 0x3d,
-	0x95, 0x25, 0x03, 0x26, 0xa9, 0xa5, 0xc2, 0x7f, 0x3b, 0x68, 0xae, 0xd6, 0xd2, 0x59, 0x1b, 0x6b,
-	0xb4, 0x10, 0x73, 0x18, 0x13, 0xdf, 0x28, 0x73, 0xc3, 0xc4, 0xb7, 0x91, 0x87, 0x14, 0xdf, 0x24,
-	0x01, 0x9c, 0xd0, 0x42, 0x1e, 0xcc, 0x34, 0xcc, 0x84, 0x9b, 0xca, 0xeb, 0xed, 0xa9, 0xbe, 0xa9,
-	0x2f, 0x3b, 0x5a, 0x76, 0xb3, 0xa5, 0x34, 0x15, 0xdc, 0x4d, 0x18, 0xbd, 0x06, 0xa3, 0xef, 0x05,
-	0x11, 0xdb, 0x7c, 0xe2, 0x86, 0x97, 0xde, 0x41, 0xa3, 0x6f, 0xde, 0xa9, 0xb3, 0xf2, 0xa3, 0x83,
-	0xca, 0x58, 0x2d, 0x68, 0xca, 0xbf, 0x58, 0x55, 0x40, 0x0f, 0xe0, 0x9c, 0x71, 0x2e, 0xaa, 0xee,
-	0xc2, 0xe0, 0xdd, 0xbd, 0x28, 0x9a, 0x3b, 0xb7, 0x9a, 0x45, 0x09, 0x67, 0x37, 0x40, 0x0f, 0x1b,
-	0x3f, 0x10, 0xc9, 0x6a, 0x25, 0x17, 0xc1, 0x98, 0x85, 0xb2, 0xee, 0x1b, 0x9e, 0x42, 0xc0, 0xdd,
-	0x75, 0xec, 0xaf, 0xf1, 0x97, 0x03, 0xa1, 0x5f, 0x24, 0x51, 0xc7, 0x3b, 0x8d, 0x5c, 0x48, 0xcb,
-	0x86, 0xea, 0xf3, 0xa1, 0x5f, 0xa7, 0x7e, 0xd3, 0x62, 0xaf, 0x53, 0x1b, 0x64, 0xb7, 0xed, 0x51,
-	0x29, 0xf7, 0xd1, 0x77, 0xfc, 0x4d, 0x18, 0x8d, 0x45, 0x6b, 0xbd, 0xd2, 0x37, 0x69, 0x9d, 0x62,
-	0x2f, 0x74, 0x8a, 0xbf, 0x90, 0xa5, 0x58, 0x91, 0xb1, 0xff, 0x29, 0x9f, 0x01, 0x09, 0x39, 0x05,
-	0x35, 0x54, 0xd5, 0x54, 0x43, 0x55, 0xfa, 0x7c, 0x41, 0x8e, 0x3a, 0xea, 0x9f, 0x98, 0xfd, 0x66,
-	0xa2, 0xdc, 0x47, 0xfd, 0x59, 0xd4, 0xfe, 0x31, 0x0b, 0xce, 0x66, 0xd9, 0x11, 0x51, 0x9e, 0x90,
-	0x0b, 0x92, 0xea, 0x99, 0x58, 0x8d, 0xe0, 0x3d, 0x51, 0x8e, 0x15, 0xc6, 0xc0, 0x99, 0x11, 0x8e,
-	0x17, 0x3e, 0xed, 0x0e, 0x4c, 0xd4, 0x42, 0xa2, 0xdd, 0x01, 0xaf, 0x73, 0x37, 0x33, 0xde, 0x9f,
-	0xe7, 0x8e, 0xed, 0x62, 0x66, 0xff, 0x7c, 0x01, 0xce, 0xf2, 0x77, 0x9e, 0x85, 0xbd, 0xc0, 0x6d,
-	0xd6, 0x82, 0xa6, 0xc8, 0x6a, 0xf1, 0x36, 0x8c, 0xb7, 0x35, 0xe9, 0xbf, 0x57, 0x00, 0x27, 0x5d,
-	0x4b, 0x90, 0x48, 0x61, 0x7a, 0x29, 0x36, 0x68, 0xa1, 0x26, 0x8c, 0x93, 0x3d, 0xb7, 0xa1, 0x1e,
-	0x0b, 0x0a, 0xc7, 0xbe, 0x1b, 0x54, 0x2b, 0xcb, 0x1a, 0x1d, 0x6c, 0x50, 0x7d, 0x04, 0x89, 0xce,
-	0xec, 0x1f, 0xb7, 0xe0, 0xb1, 0x9c, 0x70, 0x4f, 0xb4, 0xb9, 0xfb, 0xec, 0x45, 0x4d, 0xe4, 0x4c,
-	0x52, 0xcd, 0xf1, 0x77, 0x36, 0x2c, 0xa0, 0xe8, 0xf3, 0x00, 0xfc, 0x9d, 0x8c, 0x0a, 0x25, 0xfd,
-	0xe2, 0xe2, 0x18, 0x21, 0x3d, 0xb4, 0x50, 0x0c, 0xb2, 0x3e, 0xd6, 0x68, 0xd9, 0x3f, 0x53, 0x84,
-	0x21, 0xf6, 0x2e, 0x83, 0x56, 0x60, 0x64, 0x9b, 0x07, 0x37, 0x1e, 0x24, 0x8e, 0x72, 0x22, 0xdd,
-	0xf1, 0x02, 0x2c, 0x2b, 0xa3, 0x35, 0x38, 0xc3, 0x83, 0x43, 0x7b, 0x55, 0xe2, 0x39, 0xfb, 0x52,
-	0x49, 0xc0, 0xf3, 0x0c, 0xa9, 0xb0, 0x12, 0xab, 0xdd, 0x28, 0x38, 0xab, 0x1e, 0x7a, 0x1d, 0x26,
-	0x63, 0x77, 0x97, 0x04, 0x9d, 0x58, 0x52, 0xe2, 0x61, 0xa1, 0x15, 0x1b, 0xb7, 0x61, 0x40, 0x71,
-	0x0a, 0x9b, 0x8a, 0x3b, 0xed, 0x2e, 0x75, 0x88, 0x96, 0xb9, 0xdf, 0x54, 0x81, 0x98, 0xb8, 0xcc,
-	0x80, 0xa8, 0xc3, 0xcc, 0xa5, 0x36, 0xb6, 0x43, 0x12, 0x6d, 0x07, 0x5e, 0x53, 0xa4, 0xa9, 0x4e,
-	0x0c, 0x88, 0x52, 0x70, 0xdc, 0x55, 0x83, 0x52, 0xd9, 0x72, 0x5c, 0xaf, 0x13, 0x92, 0x84, 0xca,
-	0xb0, 0x49, 0x65, 0x25, 0x05, 0xc7, 0x5d, 0x35, 0xe8, 0x3a, 0x3a, 0x27, 0xf2, 0x46, 0x4b, 0x67,
-	0x77, 0x65, 0x15, 0x36, 0x22, 0xdd, 0x7e, 0x7a, 0x44, 0x7b, 0x11, 0x76, 0x33, 0x2a, 0xf3, 0xb4,
-	0xa6, 0xc5, 0x13, 0x0e, 0x3f, 0x92, 0xca, 0xc3, 0x64, 0x2f, 0xfe, 0x3d, 0x0b, 0xce, 0x64, 0x58,
-	0x9f, 0xf2, 0xa3, 0xaa, 0xe5, 0x46, 0xb1, 0xca, 0xa5, 0xa2, 0x1d, 0x55, 0xbc, 0x1c, 0x2b, 0x0c,
-	0xba, 0x1f, 0xf8, 0x61, 0x98, 0x3e, 0x00, 0x85, 0x75, 0x97, 0x80, 0x1e, 0xef, 0x00, 0x44, 0x97,
-	0xa1, 0xd4, 0x89, 0x88, 0x8c, 0xd3, 0xa4, 0xce, 0x6f, 0xa6, 0xd7, 0x65, 0x10, 0xca, 0x9a, 0xb6,
-	0x94, 0x4a, 0x55, 0x63, 0x4d, 0xb9, 0x9e, 0x94, 0xc3, 0xec, 0xaf, 0x16, 0xe1, 0x42, 0xae, 0x9d,
-	0x39, 0xed, 0xd2, 0x6e, 0xe0, 0xbb, 0x71, 0xa0, 0xde, 0xfc, 0x78, 0xa4, 0x10, 0xd2, 0xde, 0x5e,
-	0x13, 0xe5, 0x58, 0x61, 0xa0, 0x2b, 0x32, 0x83, 0x79, 0x3a, 0x5b, 0xcc, 0x62, 0xd5, 0x48, 0x62,
-	0x3e, 0x68, 0x26, 0xae, 0xa7, 0xa0, 0xd4, 0x0e, 0x02, 0x2f, 0x7d, 0x18, 0xd1, 0xee, 0x06, 0x81,
-	0x87, 0x19, 0x10, 0x7d, 0x42, 0x8c, 0x43, 0xea, 0x91, 0x0b, 0x3b, 0xcd, 0x20, 0xd2, 0x06, 0xe3,
-	0x19, 0x18, 0xd9, 0x21, 0xfb, 0xa1, 0xeb, 0xb7, 0xd2, 0x8f, 0x9f, 0xb7, 0x78, 0x31, 0x96, 0x70,
-	0x33, 0x59, 0xc2, 0xc8, 0x49, 0xa7, 0xd0, 0x1a, 0xed, 0x7b, 0xb5, 0xfd, 0x50, 0x11, 0xa6, 0xf0,
-	0x62, 0xf5, 0x5b, 0x13, 0x71, 0xb7, 0x7b, 0x22, 0x4e, 0x3a, 0x85, 0x56, 0xff, 0xd9, 0xf8, 0x65,
-	0x0b, 0xa6, 0x58, 0x40, 0x61, 0x11, 0x9f, 0xc2, 0x0d, 0xfc, 0x53, 0x60, 0xdd, 0x9e, 0x82, 0xa1,
-	0x90, 0x36, 0x9a, 0xce, 0x8b, 0xc3, 0x7a, 0x82, 0x39, 0x0c, 0x3d, 0x01, 0x25, 0xd6, 0x05, 0x3a,
-	0x79, 0xe3, 0x3c, 0xa5, 0x40, 0xd5, 0x89, 0x1d, 0xcc, 0x4a, 0x99, 0xd3, 0x35, 0x26, 0x6d, 0xcf,
-	0xe5, 0x9d, 0x4e, 0x1e, 0x14, 0x3e, 0x1a, 0x4e, 0xd7, 0x99, 0x5d, 0xfb, 0x60, 0x4e, 0xd7, 0xd9,
-	0x24, 0x7b, 0x8b, 0x45, 0xff, 0xbd, 0x00, 0x97, 0x32, 0xeb, 0x0d, 0xec, 0x74, 0xdd, 0xbb, 0xf6,
-	0xc9, 0xd8, 0xb0, 0x64, 0x9b, 0x96, 0x14, 0x4f, 0xd1, 0xb4, 0xa4, 0x34, 0x28, 0xe7, 0x38, 0x34,
-	0x80, 0x2f, 0x74, 0xe6, 0x90, 0x7d, 0x44, 0x7c, 0xa1, 0x33, 0xfb, 0x96, 0x23, 0xd6, 0xfd, 0x59,
-	0x21, 0xe7, 0x5b, 0x98, 0x80, 0x77, 0x95, 0x9e, 0x33, 0x0c, 0x18, 0x09, 0x4e, 0x78, 0x9c, 0x9f,
-	0x31, 0xbc, 0x0c, 0x2b, 0x28, 0x72, 0x35, 0xaf, 0xe2, 0x42, 0x7e, 0xd6, 0xc4, 0xdc, 0xa6, 0xe6,
-	0xcd, 0xf7, 0x1f, 0x35, 0x04, 0x19, 0x1e, 0xc6, 0x6b, 0x9a, 0x50, 0x5e, 0x1c, 0x5c, 0x28, 0x1f,
-	0xcf, 0x16, 0xc8, 0xd1, 0x02, 0x4c, 0xed, 0xba, 0x3e, 0xcb, 0x82, 0x6f, 0xb2, 0xa2, 0x2a, 0xc8,
-	0xc6, 0x9a, 0x09, 0xc6, 0x69, 0xfc, 0xb9, 0xd7, 0x60, 0xe2, 0xe1, 0xd5, 0x91, 0xdf, 0x2c, 0xc2,
-	0xe3, 0x3d, 0xb6, 0x3d, 0x3f, 0xeb, 0x8d, 0x39, 0xd0, 0xce, 0xfa, 0xae, 0x79, 0xa8, 0xc1, 0xd9,
-	0xad, 0x8e, 0xe7, 0xed, 0x33, 0xeb, 0x4d, 0xd2, 0x94, 0x18, 0x82, 0x57, 0x7c, 0x42, 0x26, 0x71,
-	0x58, 0xc9, 0xc0, 0xc1, 0x99, 0x35, 0xd1, 0x1b, 0x80, 0x02, 0x91, 0xb2, 0xf5, 0x06, 0xf1, 0x85,
-	0x56, 0x9d, 0x0d, 0x7c, 0x31, 0xd9, 0x8c, 0x77, 0xba, 0x30, 0x70, 0x46, 0x2d, 0xca, 0xf4, 0xd3,
-	0x5b, 0x69, 0x5f, 0x75, 0x2b, 0xc5, 0xf4, 0x63, 0x1d, 0x88, 0x4d, 0x5c, 0x74, 0x03, 0x66, 0x9c,
-	0x3d, 0xc7, 0xe5, 0xc1, 0xe7, 0x24, 0x01, 0xce, 0xf5, 0x2b, 0x25, 0xd8, 0x42, 0x1a, 0x01, 0x77,
-	0xd7, 0x49, 0xb9, 0x35, 0x0f, 0xe7, 0xbb, 0x35, 0xf7, 0x3e, 0x17, 0xfb, 0xe9, 0x74, 0xed, 0xff,
-	0x68, 0xd1, 0xeb, 0x2b, 0x23, 0xed, 0x3a, 0x1d, 0x07, 0xa5, 0x9b, 0xd4, 0x3c, 0x8c, 0xcf, 0x69,
-	0xf6, 0x19, 0x09, 0x10, 0x9b, 0xb8, 0x7c, 0x41, 0x44, 0x89, 0x8b, 0x8b, 0xc1, 0xba, 0x8b, 0x10,
-	0x02, 0x0a, 0x03, 0x7d, 0x01, 0x46, 0x9a, 0xee, 0x9e, 0x1b, 0x05, 0xa1, 0xd8, 0x2c, 0xc7, 0x74,
-	0x14, 0x48, 0xce, 0xc1, 0x2a, 0x27, 0x83, 0x25, 0x3d, 0xfb, 0x87, 0x0a, 0x30, 0x21, 0x5b, 0x7c,
-	0xb3, 0x13, 0xc4, 0xce, 0x29, 0x5c, 0xcb, 0x37, 0x8c, 0x6b, 0xf9, 0x13, 0xbd, 0xe2, 0x28, 0xb0,
-	0x2e, 0xe5, 0x5e, 0xc7, 0x77, 0x52, 0xd7, 0xf1, 0xd3, 0xfd, 0x49, 0xf5, 0xbe, 0x86, 0xff, 0x99,
-	0x05, 0x33, 0x06, 0xfe, 0x29, 0xdc, 0x06, 0x2b, 0xe6, 0x6d, 0xf0, 0x64, 0xdf, 0x6f, 0xc8, 0xb9,
-	0x05, 0xbe, 0xaf, 0x98, 0xea, 0x3b, 0x3b, 0xfd, 0xdf, 0x83, 0xd2, 0xb6, 0x13, 0x36, 0x7b, 0xc5,
-	0x6b, 0xed, 0xaa, 0x34, 0x7f, 0xd3, 0x09, 0x9b, 0xfc, 0x0c, 0x7f, 0x4e, 0x25, 0x7a, 0x74, 0xc2,
-	0x66, 0x5f, 0x8f, 0x2e, 0xd6, 0x14, 0x7a, 0x15, 0x86, 0xa3, 0x46, 0xd0, 0x56, 0xf6, 0x96, 0x97,
-	0x79, 0x12, 0x48, 0x5a, 0x72, 0x74, 0x50, 0x41, 0x66, 0x73, 0xb4, 0x18, 0x0b, 0x7c, 0xf4, 0x36,
-	0x4c, 0xb0, 0x5f, 0xca, 0xee, 0xa0, 0x98, 0x9f, 0x25, 0xa0, 0xae, 0x23, 0x72, 0xf3, 0x15, 0xa3,
-	0x08, 0x9b, 0xa4, 0xe6, 0x5a, 0x50, 0x56, 0x9f, 0xf5, 0x48, 0x3d, 0x71, 0xfe, 0x5d, 0x11, 0xce,
-	0x64, 0xac, 0x39, 0x14, 0x19, 0x33, 0xf1, 0xc2, 0x80, 0x4b, 0xf5, 0x03, 0xce, 0x45, 0xc4, 0xa4,
-	0xa1, 0xa6, 0x58, 0x5b, 0x03, 0x37, 0x7a, 0x37, 0x22, 0xe9, 0x46, 0x69, 0x51, 0xff, 0x46, 0x69,
-	0x63, 0xa7, 0x36, 0xd4, 0xb4, 0x21, 0xd5, 0xd3, 0x47, 0x3a, 0xa7, 0x7f, 0x5c, 0x84, 0xb3, 0x59,
-	0xa1, 0x5d, 0xd0, 0x77, 0xa7, 0xb2, 0xc1, 0xbc, 0x34, 0x68, 0x50, 0x18, 0x9e, 0x22, 0x46, 0xe4,
-	0x36, 0x9e, 0x37, 0xf3, 0xc3, 0xf4, 0x1d, 0x66, 0xd1, 0x26, 0x73, 0xdf, 0x0c, 0x79, 0x16, 0x1f,
-	0x79, 0x7c, 0x7c, 0x7a, 0xe0, 0x0e, 0x88, 0xf4, 0x3f, 0x51, 0xca, 0x7d, 0x53, 0x16, 0xf7, 0x77,
-	0xdf, 0x94, 0x2d, 0xcf, 0xb9, 0x30, 0xa6, 0x7d, 0xcd, 0x23, 0x9d, 0xf1, 0x1d, 0x7a, 0x5b, 0x69,
-	0xfd, 0x7e, 0xa4, 0xb3, 0xfe, 0xe3, 0x16, 0xa4, 0x8c, 0x1b, 0x95, 0xba, 0xcb, 0xca, 0x55, 0x77,
-	0x5d, 0x86, 0x52, 0x18, 0x78, 0x24, 0x9d, 0xa0, 0x05, 0x07, 0x1e, 0xc1, 0x0c, 0x42, 0x31, 0xe2,
-	0x44, 0xd9, 0x31, 0xae, 0x0b, 0x72, 0x42, 0x44, 0x7b, 0x0a, 0x86, 0x3c, 0xb2, 0x47, 0xbc, 0x74,
-	0xf4, 0xf3, 0xdb, 0xb4, 0x10, 0x73, 0x98, 0xfd, 0xcb, 0x25, 0xb8, 0xd8, 0xd3, 0x01, 0x9a, 0x8a,
-	0x43, 0x2d, 0x27, 0x26, 0xf7, 0x9d, 0xfd, 0x74, 0x98, 0xe2, 0x1b, 0xbc, 0x18, 0x4b, 0x38, 0xb3,
-	0xf7, 0xe6, 0x61, 0x09, 0x53, 0xca, 0x41, 0x11, 0x8d, 0x50, 0x40, 0x1f, 0x41, 0x5e, 0xf7, 0xeb,
-	0x00, 0x51, 0xe4, 0x2d, 0xfb, 0x94, 0xbb, 0x6b, 0x0a, 0x43, 0xf2, 0x24, 0x7c, 0x65, 0xfd, 0xb6,
-	0x80, 0x60, 0x0d, 0x0b, 0x55, 0x61, 0xba, 0x1d, 0x06, 0x31, 0xd7, 0xb5, 0x56, 0xb9, 0x99, 0xcf,
-	0x90, 0xe9, 0x7b, 0x5a, 0x4b, 0xc1, 0x71, 0x57, 0x0d, 0xf4, 0x32, 0x8c, 0x09, 0x7f, 0xd4, 0x5a,
-	0x10, 0x78, 0x42, 0x0d, 0xa4, 0x8c, 0x46, 0xea, 0x09, 0x08, 0xeb, 0x78, 0x5a, 0x35, 0xa6, 0xc0,
-	0x1d, 0xc9, 0xac, 0xc6, 0x95, 0xb8, 0x1a, 0x5e, 0x2a, 0xcc, 0xd3, 0xe8, 0x40, 0x61, 0x9e, 0x12,
-	0xc5, 0x58, 0x79, 0xe0, 0x37, 0x2b, 0xe8, 0xab, 0x4a, 0xfa, 0x85, 0x12, 0x9c, 0x11, 0x0b, 0xe7,
-	0x51, 0x2f, 0x97, 0x47, 0x94, 0x7d, 0xfe, 0x5b, 0x6b, 0xe6, 0xb4, 0xd7, 0xcc, 0x0f, 0x5b, 0x60,
-	0xb2, 0x57, 0xe8, 0xff, 0xcb, 0x8d, 0xf3, 0xfe, 0x72, 0x2e, 0xbb, 0xd6, 0x94, 0x17, 0xc8, 0x07,
-	0x8c, 0xf8, 0x6e, 0xff, 0x07, 0x0b, 0x9e, 0xec, 0x4b, 0x11, 0x2d, 0x43, 0x99, 0xf1, 0x80, 0x9a,
-	0x74, 0xf6, 0xb4, 0x32, 0x03, 0x94, 0x80, 0x1c, 0x96, 0x34, 0xa9, 0x89, 0x96, 0xbb, 0x02, 0xea,
-	0x3f, 0x93, 0x11, 0x50, 0xff, 0x9c, 0x31, 0x3c, 0x0f, 0x19, 0x51, 0xff, 0x6b, 0x45, 0x18, 0xe6,
-	0x2b, 0xfe, 0x14, 0xc4, 0xb0, 0x15, 0xa1, 0xb7, 0xed, 0x11, 0x47, 0x8a, 0xf7, 0x65, 0xbe, 0xea,
-	0xc4, 0x0e, 0x67, 0x13, 0xd4, 0x6d, 0x95, 0x68, 0x78, 0xd1, 0xbc, 0x71, 0x9f, 0xcd, 0xa5, 0x14,
-	0x93, 0xc0, 0x69, 0x68, 0xb7, 0xdb, 0x97, 0x00, 0x22, 0x96, 0x68, 0x9e, 0xd2, 0x10, 0x11, 0xc9,
-	0x3e, 0xd9, 0xa3, 0xf5, 0xba, 0x42, 0xe6, 0x7d, 0x48, 0x76, 0xba, 0x02, 0x60, 0x8d, 0xe2, 0xdc,
-	0x2b, 0x50, 0x56, 0xc8, 0xfd, 0xb4, 0x38, 0xe3, 0x3a, 0x73, 0xf1, 0x39, 0x98, 0x4a, 0xb5, 0x75,
-	0x2c, 0x25, 0xd0, 0xaf, 0x58, 0x30, 0xc5, 0xbb, 0xbc, 0xec, 0xef, 0x89, 0x33, 0xf5, 0x7d, 0x38,
-	0xeb, 0x65, 0x9c, 0x6d, 0x62, 0x46, 0x07, 0x3f, 0x0b, 0x95, 0xd2, 0x27, 0x0b, 0x8a, 0x33, 0xdb,
-	0x40, 0x57, 0xe9, 0xba, 0xa5, 0x67, 0x97, 0xe3, 0x09, 0xdf, 0xa1, 0x71, 0xbe, 0x66, 0x79, 0x19,
-	0x56, 0x50, 0xfb, 0x77, 0x2c, 0x98, 0xe1, 0x3d, 0xbf, 0x45, 0xf6, 0xd5, 0x0e, 0xff, 0x30, 0xfb,
-	0x2e, 0x72, 0x5c, 0x14, 0x72, 0x72, 0x5c, 0xe8, 0x9f, 0x56, 0xec, 0xf9, 0x69, 0x3f, 0x6f, 0x81,
-	0x58, 0x81, 0xa7, 0x20, 0xca, 0x7f, 0xbb, 0x29, 0xca, 0xcf, 0xe5, 0x2f, 0xea, 0x1c, 0x19, 0xfe,
-	0x4f, 0x2d, 0x98, 0xe6, 0x08, 0xc9, 0x5b, 0xf2, 0x87, 0x3a, 0x0f, 0x83, 0x24, 0xab, 0x53, 0xd9,
-	0xa9, 0xb3, 0x3f, 0xca, 0x98, 0xac, 0x52, 0xcf, 0xc9, 0x6a, 0xca, 0x0d, 0x74, 0x8c, 0x24, 0x8c,
-	0xc7, 0x8e, 0x15, 0x6d, 0xff, 0x91, 0x05, 0x88, 0x37, 0x63, 0xb0, 0x3f, 0x94, 0xa9, 0x60, 0xa5,
-	0xda, 0x75, 0x91, 0x1c, 0x35, 0x0a, 0x82, 0x35, 0xac, 0x13, 0x19, 0x9e, 0x94, 0x41, 0x40, 0xb1,
-	0xbf, 0x41, 0xc0, 0x31, 0x46, 0xf4, 0x6b, 0x25, 0x48, 0x1b, 0xf3, 0xa3, 0x7b, 0x30, 0xde, 0x70,
-	0xda, 0xce, 0xa6, 0xeb, 0xb9, 0xb1, 0x4b, 0xa2, 0x5e, 0x96, 0x44, 0x4b, 0x1a, 0x9e, 0x78, 0xea,
-	0xd5, 0x4a, 0xb0, 0x41, 0x07, 0xcd, 0x03, 0xb4, 0x43, 0x77, 0xcf, 0xf5, 0x48, 0x8b, 0x69, 0x1c,
-	0x98, 0xb7, 0x22, 0x37, 0x8f, 0x91, 0xa5, 0x58, 0xc3, 0xc8, 0x70, 0x3c, 0x2b, 0x3e, 0x3a, 0xc7,
-	0xb3, 0xd2, 0x31, 0x1d, 0xcf, 0x86, 0x06, 0x72, 0x3c, 0xc3, 0x70, 0x5e, 0xb2, 0x48, 0xf4, 0xff,
-	0x8a, 0xeb, 0x11, 0xc1, 0x17, 0x73, 0x1f, 0xc6, 0xb9, 0xc3, 0x83, 0xca, 0x79, 0x9c, 0x89, 0x81,
-	0x73, 0x6a, 0xa2, 0xcf, 0xc3, 0xac, 0xe3, 0x79, 0xc1, 0x7d, 0x35, 0x6a, 0xcb, 0x51, 0xc3, 0xf1,
-	0xb8, 0xc6, 0x7e, 0x84, 0x51, 0x7d, 0xe2, 0xf0, 0xa0, 0x32, 0xbb, 0x90, 0x83, 0x83, 0x73, 0x6b,
-	0xa7, 0xfc, 0xd6, 0x46, 0xfb, 0xf9, 0xad, 0xd9, 0x3b, 0x70, 0xa6, 0x4e, 0x42, 0x97, 0xa5, 0x88,
-	0x6c, 0x26, 0x5b, 0x72, 0x03, 0xca, 0x61, 0xea, 0x10, 0x1a, 0x28, 0xb0, 0x91, 0x16, 0x06, 0x57,
-	0x1e, 0x3a, 0x09, 0x21, 0xfb, 0x4f, 0x2c, 0x18, 0x11, 0x0e, 0x05, 0xa7, 0xc0, 0xfb, 0x2c, 0x18,
-	0x2a, 0xe8, 0x4a, 0xf6, 0x41, 0xcd, 0x3a, 0x93, 0xab, 0x7c, 0x5e, 0x4d, 0x29, 0x9f, 0x9f, 0xec,
-	0x45, 0xa4, 0xb7, 0xda, 0xf9, 0x6f, 0x15, 0x61, 0xd2, 0x74, 0xa6, 0x38, 0x85, 0x21, 0x58, 0x87,
-	0x91, 0x48, 0x78, 0xee, 0x14, 0xf2, 0x6d, 0x9f, 0xd3, 0x93, 0x98, 0x18, 0x36, 0x09, 0x5f, 0x1d,
-	0x49, 0x24, 0xd3, 0x25, 0xa8, 0xf8, 0x08, 0x5d, 0x82, 0xfa, 0xf9, 0xb3, 0x94, 0x4e, 0xc2, 0x9f,
-	0xc5, 0xfe, 0x3a, 0xbb, 0x2c, 0xf4, 0xf2, 0x53, 0xe0, 0x23, 0x6e, 0x98, 0xd7, 0x8a, 0xdd, 0x63,
-	0x65, 0x89, 0x4e, 0xe5, 0xf0, 0x13, 0xbf, 0x64, 0xc1, 0xc5, 0x8c, 0xaf, 0xd2, 0x98, 0x8b, 0xe7,
-	0x60, 0xd4, 0xe9, 0x34, 0x5d, 0xb5, 0x97, 0xb5, 0x87, 0xa8, 0x05, 0x51, 0x8e, 0x15, 0x06, 0x5a,
-	0x82, 0x19, 0xf2, 0xa0, 0xed, 0xf2, 0x97, 0x40, 0xdd, 0xfa, 0xb0, 0xc8, 0x43, 0xbc, 0x2e, 0xa7,
-	0x81, 0xb8, 0x1b, 0x5f, 0xb9, 0x43, 0x17, 0x73, 0xdd, 0xa1, 0xff, 0xa1, 0x05, 0x63, 0xa2, 0xdb,
-	0xa7, 0x30, 0xda, 0xdf, 0x61, 0x8e, 0xf6, 0xe3, 0x3d, 0x46, 0x3b, 0x67, 0x98, 0xff, 0x4e, 0x41,
-	0xf5, 0xb7, 0x16, 0x84, 0xf1, 0x00, 0x4c, 0xcb, 0xab, 0x30, 0xda, 0x0e, 0x83, 0x38, 0x68, 0x04,
-	0x9e, 0xe0, 0x59, 0x9e, 0x48, 0xbc, 0xf5, 0x79, 0xf9, 0x91, 0xf6, 0x1b, 0x2b, 0x6c, 0x36, 0x7a,
-	0x41, 0x18, 0x0b, 0x3e, 0x21, 0x19, 0xbd, 0x20, 0x8c, 0x31, 0x83, 0xa0, 0x26, 0x40, 0xec, 0x84,
-	0x2d, 0x12, 0xd3, 0x32, 0x11, 0xf8, 0x23, 0xff, 0xf0, 0xe8, 0xc4, 0xae, 0x37, 0xef, 0xfa, 0x71,
-	0x14, 0x87, 0xf3, 0xab, 0x7e, 0x7c, 0x27, 0xe4, 0x22, 0x90, 0xe6, 0x7e, 0xaf, 0x68, 0x61, 0x8d,
-	0xae, 0xf4, 0x91, 0x64, 0x6d, 0x0c, 0x99, 0x4f, 0xda, 0xeb, 0xa2, 0x1c, 0x2b, 0x0c, 0xfb, 0x15,
-	0x76, 0x95, 0xb0, 0x01, 0x3a, 0x9e, 0x67, 0xfc, 0x37, 0x46, 0xd5, 0xd0, 0xb2, 0xf7, 0xac, 0xaa,
-	0xee, 0x7f, 0xdf, 0xfb, 0xe4, 0xa6, 0x0d, 0xeb, 0x9e, 0x30, 0x89, 0x93, 0x3e, 0xfa, 0xce, 0x2e,
-	0x4b, 0x87, 0xe7, 0xfb, 0x5c, 0x01, 0xc7, 0xb0, 0x6d, 0x60, 0x61, 0xa7, 0x59, 0x78, 0xde, 0xd5,
-	0x9a, 0x58, 0xe4, 0x5a, 0xd8, 0x69, 0x01, 0xc0, 0x09, 0x0e, 0xba, 0x26, 0x04, 0xe8, 0x92, 0x91,
-	0x1d, 0x4e, 0x0a, 0xd0, 0xf2, 0xf3, 0x35, 0x09, 0xfa, 0x05, 0x18, 0x53, 0x59, 0xe2, 0x6a, 0x3c,
-	0xd9, 0x96, 0x08, 0x83, 0xb2, 0x9c, 0x14, 0x63, 0x1d, 0x07, 0x6d, 0xc0, 0x54, 0xc4, 0xb5, 0x27,
-	0x2a, 0xda, 0x1d, 0xd7, 0x42, 0x7d, 0x52, 0x5a, 0x48, 0xd4, 0x4d, 0xf0, 0x11, 0x2b, 0xe2, 0x47,
-	0x87, 0x74, 0x74, 0x4c, 0x93, 0x40, 0xaf, 0xc3, 0xa4, 0xa7, 0xe7, 0x5a, 0xaf, 0x09, 0x25, 0x95,
-	0x32, 0x20, 0x36, 0x32, 0xb1, 0xd7, 0x70, 0x0a, 0x9b, 0xf2, 0x3a, 0x7a, 0x89, 0x88, 0xd0, 0xe8,
-	0xf8, 0x2d, 0x12, 0x89, 0x1c, 0x57, 0x8c, 0xd7, 0xb9, 0x9d, 0x83, 0x83, 0x73, 0x6b, 0xa3, 0x57,
-	0x61, 0x5c, 0x7e, 0xbe, 0xe6, 0xc6, 0x9b, 0x98, 0xa9, 0x6b, 0x30, 0x6c, 0x60, 0xa2, 0xfb, 0x70,
-	0x4e, 0xfe, 0xdf, 0x08, 0x9d, 0xad, 0x2d, 0xb7, 0x21, 0xbc, 0xa8, 0xb9, 0xaf, 0xce, 0x82, 0x74,
-	0xfe, 0x59, 0xce, 0x42, 0x3a, 0x3a, 0xa8, 0x5c, 0x16, 0xa3, 0x96, 0x09, 0x67, 0x93, 0x98, 0x4d,
-	0x1f, 0xad, 0xc1, 0x99, 0x6d, 0xe2, 0x78, 0xf1, 0xf6, 0xd2, 0x36, 0x69, 0xec, 0xc8, 0x4d, 0xc4,
-	0x9c, 0x83, 0x35, 0xe3, 0xee, 0x9b, 0xdd, 0x28, 0x38, 0xab, 0x1e, 0x7a, 0x07, 0x66, 0xdb, 0x9d,
-	0x4d, 0xcf, 0x8d, 0xb6, 0xd7, 0x83, 0x98, 0x19, 0x65, 0xa8, 0x24, 0x6b, 0xc2, 0x8b, 0x58, 0x39,
-	0x46, 0xd7, 0x72, 0xf0, 0x70, 0x2e, 0x05, 0xf4, 0x3e, 0x9c, 0x4b, 0x2d, 0x06, 0xe1, 0xd3, 0x38,
-	0x99, 0x1f, 0xef, 0xb6, 0x9e, 0x55, 0x41, 0xf8, 0x28, 0x66, 0x81, 0x70, 0x76, 0x13, 0x1f, 0xcc,
-	0x54, 0xe7, 0x3d, 0x5a, 0x59, 0x63, 0xca, 0xd0, 0x97, 0x61, 0x5c, 0x5f, 0x45, 0xe2, 0x82, 0xb9,
-	0x92, 0xcd, 0xb3, 0x68, 0xab, 0x8d, 0xb3, 0x74, 0x6a, 0x45, 0xe9, 0x30, 0x6c, 0x50, 0xb4, 0x09,
-	0x64, 0x7f, 0x1f, 0xba, 0x0d, 0xa3, 0x0d, 0xcf, 0x25, 0x7e, 0xbc, 0x5a, 0xeb, 0x15, 0x74, 0x63,
-	0x49, 0xe0, 0x88, 0x01, 0x13, 0x01, 0x42, 0x79, 0x19, 0x56, 0x14, 0xec, 0xdf, 0x28, 0x40, 0xa5,
-	0x4f, 0xb4, 0xd9, 0x94, 0x46, 0xd9, 0x1a, 0x48, 0xa3, 0xbc, 0x20, 0x53, 0xc6, 0xad, 0xa7, 0xc4,
-	0xec, 0x54, 0x3a, 0xb8, 0x44, 0xd8, 0x4e, 0xe3, 0x0f, 0x6c, 0xe1, 0xab, 0x2b, 0xa5, 0x4b, 0x7d,
-	0x6d, 0xcf, 0x8d, 0xc7, 0xa8, 0xa1, 0xc1, 0x05, 0x91, 0xdc, 0x87, 0x05, 0xfb, 0xeb, 0x05, 0x38,
-	0xa7, 0x86, 0xf0, 0x2f, 0xee, 0xc0, 0xdd, 0xed, 0x1e, 0xb8, 0x13, 0x78, 0x96, 0xb1, 0xef, 0xc0,
-	0x30, 0x0f, 0x5a, 0x32, 0x00, 0x03, 0xf4, 0x94, 0x19, 0xe1, 0x4a, 0x5d, 0xd3, 0x46, 0x94, 0xab,
-	0xbf, 0x62, 0xc1, 0xd4, 0xc6, 0x52, 0xad, 0x1e, 0x34, 0x76, 0x48, 0xbc, 0xc0, 0x19, 0x56, 0x2c,
-	0xf8, 0x1f, 0xeb, 0x21, 0xf9, 0x9a, 0x2c, 0x8e, 0xe9, 0x32, 0x94, 0xb6, 0x83, 0x28, 0x4e, 0xbf,
-	0xd9, 0xde, 0x0c, 0xa2, 0x18, 0x33, 0x88, 0xfd, 0xbb, 0x16, 0x0c, 0xb1, 0x44, 0xa7, 0xfd, 0xb2,
-	0xef, 0x0e, 0xf2, 0x5d, 0xe8, 0x65, 0x18, 0x26, 0x5b, 0x5b, 0xa4, 0x11, 0x8b, 0x59, 0x95, 0x0e,
-	0xa5, 0xc3, 0xcb, 0xac, 0x94, 0x5e, 0xfa, 0xac, 0x31, 0xfe, 0x17, 0x0b, 0x64, 0xf4, 0x16, 0x94,
-	0x63, 0x77, 0x97, 0x2c, 0x34, 0x9b, 0xe2, 0xd5, 0xeb, 0x21, 0xfc, 0x77, 0x37, 0x24, 0x01, 0x9c,
-	0xd0, 0xb2, 0xbf, 0x5a, 0x00, 0x48, 0x5c, 0xef, 0xfb, 0x7d, 0xe2, 0x62, 0xd7, 0x7b, 0xc8, 0x95,
-	0x8c, 0xf7, 0x10, 0x94, 0x10, 0xcc, 0x78, 0x0c, 0x51, 0xc3, 0x54, 0x1c, 0x68, 0x98, 0x4a, 0xc7,
-	0x19, 0xa6, 0x25, 0x98, 0x49, 0x42, 0x07, 0x98, 0x71, 0x54, 0x98, 0x90, 0xb2, 0x91, 0x06, 0xe2,
-	0x6e, 0x7c, 0x9b, 0xc0, 0x65, 0x19, 0xd1, 0x52, 0xde, 0x35, 0xcc, 0xa8, 0xf2, 0x18, 0x89, 0x98,
-	0x93, 0x07, 0x9f, 0x42, 0xee, 0x83, 0xcf, 0x4f, 0x59, 0x70, 0x36, 0xdd, 0x0e, 0xf3, 0x5e, 0xfb,
-	0x01, 0x0b, 0xce, 0xb1, 0x67, 0x2f, 0xd6, 0x6a, 0xf7, 0x23, 0xdb, 0x4b, 0xd9, 0x21, 0x15, 0x7a,
-	0xf7, 0x38, 0xf1, 0x5c, 0x5e, 0xcb, 0x22, 0x8d, 0xb3, 0x5b, 0xb4, 0xbf, 0xdf, 0x02, 0xe1, 0x24,
-	0x34, 0xc0, 0xc6, 0x7e, 0x5b, 0xa6, 0x2a, 0x35, 0x02, 0x78, 0x5f, 0xce, 0xf7, 0x9a, 0x12, 0x61,
-	0xbb, 0xd5, 0x45, 0x6a, 0x04, 0xeb, 0x36, 0x68, 0xd9, 0x4d, 0x10, 0xd0, 0x2a, 0x61, 0x7a, 0xa2,
-	0xfe, 0xbd, 0xb9, 0x0e, 0xd0, 0x64, 0xb8, 0x5a, 0xc2, 0x42, 0x75, 0x6c, 0x57, 0x15, 0x04, 0x6b,
-	0x58, 0xf6, 0x8f, 0x14, 0x60, 0x4c, 0x06, 0x8c, 0xee, 0xf8, 0x83, 0x48, 0x73, 0xc7, 0xca, 0x1b,
-	0xc3, 0x32, 0x7c, 0x52, 0xc2, 0xb5, 0x44, 0x08, 0x4e, 0x32, 0x7c, 0x4a, 0x00, 0x4e, 0x70, 0xd0,
-	0x33, 0x30, 0x12, 0x75, 0x36, 0x19, 0x7a, 0xca, 0xf5, 0xa5, 0xce, 0x8b, 0xb1, 0x84, 0xa3, 0xcf,
-	0xc3, 0x34, 0xaf, 0x17, 0x06, 0x6d, 0xa7, 0xc5, 0x95, 0x86, 0x43, 0xca, 0x17, 0x75, 0x7a, 0x2d,
-	0x05, 0x3b, 0x3a, 0xa8, 0x9c, 0x4d, 0x97, 0x31, 0x75, 0x73, 0x17, 0x15, 0xfb, 0xcb, 0x80, 0xba,
-	0x63, 0x60, 0xa3, 0x37, 0xb8, 0x01, 0x92, 0x1b, 0x92, 0x66, 0x2f, 0x3d, 0xb2, 0xee, 0x3a, 0x29,
-	0xcd, 0xcf, 0x79, 0x2d, 0xac, 0xea, 0xdb, 0x7f, 0xad, 0x08, 0xd3, 0x69, 0x47, 0x3a, 0x74, 0x13,
-	0x86, 0xf9, 0x05, 0x23, 0xc8, 0xf7, 0x78, 0xa6, 0xd4, 0xdc, 0xef, 0xd8, 0x56, 0x13, 0x77, 0x94,
-	0xa8, 0x8f, 0xde, 0x81, 0xb1, 0x66, 0x70, 0xdf, 0xbf, 0xef, 0x84, 0xcd, 0x85, 0xda, 0xaa, 0x58,
-	0x97, 0x99, 0x7c, 0x6a, 0x35, 0x41, 0xd3, 0x5d, 0xfa, 0x98, 0x4a, 0x3e, 0x01, 0x61, 0x9d, 0x1c,
-	0xda, 0x60, 0x71, 0xfd, 0xb6, 0xdc, 0xd6, 0x9a, 0xd3, 0xee, 0x65, 0x8d, 0xba, 0x24, 0x91, 0x34,
-	0xca, 0x13, 0x22, 0xf8, 0x1f, 0x07, 0xe0, 0x84, 0x10, 0xfa, 0x6e, 0x38, 0x13, 0xe5, 0xa8, 0xb6,
-	0xf2, 0x52, 0x22, 0xf4, 0xd2, 0xf6, 0x2c, 0x3e, 0x46, 0x25, 0x88, 0x2c, 0x25, 0x58, 0x56, 0x33,
-	0xf6, 0x57, 0xce, 0x80, 0xb1, 0x1b, 0x8d, 0xbc, 0x38, 0xd6, 0x09, 0xe5, 0xc5, 0xc1, 0x30, 0x4a,
-	0x76, 0xdb, 0xf1, 0x7e, 0xd5, 0x0d, 0x7b, 0x25, 0x56, 0x5b, 0x16, 0x38, 0xdd, 0x34, 0x25, 0x04,
-	0x2b, 0x3a, 0xd9, 0xc9, 0x8b, 0x8a, 0x1f, 0x62, 0xf2, 0xa2, 0xd2, 0x29, 0x26, 0x2f, 0x5a, 0x87,
-	0x91, 0x96, 0x1b, 0x63, 0xd2, 0x0e, 0x04, 0x6b, 0x97, 0xb9, 0x0e, 0x6f, 0x70, 0x94, 0xee, 0x84,
-	0x19, 0x02, 0x80, 0x25, 0x11, 0xf4, 0x86, 0xda, 0x81, 0xc3, 0xf9, 0x92, 0x51, 0xf7, 0x7b, 0x5a,
-	0xe6, 0x1e, 0x14, 0xc9, 0x8a, 0x46, 0x1e, 0x36, 0x59, 0xd1, 0x8a, 0x4c, 0x31, 0x34, 0x9a, 0x6f,
-	0x3a, 0xce, 0x32, 0x08, 0xf5, 0x49, 0x2c, 0x64, 0x24, 0x63, 0x2a, 0x9f, 0x5c, 0x32, 0xa6, 0xef,
-	0xb7, 0xe0, 0x5c, 0x3b, 0x2b, 0x2f, 0x99, 0x48, 0x0c, 0xf4, 0xf2, 0xc0, 0x89, 0xd7, 0x8c, 0x06,
-	0x99, 0x88, 0x9c, 0x89, 0x86, 0xb3, 0x9b, 0xa3, 0x03, 0x1d, 0x6e, 0x36, 0x45, 0x36, 0xa1, 0xa7,
-	0x72, 0xb2, 0x3a, 0xf5, 0xc8, 0xe5, 0xb4, 0x91, 0x91, 0x41, 0xe8, 0xe3, 0x79, 0x19, 0x84, 0x06,
-	0xce, 0x1b, 0xf4, 0x86, 0xca, 0xe7, 0x34, 0x91, 0xbf, 0x94, 0x78, 0xb6, 0xa6, 0xbe, 0x59, 0x9c,
-	0xde, 0x50, 0x59, 0x9c, 0x7a, 0xc4, 0x37, 0xe3, 0x39, 0x9a, 0xfa, 0xe6, 0x6e, 0xd2, 0xf2, 0x2f,
-	0x4d, 0x9d, 0x4c, 0xfe, 0x25, 0xe3, 0xaa, 0xe1, 0x29, 0x80, 0x9e, 0xed, 0x73, 0xd5, 0x18, 0x74,
-	0x7b, 0x5f, 0x36, 0x3c, 0xd7, 0xd4, 0xcc, 0x43, 0xe5, 0x9a, 0xba, 0xa7, 0xe7, 0x6e, 0x42, 0x7d,
-	0x92, 0x13, 0x51, 0xa4, 0x01, 0x33, 0x36, 0xdd, 0xd3, 0x2f, 0xc0, 0x33, 0xf9, 0x74, 0xd5, 0x3d,
-	0xd7, 0x4d, 0x37, 0xf3, 0x0a, 0xec, 0xca, 0x04, 0x75, 0xf6, 0x74, 0x32, 0x41, 0x9d, 0x3b, 0xf1,
-	0x4c, 0x50, 0xe7, 0x4f, 0x21, 0x13, 0xd4, 0x63, 0x1f, 0x6a, 0x26, 0xa8, 0xd9, 0x47, 0x90, 0x09,
-	0x6a, 0x3d, 0xc9, 0x04, 0x75, 0x21, 0x7f, 0x4a, 0x32, 0xec, 0x59, 0x73, 0xf2, 0x3f, 0xdd, 0x83,
-	0x72, 0x5b, 0x46, 0x7a, 0x10, 0x01, 0xd8, 0xb2, 0x93, 0xd1, 0x66, 0x85, 0x83, 0xe0, 0x53, 0xa2,
-	0x40, 0x38, 0x21, 0x45, 0xe9, 0x26, 0xf9, 0xa0, 0x1e, 0xef, 0xa1, 0x04, 0xcd, 0x52, 0x2f, 0xe5,
-	0x67, 0x81, 0xb2, 0xff, 0x6a, 0x01, 0x2e, 0xf5, 0x5e, 0xd7, 0x89, 0x6e, 0xaa, 0x96, 0xbc, 0xa5,
-	0xa4, 0x74, 0x53, 0x5c, 0xc8, 0x49, 0xb0, 0x06, 0x0e, 0x87, 0x73, 0x03, 0x66, 0x94, 0x21, 0xab,
-	0xe7, 0x36, 0xf6, 0xb5, 0x24, 0xb5, 0xca, 0x61, 0xaf, 0x9e, 0x46, 0xc0, 0xdd, 0x75, 0xd0, 0x02,
-	0x4c, 0x19, 0x85, 0xab, 0x55, 0x21, 0xcc, 0x28, 0x65, 0x58, 0xdd, 0x04, 0xe3, 0x34, 0xbe, 0xfd,
-	0x73, 0x16, 0x3c, 0x96, 0x93, 0x24, 0x61, 0xe0, 0x68, 0x2f, 0x5b, 0x30, 0xd5, 0x36, 0xab, 0xf6,
-	0x09, 0x0a, 0x65, 0xa4, 0x62, 0x50, 0x7d, 0x4d, 0x01, 0x70, 0x9a, 0xe8, 0xe2, 0xd5, 0xdf, 0xfa,
-	0xfd, 0x4b, 0x1f, 0xfb, 0xed, 0xdf, 0xbf, 0xf4, 0xb1, 0xdf, 0xf9, 0xfd, 0x4b, 0x1f, 0xfb, 0xff,
-	0x0f, 0x2f, 0x59, 0xbf, 0x75, 0x78, 0xc9, 0xfa, 0xed, 0xc3, 0x4b, 0xd6, 0xef, 0x1c, 0x5e, 0xb2,
-	0x7e, 0xef, 0xf0, 0x92, 0xf5, 0xd5, 0x3f, 0xb8, 0xf4, 0xb1, 0xb7, 0x0b, 0x7b, 0x2f, 0xfc, 0xbf,
-	0x00, 0x00, 0x00, 0xff, 0xff, 0x41, 0x99, 0x07, 0x31, 0x7e, 0xe5, 0x00, 0x00,
+	0x76, 0x18, 0xbc, 0xd5, 0xdd, 0x7c, 0xf4, 0xe1, 0xfb, 0xce, 0x8b, 0x43, 0xcd, 0x4c, 0x8f, 0x4a,
+	0xbb, 0xa3, 0xd1, 0x4a, 0x22, 0x57, 0x23, 0x69, 0x25, 0xaf, 0x76, 0x65, 0x93, 0x6c, 0x72, 0x86,
+	0x9a, 0x21, 0xa7, 0x75, 0x9b, 0x33, 0xda, 0x95, 0xb5, 0xeb, 0x2d, 0x76, 0x5f, 0x92, 0x25, 0x16,
+	0xab, 0x5a, 0x55, 0xd5, 0x9c, 0xa1, 0x3e, 0x1b, 0xf8, 0xb2, 0x8e, 0x9d, 0xf8, 0x81, 0x60, 0x11,
+	0x1b, 0x79, 0xd8, 0x86, 0x03, 0x38, 0x0e, 0x6c, 0xc7, 0x49, 0x10, 0xc7, 0x8e, 0xed, 0xec, 0xda,
+	0x89, 0xe3, 0x24, 0x80, 0xf3, 0x67, 0xe3, 0x04, 0x08, 0xd6, 0x80, 0x11, 0xc6, 0xa6, 0x8d, 0x04,
+	0xfe, 0x91, 0x07, 0xe2, 0xfc, 0x31, 0x63, 0xc4, 0xc1, 0x7d, 0xd6, 0xbd, 0xd5, 0x55, 0xdd, 0xcd,
+	0x11, 0x87, 0x92, 0x8d, 0xfd, 0xd7, 0x7d, 0xcf, 0xb9, 0xe7, 0xde, 0xba, 0xcf, 0x73, 0xce, 0x3d,
+	0x0f, 0x78, 0x6d, 0xe7, 0xd5, 0x68, 0xd6, 0x0d, 0xe6, 0x76, 0xda, 0x1b, 0x24, 0xf4, 0x49, 0x4c,
+	0xa2, 0xb9, 0x3d, 0xe2, 0x37, 0x83, 0x70, 0x4e, 0x00, 0x9c, 0x96, 0x3b, 0xd7, 0x08, 0x42, 0x32,
+	0xb7, 0xf7, 0xc2, 0xdc, 0x16, 0xf1, 0x49, 0xe8, 0xc4, 0xa4, 0x39, 0xdb, 0x0a, 0x83, 0x38, 0x40,
+	0x88, 0xe3, 0xcc, 0x3a, 0x2d, 0x77, 0x96, 0xe2, 0xcc, 0xee, 0xbd, 0x30, 0xf3, 0xfc, 0x96, 0x1b,
+	0x6f, 0xb7, 0x37, 0x66, 0x1b, 0xc1, 0xee, 0xdc, 0x56, 0xb0, 0x15, 0xcc, 0x31, 0xd4, 0x8d, 0xf6,
+	0x26, 0xfb, 0xc7, 0xfe, 0xb0, 0x5f, 0x9c, 0xc4, 0xcc, 0x6a, 0xd2, 0x0c, 0x79, 0x18, 0x13, 0x3f,
+	0x72, 0x03, 0x3f, 0x7a, 0xde, 0x69, 0xb9, 0x11, 0x09, 0xf7, 0x48, 0x38, 0xd7, 0xda, 0xd9, 0xa2,
+	0xb0, 0xc8, 0x44, 0x98, 0xdb, 0x7b, 0x61, 0x83, 0xc4, 0x4e, 0x47, 0x8f, 0x66, 0x5e, 0x4a, 0xc8,
+	0xed, 0x3a, 0x8d, 0x6d, 0xd7, 0x27, 0xe1, 0xbe, 0xa4, 0x31, 0x17, 0x92, 0x28, 0x68, 0x87, 0x0d,
+	0x72, 0xac, 0x5a, 0xd1, 0xdc, 0x2e, 0x89, 0x9d, 0x8c, 0xaf, 0x9f, 0x99, 0xcb, 0xab, 0x15, 0xb6,
+	0xfd, 0xd8, 0xdd, 0xed, 0x6c, 0xe6, 0xd3, 0xbd, 0x2a, 0x44, 0x8d, 0x6d, 0xb2, 0xeb, 0x74, 0xd4,
+	0x7b, 0x31, 0xaf, 0x5e, 0x3b, 0x76, 0xbd, 0x39, 0xd7, 0x8f, 0xa3, 0x38, 0x4c, 0x57, 0xb2, 0xbf,
+	0x69, 0xc1, 0xd5, 0xf9, 0xb7, 0xea, 0x4b, 0x9e, 0x13, 0xc5, 0x6e, 0x63, 0xc1, 0x0b, 0x1a, 0x3b,
+	0xf5, 0x38, 0x08, 0xc9, 0xfd, 0xc0, 0x6b, 0xef, 0x92, 0x3a, 0x1b, 0x08, 0xf4, 0x1c, 0x0c, 0xef,
+	0xb1, 0xff, 0x2b, 0xd5, 0x69, 0xeb, 0xaa, 0x75, 0xbd, 0xbc, 0x30, 0xf9, 0x5b, 0x07, 0x95, 0x8f,
+	0x1d, 0x1e, 0x54, 0x86, 0xef, 0x8b, 0x72, 0xac, 0x30, 0xd0, 0x35, 0x18, 0xdc, 0x8c, 0xd6, 0xf7,
+	0x5b, 0x64, 0xba, 0xc0, 0x70, 0xc7, 0x05, 0xee, 0xe0, 0x72, 0x9d, 0x96, 0x62, 0x01, 0x45, 0x73,
+	0x50, 0x6e, 0x39, 0x61, 0xec, 0xc6, 0x6e, 0xe0, 0x4f, 0x17, 0xaf, 0x5a, 0xd7, 0x07, 0x16, 0xa6,
+	0x04, 0x6a, 0xb9, 0x26, 0x01, 0x38, 0xc1, 0xa1, 0xdd, 0x08, 0x89, 0xd3, 0xbc, 0xeb, 0x7b, 0xfb,
+	0xd3, 0xa5, 0xab, 0xd6, 0xf5, 0xe1, 0xa4, 0x1b, 0x58, 0x94, 0x63, 0x85, 0x61, 0xff, 0x58, 0x01,
+	0x86, 0xe7, 0x37, 0x37, 0x5d, 0xdf, 0x8d, 0xf7, 0xd1, 0x7d, 0x18, 0xf5, 0x83, 0x26, 0x91, 0xff,
+	0xd9, 0x57, 0x8c, 0xdc, 0xb8, 0x3a, 0xdb, 0xb9, 0x32, 0x67, 0xd7, 0x34, 0xbc, 0x85, 0xc9, 0xc3,
+	0x83, 0xca, 0xa8, 0x5e, 0x82, 0x0d, 0x3a, 0x08, 0xc3, 0x48, 0x2b, 0x68, 0x2a, 0xb2, 0x05, 0x46,
+	0xb6, 0x92, 0x45, 0xb6, 0x96, 0xa0, 0x2d, 0x4c, 0x1c, 0x1e, 0x54, 0x46, 0xb4, 0x02, 0xac, 0x13,
+	0x41, 0x1b, 0x30, 0x41, 0xff, 0xfa, 0xb1, 0xab, 0xe8, 0x16, 0x19, 0xdd, 0xa7, 0xf2, 0xe8, 0x6a,
+	0xa8, 0x0b, 0x67, 0x0e, 0x0f, 0x2a, 0x13, 0xa9, 0x42, 0x9c, 0x26, 0x68, 0xbf, 0x0f, 0xe3, 0xf3,
+	0x71, 0xec, 0x34, 0xb6, 0x49, 0x93, 0xcf, 0x20, 0x7a, 0x09, 0x4a, 0xbe, 0xb3, 0x4b, 0xc4, 0xfc,
+	0x5e, 0x15, 0x03, 0x5b, 0x5a, 0x73, 0x76, 0xc9, 0xd1, 0x41, 0x65, 0xf2, 0x9e, 0xef, 0xbe, 0xd7,
+	0x16, 0xab, 0x82, 0x96, 0x61, 0x86, 0x8d, 0x6e, 0x00, 0x34, 0xc9, 0x9e, 0xdb, 0x20, 0x35, 0x27,
+	0xde, 0x16, 0xf3, 0x8d, 0x44, 0x5d, 0xa8, 0x2a, 0x08, 0xd6, 0xb0, 0xec, 0x87, 0x50, 0x9e, 0xdf,
+	0x0b, 0xdc, 0x66, 0x2d, 0x68, 0x46, 0x68, 0x07, 0x26, 0x5a, 0x21, 0xd9, 0x24, 0xa1, 0x2a, 0x9a,
+	0xb6, 0xae, 0x16, 0xaf, 0x8f, 0xdc, 0xb8, 0x9e, 0xf9, 0xb1, 0x26, 0xea, 0x92, 0x1f, 0x87, 0xfb,
+	0x0b, 0x17, 0x44, 0x7b, 0x13, 0x29, 0x28, 0x4e, 0x53, 0xb6, 0xff, 0x75, 0x01, 0xce, 0xcd, 0xbf,
+	0xdf, 0x0e, 0x49, 0xd5, 0x8d, 0x76, 0xd2, 0x2b, 0xbc, 0xe9, 0x46, 0x3b, 0x6b, 0xc9, 0x08, 0xa8,
+	0xa5, 0x55, 0x15, 0xe5, 0x58, 0x61, 0xa0, 0xe7, 0x61, 0x88, 0xfe, 0xbe, 0x87, 0x57, 0xc4, 0x27,
+	0x9f, 0x11, 0xc8, 0x23, 0x55, 0x27, 0x76, 0xaa, 0x1c, 0x84, 0x25, 0x0e, 0x5a, 0x85, 0x91, 0x06,
+	0xdb, 0x90, 0x5b, 0xab, 0x41, 0x93, 0xb0, 0xc9, 0x2c, 0x2f, 0x3c, 0x4b, 0xd1, 0x17, 0x93, 0xe2,
+	0xa3, 0x83, 0xca, 0x34, 0xef, 0x9b, 0x20, 0xa1, 0xc1, 0xb0, 0x5e, 0x1f, 0xd9, 0x6a, 0x7f, 0x95,
+	0x18, 0x25, 0xc8, 0xd8, 0x5b, 0xd7, 0xb5, 0xad, 0x32, 0xc0, 0xb6, 0xca, 0x68, 0xf6, 0x36, 0x41,
+	0x2f, 0x40, 0x69, 0xc7, 0xf5, 0x9b, 0xd3, 0x83, 0x8c, 0xd6, 0x65, 0x3a, 0xe7, 0xb7, 0x5d, 0xbf,
+	0x79, 0x74, 0x50, 0x99, 0x32, 0xba, 0x43, 0x0b, 0x31, 0x43, 0xb5, 0xff, 0xd8, 0x82, 0x0a, 0x83,
+	0x2d, 0xbb, 0x1e, 0xa9, 0x91, 0x30, 0x72, 0xa3, 0x98, 0xf8, 0xb1, 0x31, 0xa0, 0x37, 0x00, 0x22,
+	0xd2, 0x08, 0x49, 0xac, 0x0d, 0xa9, 0x5a, 0x18, 0x75, 0x05, 0xc1, 0x1a, 0x16, 0x3d, 0x10, 0xa2,
+	0x6d, 0x27, 0x64, 0xeb, 0x4b, 0x0c, 0xac, 0x3a, 0x10, 0xea, 0x12, 0x80, 0x13, 0x1c, 0xe3, 0x40,
+	0x28, 0xf6, 0x3a, 0x10, 0xd0, 0xe7, 0x60, 0x22, 0x69, 0x2c, 0x6a, 0x39, 0x0d, 0x39, 0x80, 0x6c,
+	0xcb, 0xd4, 0x4d, 0x10, 0x4e, 0xe3, 0xda, 0x7f, 0xdf, 0x12, 0x8b, 0x87, 0x7e, 0xf5, 0x47, 0xfc,
+	0x5b, 0xed, 0x5f, 0xb5, 0x60, 0x68, 0xc1, 0xf5, 0x9b, 0xae, 0xbf, 0x85, 0xbe, 0x0c, 0xc3, 0xf4,
+	0x6e, 0x6a, 0x3a, 0xb1, 0x23, 0xce, 0xbd, 0x4f, 0x69, 0x7b, 0x4b, 0x5d, 0x15, 0xb3, 0xad, 0x9d,
+	0x2d, 0x5a, 0x10, 0xcd, 0x52, 0x6c, 0xba, 0xdb, 0xee, 0x6e, 0xbc, 0x4b, 0x1a, 0xf1, 0x2a, 0x89,
+	0x9d, 0xe4, 0x73, 0x92, 0x32, 0xac, 0xa8, 0xa2, 0xdb, 0x30, 0x18, 0x3b, 0xe1, 0x16, 0x89, 0xc5,
+	0x01, 0x98, 0x79, 0x50, 0xf1, 0x9a, 0x98, 0xee, 0x48, 0xe2, 0x37, 0x48, 0x72, 0x2d, 0xac, 0xb3,
+	0xaa, 0x58, 0x90, 0xb0, 0x7f, 0x70, 0x10, 0x2e, 0x2e, 0xd6, 0x57, 0x72, 0xd6, 0xd5, 0x35, 0x18,
+	0x6c, 0x86, 0xee, 0x1e, 0x09, 0xc5, 0x38, 0x2b, 0x2a, 0x55, 0x56, 0x8a, 0x05, 0x14, 0xbd, 0x0a,
+	0xa3, 0xfc, 0x42, 0xba, 0xe5, 0xf8, 0x4d, 0x4f, 0x0e, 0xf1, 0x59, 0x81, 0x3d, 0x7a, 0x5f, 0x83,
+	0x61, 0x03, 0xf3, 0x98, 0x8b, 0xea, 0x5a, 0x6a, 0x33, 0xe6, 0x5d, 0x76, 0x3f, 0x60, 0xc1, 0x24,
+	0x6f, 0x66, 0x3e, 0x8e, 0x43, 0x77, 0xa3, 0x1d, 0x93, 0x68, 0x7a, 0x80, 0x9d, 0x74, 0x8b, 0x59,
+	0xa3, 0x95, 0x3b, 0x02, 0xb3, 0xf7, 0x53, 0x54, 0xf8, 0x21, 0x38, 0x2d, 0xda, 0x9d, 0x4c, 0x83,
+	0x71, 0x47, 0xb3, 0xe8, 0x7b, 0x2d, 0x98, 0x69, 0x04, 0x7e, 0x1c, 0x06, 0x9e, 0x47, 0xc2, 0x5a,
+	0x7b, 0xc3, 0x73, 0xa3, 0x6d, 0xbe, 0x4e, 0x31, 0xd9, 0x64, 0x27, 0x41, 0xce, 0x1c, 0x2a, 0x24,
+	0x31, 0x87, 0x57, 0x0e, 0x0f, 0x2a, 0x33, 0x8b, 0xb9, 0xa4, 0x70, 0x97, 0x66, 0xd0, 0x0e, 0x20,
+	0x7a, 0x95, 0xd6, 0x63, 0x67, 0x8b, 0x24, 0x8d, 0x0f, 0xf5, 0xdf, 0xf8, 0xf9, 0xc3, 0x83, 0x0a,
+	0x5a, 0xeb, 0x20, 0x81, 0x33, 0xc8, 0xa2, 0xf7, 0xe0, 0x2c, 0x2d, 0xed, 0xf8, 0xd6, 0xe1, 0xfe,
+	0x9b, 0x9b, 0x3e, 0x3c, 0xa8, 0x9c, 0x5d, 0xcb, 0x20, 0x82, 0x33, 0x49, 0xcf, 0x2c, 0xc2, 0xb9,
+	0xcc, 0xa9, 0x42, 0x93, 0x50, 0xdc, 0x21, 0x9c, 0x05, 0x29, 0x63, 0xfa, 0x13, 0x9d, 0x85, 0x81,
+	0x3d, 0xc7, 0x6b, 0x8b, 0x55, 0x8a, 0xf9, 0x9f, 0xcf, 0x14, 0x5e, 0xb5, 0xec, 0x06, 0x8c, 0x2e,
+	0x3a, 0x2d, 0x67, 0xc3, 0xf5, 0xdc, 0xd8, 0x25, 0x11, 0x7a, 0x1a, 0x8a, 0x4e, 0xb3, 0xc9, 0xae,
+	0xc8, 0xf2, 0xc2, 0xb9, 0xc3, 0x83, 0x4a, 0x71, 0xbe, 0x49, 0xcf, 0x6a, 0x50, 0x58, 0xfb, 0x98,
+	0x62, 0xa0, 0x4f, 0x42, 0xa9, 0x19, 0x06, 0xad, 0xe9, 0x02, 0xc3, 0xa4, 0x43, 0x55, 0xaa, 0x86,
+	0x41, 0x2b, 0x85, 0xca, 0x70, 0x6c, 0x17, 0x2e, 0x2c, 0x3a, 0x51, 0xc3, 0x69, 0x76, 0xde, 0x8b,
+	0x74, 0xbb, 0xb9, 0xd1, 0x8e, 0xe2, 0xfb, 0x92, 0xed, 0xc6, 0x4a, 0xb1, 0x80, 0xf6, 0xcb, 0xf3,
+	0xd9, 0xbf, 0x51, 0x80, 0x4b, 0x8b, 0xa4, 0xb5, 0xbd, 0x5c, 0xcf, 0xd9, 0xdf, 0xd7, 0x61, 0x78,
+	0x37, 0xf0, 0xdd, 0x38, 0x08, 0x23, 0xf1, 0x95, 0xec, 0xe2, 0x5a, 0x15, 0x65, 0x58, 0x41, 0xd1,
+	0x55, 0x28, 0xb5, 0x12, 0xa6, 0x63, 0x54, 0x32, 0x2c, 0x8c, 0xdd, 0x60, 0x10, 0x8a, 0xd1, 0x8e,
+	0x48, 0x28, 0x2e, 0x5c, 0x85, 0x71, 0x2f, 0x22, 0x21, 0x66, 0x90, 0xe4, 0xe4, 0xa6, 0x67, 0xba,
+	0xd8, 0xc1, 0xa9, 0x93, 0x9b, 0x42, 0xb0, 0x86, 0x85, 0x6a, 0x50, 0x8e, 0xd4, 0xfa, 0x19, 0xe8,
+	0x7f, 0xfd, 0x8c, 0xb1, 0xa3, 0x5d, 0x2d, 0x9a, 0x84, 0x88, 0x71, 0xe2, 0x0c, 0xf6, 0x3c, 0xda,
+	0xbf, 0x5e, 0x00, 0xc4, 0x87, 0xf0, 0xcf, 0xd9, 0xc0, 0xdd, 0xeb, 0x1c, 0xb8, 0x4c, 0x26, 0xef,
+	0x4e, 0xd0, 0x70, 0xbc, 0xf4, 0x6d, 0x71, 0x52, 0xa3, 0xf7, 0xbf, 0x2d, 0xb8, 0xb4, 0xe8, 0xfa,
+	0x4d, 0x12, 0xe6, 0x2c, 0xc0, 0xc7, 0x23, 0xeb, 0x1c, 0xef, 0x52, 0x31, 0x96, 0x58, 0xe9, 0x04,
+	0x96, 0x98, 0xfd, 0x3f, 0x2c, 0x40, 0xfc, 0xb3, 0x3f, 0x72, 0x1f, 0x7b, 0xaf, 0xf3, 0x63, 0x4f,
+	0x60, 0x59, 0xd8, 0x77, 0x60, 0x7c, 0xd1, 0x73, 0x89, 0x1f, 0xaf, 0xd4, 0x16, 0x03, 0x7f, 0xd3,
+	0xdd, 0x42, 0x9f, 0x81, 0x71, 0x2a, 0x3e, 0x07, 0xed, 0xb8, 0x4e, 0x1a, 0x81, 0xcf, 0x24, 0x0d,
+	0x2a, 0x74, 0xa2, 0xc3, 0x83, 0xca, 0xf8, 0xba, 0x01, 0xc1, 0x29, 0x4c, 0xfb, 0x77, 0xe9, 0xf8,
+	0x05, 0xbb, 0xad, 0xc0, 0x27, 0x7e, 0xbc, 0x18, 0xf8, 0x4d, 0x2e, 0x91, 0x7e, 0x06, 0x4a, 0x31,
+	0x1d, 0x0f, 0x3e, 0x76, 0xd7, 0xe4, 0x46, 0xa1, 0xa3, 0x70, 0x74, 0x50, 0x39, 0xdf, 0x59, 0x83,
+	0x8d, 0x13, 0xab, 0x83, 0xbe, 0x0d, 0x06, 0xa3, 0xd8, 0x89, 0xdb, 0x91, 0x18, 0xcd, 0x27, 0xe5,
+	0x68, 0xd6, 0x59, 0xe9, 0xd1, 0x41, 0x65, 0x42, 0x55, 0xe3, 0x45, 0x58, 0x54, 0x40, 0xcf, 0xc0,
+	0xd0, 0x2e, 0x89, 0x22, 0x67, 0x4b, 0x0a, 0x13, 0x13, 0xa2, 0xee, 0xd0, 0x2a, 0x2f, 0xc6, 0x12,
+	0x8e, 0x9e, 0x82, 0x01, 0x12, 0x86, 0x41, 0x28, 0xf6, 0xe8, 0x98, 0x40, 0x1c, 0x58, 0xa2, 0x85,
+	0x98, 0xc3, 0xec, 0x7f, 0x67, 0xc1, 0x84, 0xea, 0x2b, 0x6f, 0xeb, 0x14, 0xb8, 0xc6, 0xb7, 0x01,
+	0x1a, 0xf2, 0x03, 0x23, 0x76, 0x51, 0x8d, 0xdc, 0xb8, 0x96, 0xc9, 0x0b, 0x75, 0x0c, 0x63, 0x42,
+	0x59, 0x15, 0x45, 0x58, 0xa3, 0x66, 0xff, 0xba, 0x05, 0x67, 0x52, 0x5f, 0x74, 0xc7, 0x8d, 0x62,
+	0xf4, 0x4e, 0xc7, 0x57, 0xcd, 0xf6, 0xf7, 0x55, 0xb4, 0x36, 0xfb, 0x26, 0xb5, 0x94, 0x65, 0x89,
+	0xf6, 0x45, 0xb7, 0x60, 0xc0, 0x8d, 0xc9, 0xae, 0xfc, 0x98, 0xa7, 0xba, 0x7e, 0x0c, 0xef, 0x55,
+	0x32, 0x23, 0x2b, 0xb4, 0x26, 0xe6, 0x04, 0xec, 0x1f, 0x29, 0x42, 0x99, 0x2f, 0xdb, 0x55, 0xa7,
+	0x75, 0x0a, 0x73, 0xb1, 0x02, 0x25, 0x46, 0x9d, 0x77, 0xfc, 0xe9, 0xec, 0x8e, 0x8b, 0xee, 0xcc,
+	0x52, 0x91, 0x90, 0x73, 0x9d, 0xea, 0x6a, 0xa0, 0x45, 0x98, 0x91, 0x40, 0x0e, 0xc0, 0x86, 0xeb,
+	0x3b, 0xe1, 0x3e, 0x2d, 0x9b, 0x2e, 0x32, 0x82, 0xcf, 0x77, 0x27, 0xb8, 0xa0, 0xf0, 0x39, 0x59,
+	0xd5, 0xd7, 0x04, 0x80, 0x35, 0xa2, 0x33, 0xaf, 0x40, 0x59, 0x21, 0x1f, 0x87, 0x9d, 0x9a, 0xf9,
+	0x1c, 0x4c, 0xa4, 0xda, 0xea, 0x55, 0x7d, 0x54, 0xe7, 0xc6, 0xbe, 0xc6, 0x4e, 0x01, 0xd1, 0xeb,
+	0x25, 0x7f, 0x4f, 0x9c, 0xa2, 0xef, 0xc3, 0x59, 0x2f, 0xe3, 0x70, 0x12, 0x53, 0xd5, 0xff, 0x61,
+	0x76, 0x49, 0x7c, 0xf6, 0xd9, 0x2c, 0x28, 0xce, 0x6c, 0x83, 0x5e, 0xfb, 0x41, 0x8b, 0xae, 0x79,
+	0xc7, 0x63, 0xfd, 0x15, 0x82, 0xfe, 0x5d, 0x51, 0x86, 0x15, 0x94, 0x1e, 0x61, 0x67, 0x55, 0xe7,
+	0x6f, 0x93, 0xfd, 0x3a, 0xf1, 0x48, 0x23, 0x0e, 0xc2, 0x0f, 0xb5, 0xfb, 0x97, 0xf9, 0xe8, 0xf3,
+	0x13, 0x70, 0x44, 0x10, 0x28, 0xde, 0x26, 0xfb, 0x7c, 0x2a, 0xf4, 0xaf, 0x2b, 0x76, 0xfd, 0xba,
+	0x5f, 0xb0, 0x60, 0x4c, 0x7d, 0xdd, 0x29, 0x6c, 0xf5, 0x05, 0x73, 0xab, 0x5f, 0xee, 0xba, 0xc0,
+	0x73, 0x36, 0xf9, 0xd7, 0x0b, 0x70, 0x51, 0xe1, 0x50, 0xc9, 0x82, 0xff, 0x11, 0xab, 0x6a, 0x0e,
+	0xca, 0xbe, 0x52, 0x54, 0x58, 0xa6, 0x86, 0x20, 0x51, 0x53, 0x24, 0x38, 0x94, 0x6b, 0xf3, 0x13,
+	0x6d, 0xc2, 0xa8, 0xae, 0xc1, 0x13, 0xda, 0xba, 0x05, 0x28, 0xb6, 0xdd, 0xa6, 0xb8, 0x33, 0x3e,
+	0x25, 0x47, 0xfb, 0xde, 0x4a, 0xf5, 0xe8, 0xa0, 0xf2, 0x64, 0x9e, 0xf6, 0x98, 0x5e, 0x56, 0xd1,
+	0xec, 0xbd, 0x95, 0x2a, 0xa6, 0x95, 0xd1, 0x3c, 0x4c, 0x48, 0x05, 0xf9, 0x7d, 0xca, 0x41, 0x05,
+	0xbe, 0xb8, 0x5a, 0x94, 0x1a, 0x0e, 0x9b, 0x60, 0x9c, 0xc6, 0x47, 0x55, 0x98, 0xdc, 0x69, 0x6f,
+	0x10, 0x8f, 0xc4, 0xfc, 0x83, 0x6f, 0x13, 0xae, 0xa4, 0x2a, 0x27, 0x52, 0xec, 0xed, 0x14, 0x1c,
+	0x77, 0xd4, 0xb0, 0xff, 0x8c, 0x1d, 0xf1, 0x62, 0xf4, 0x6a, 0x61, 0x40, 0x17, 0x16, 0xa5, 0xfe,
+	0x61, 0x2e, 0xe7, 0x7e, 0x56, 0xc5, 0x6d, 0xb2, 0xbf, 0x1e, 0x50, 0x66, 0x3b, 0x7b, 0x55, 0x18,
+	0x6b, 0xbe, 0xd4, 0x75, 0xcd, 0xff, 0x52, 0x01, 0xce, 0xa9, 0x11, 0x30, 0xf8, 0xba, 0x3f, 0xef,
+	0x63, 0xf0, 0x02, 0x8c, 0x34, 0xc9, 0xa6, 0xd3, 0xf6, 0x62, 0xa5, 0x31, 0x1d, 0xe0, 0x5a, 0xf3,
+	0x6a, 0x52, 0x8c, 0x75, 0x9c, 0x63, 0x0c, 0xdb, 0x4f, 0x8f, 0xb0, 0xbb, 0x35, 0x76, 0xe8, 0x1a,
+	0x57, 0xbb, 0xc6, 0xca, 0xdd, 0x35, 0x4f, 0xc1, 0x80, 0xbb, 0x4b, 0x79, 0xad, 0x82, 0xc9, 0x42,
+	0xad, 0xd0, 0x42, 0xcc, 0x61, 0xe8, 0x13, 0x30, 0xd4, 0x08, 0x76, 0x77, 0x1d, 0xbf, 0xc9, 0xae,
+	0xbc, 0xf2, 0xc2, 0x08, 0x65, 0xc7, 0x16, 0x79, 0x11, 0x96, 0x30, 0x74, 0x09, 0x4a, 0x4e, 0xb8,
+	0x15, 0x4d, 0x97, 0x18, 0xce, 0x30, 0x6d, 0x69, 0x3e, 0xdc, 0x8a, 0x30, 0x2b, 0xa5, 0x52, 0xd5,
+	0x83, 0x20, 0xdc, 0x71, 0xfd, 0xad, 0xaa, 0x1b, 0x8a, 0x2d, 0xa1, 0xee, 0xc2, 0xb7, 0x14, 0x04,
+	0x6b, 0x58, 0x68, 0x19, 0x06, 0x5a, 0x41, 0x18, 0x47, 0xd3, 0x83, 0x6c, 0xb8, 0x9f, 0xcc, 0x39,
+	0x88, 0xf8, 0xd7, 0xd6, 0x82, 0x30, 0x4e, 0x3e, 0x80, 0xfe, 0x8b, 0x30, 0xaf, 0x8e, 0xbe, 0x0d,
+	0x8a, 0xc4, 0xdf, 0x9b, 0x1e, 0x62, 0x54, 0x66, 0xb2, 0xa8, 0x2c, 0xf9, 0x7b, 0xf7, 0x9d, 0x30,
+	0x39, 0xa5, 0x97, 0xfc, 0x3d, 0x4c, 0xeb, 0xa0, 0x2f, 0x40, 0x59, 0x6e, 0xf1, 0x48, 0x68, 0x54,
+	0x32, 0x97, 0x98, 0x3c, 0x18, 0x30, 0x79, 0xaf, 0xed, 0x86, 0x64, 0x97, 0xf8, 0x71, 0x94, 0x9c,
+	0x69, 0x12, 0x1a, 0xe1, 0x84, 0x1a, 0xfa, 0x82, 0x54, 0xe3, 0xad, 0x06, 0x6d, 0x3f, 0x8e, 0xa6,
+	0xcb, 0xac, 0x7b, 0x99, 0x0f, 0x2c, 0xf7, 0x13, 0xbc, 0xb4, 0x9e, 0x8f, 0x57, 0xc6, 0x06, 0x29,
+	0x84, 0x61, 0xcc, 0x73, 0xf7, 0x88, 0x4f, 0xa2, 0xa8, 0x16, 0x06, 0x1b, 0x64, 0x1a, 0x58, 0xcf,
+	0x2f, 0x66, 0xbf, 0x3b, 0x04, 0x1b, 0x64, 0x61, 0xea, 0xf0, 0xa0, 0x32, 0x76, 0x47, 0xaf, 0x83,
+	0x4d, 0x12, 0xe8, 0x1e, 0x8c, 0x53, 0xb9, 0xc6, 0x4d, 0x88, 0x8e, 0xf4, 0x22, 0xca, 0xa4, 0x0f,
+	0x6c, 0x54, 0xc2, 0x29, 0x22, 0xe8, 0x0d, 0x28, 0x7b, 0xee, 0x26, 0x69, 0xec, 0x37, 0x3c, 0x32,
+	0x3d, 0xca, 0x28, 0x66, 0x6e, 0xab, 0x3b, 0x12, 0x89, 0xcb, 0x45, 0xea, 0x2f, 0x4e, 0xaa, 0xa3,
+	0xfb, 0x70, 0x3e, 0x26, 0xe1, 0xae, 0xeb, 0x3b, 0x74, 0x3b, 0x08, 0x79, 0x81, 0xbd, 0xde, 0x8c,
+	0xb1, 0xf5, 0x76, 0x45, 0x0c, 0xdd, 0xf9, 0xf5, 0x4c, 0x2c, 0x9c, 0x53, 0x1b, 0xdd, 0x85, 0x09,
+	0xb6, 0x13, 0x6a, 0x6d, 0xcf, 0xab, 0x05, 0x9e, 0xdb, 0xd8, 0x9f, 0x1e, 0x67, 0x04, 0x3f, 0x21,
+	0xef, 0x85, 0x15, 0x13, 0x7c, 0x74, 0x50, 0x81, 0xe4, 0x1f, 0x4e, 0xd7, 0x46, 0x1b, 0x4c, 0x5d,
+	0xdf, 0x0e, 0xdd, 0x78, 0x9f, 0xae, 0x5f, 0xf2, 0x30, 0x9e, 0x9e, 0xe8, 0x2a, 0x0a, 0xeb, 0xa8,
+	0x4a, 0xa7, 0xaf, 0x17, 0xe2, 0x34, 0x41, 0xba, 0xb5, 0xa3, 0xb8, 0xe9, 0xfa, 0xd3, 0x93, 0xec,
+	0xc4, 0x50, 0x3b, 0xa3, 0x4e, 0x0b, 0x31, 0x87, 0x31, 0x55, 0x3d, 0xfd, 0x71, 0x97, 0x9e, 0xa0,
+	0x53, 0x0c, 0x31, 0x51, 0xd5, 0x4b, 0x00, 0x4e, 0x70, 0x28, 0x53, 0x13, 0xc7, 0xfb, 0xd3, 0x88,
+	0xa1, 0xaa, 0xed, 0xb2, 0xbe, 0xfe, 0x05, 0x4c, 0xcb, 0xd1, 0x1d, 0x18, 0x22, 0xfe, 0xde, 0x72,
+	0x18, 0xec, 0x4e, 0x9f, 0xc9, 0xdf, 0xb3, 0x4b, 0x1c, 0x85, 0x1f, 0xe8, 0x89, 0x80, 0x27, 0x8a,
+	0xb1, 0x24, 0x81, 0x1e, 0xc2, 0x74, 0xc6, 0x8c, 0xf0, 0x09, 0x38, 0xcb, 0x26, 0xe0, 0xb3, 0xa2,
+	0xee, 0xf4, 0x7a, 0x0e, 0xde, 0x51, 0x17, 0x18, 0xce, 0xa5, 0x8e, 0xbe, 0x08, 0x63, 0x7c, 0x43,
+	0xf1, 0x77, 0xbe, 0x68, 0xfa, 0x1c, 0xfb, 0x9a, 0xab, 0xf9, 0x9b, 0x93, 0x23, 0x2e, 0x9c, 0x13,
+	0x1d, 0x1a, 0xd3, 0x4b, 0x23, 0x6c, 0x52, 0xb3, 0x37, 0x60, 0x5c, 0x9d, 0x5b, 0x6c, 0xe9, 0xa0,
+	0x0a, 0x0c, 0x30, 0x6e, 0x47, 0xe8, 0xb7, 0xca, 0x74, 0xa6, 0x18, 0x27, 0x84, 0x79, 0x39, 0x9b,
+	0x29, 0xf7, 0x7d, 0xb2, 0xb0, 0x1f, 0x13, 0x2e, 0x55, 0x17, 0xb5, 0x99, 0x92, 0x00, 0x9c, 0xe0,
+	0xd8, 0xff, 0x97, 0x73, 0x8d, 0xc9, 0xe1, 0xd8, 0xc7, 0x75, 0xf0, 0x1c, 0x0c, 0x6f, 0x07, 0x51,
+	0x4c, 0xb1, 0x59, 0x1b, 0x03, 0x09, 0x9f, 0x78, 0x4b, 0x94, 0x63, 0x85, 0x81, 0x5e, 0x83, 0xb1,
+	0x86, 0xde, 0x80, 0xb8, 0xcb, 0xd4, 0x10, 0x18, 0xad, 0x63, 0x13, 0x17, 0xbd, 0x0a, 0xc3, 0xec,
+	0x95, 0xbe, 0x11, 0x78, 0x82, 0xc9, 0x92, 0x17, 0xf2, 0x70, 0x4d, 0x94, 0x1f, 0x69, 0xbf, 0xb1,
+	0xc2, 0x46, 0xd7, 0x60, 0x90, 0x76, 0x61, 0xa5, 0x26, 0x6e, 0x11, 0xa5, 0xaa, 0xb9, 0xc5, 0x4a,
+	0xb1, 0x80, 0xda, 0x7f, 0xbd, 0xa0, 0x8d, 0x32, 0x95, 0x48, 0x09, 0xaa, 0xc1, 0xd0, 0x03, 0xc7,
+	0x8d, 0x5d, 0x7f, 0x4b, 0xb0, 0x0b, 0xcf, 0x74, 0xbd, 0x52, 0x58, 0xa5, 0xb7, 0x78, 0x05, 0x7e,
+	0xe9, 0x89, 0x3f, 0x58, 0x92, 0xa1, 0x14, 0xc3, 0xb6, 0xef, 0x53, 0x8a, 0x85, 0x7e, 0x29, 0x62,
+	0x5e, 0x81, 0x53, 0x14, 0x7f, 0xb0, 0x24, 0x83, 0xde, 0x01, 0x90, 0xcb, 0x92, 0x34, 0xc5, 0xeb,
+	0xf8, 0x73, 0xbd, 0x89, 0xae, 0xab, 0x3a, 0x0b, 0xe3, 0xf4, 0x4a, 0x4d, 0xfe, 0x63, 0x8d, 0x9e,
+	0x1d, 0x33, 0xb6, 0xaa, 0xb3, 0x33, 0xe8, 0x3b, 0xe9, 0x49, 0xe0, 0x84, 0x31, 0x69, 0xce, 0xc7,
+	0x62, 0x70, 0x3e, 0xd9, 0x9f, 0x4c, 0xb1, 0xee, 0xee, 0x12, 0xfd, 0xd4, 0x10, 0x44, 0x70, 0x42,
+	0xcf, 0xfe, 0x95, 0x22, 0x4c, 0xe7, 0x75, 0x97, 0x2e, 0x3a, 0xf2, 0xd0, 0x8d, 0x17, 0x29, 0x37,
+	0x64, 0x99, 0x8b, 0x6e, 0x49, 0x94, 0x63, 0x85, 0x41, 0x67, 0x3f, 0x72, 0xb7, 0xa4, 0x48, 0x38,
+	0x90, 0xcc, 0x7e, 0x9d, 0x95, 0x62, 0x01, 0xa5, 0x78, 0x21, 0x71, 0x22, 0x61, 0x7e, 0xa1, 0xad,
+	0x12, 0xcc, 0x4a, 0xb1, 0x80, 0xea, 0xfa, 0xa6, 0x52, 0x0f, 0x7d, 0x93, 0x31, 0x44, 0x03, 0x27,
+	0x3b, 0x44, 0xe8, 0x4b, 0x00, 0x9b, 0xae, 0xef, 0x46, 0xdb, 0x8c, 0xfa, 0xe0, 0xb1, 0xa9, 0x2b,
+	0x5e, 0x6a, 0x59, 0x51, 0xc1, 0x1a, 0x45, 0xf4, 0x32, 0x8c, 0xa8, 0x0d, 0xb8, 0x52, 0x65, 0x6f,
+	0x51, 0xda, 0xdb, 0x7e, 0x72, 0x1a, 0x55, 0xb1, 0x8e, 0x67, 0xbf, 0x9b, 0x5e, 0x2f, 0x62, 0x07,
+	0x68, 0xe3, 0x6b, 0xf5, 0x3b, 0xbe, 0x85, 0xee, 0xe3, 0x6b, 0xff, 0x66, 0x11, 0x26, 0x8c, 0xc6,
+	0xda, 0x51, 0x1f, 0x67, 0xd6, 0x4d, 0x7a, 0xcf, 0x39, 0x31, 0x11, 0xfb, 0xcf, 0xee, 0xbd, 0x55,
+	0xf4, 0xbb, 0x90, 0xee, 0x00, 0x5e, 0x1f, 0x7d, 0x09, 0xca, 0x9e, 0x13, 0x31, 0xdd, 0x15, 0x11,
+	0xfb, 0xae, 0x1f, 0x62, 0x89, 0x1c, 0xe1, 0x44, 0xb1, 0x76, 0xd5, 0x70, 0xda, 0x09, 0x49, 0x7a,
+	0x21, 0x53, 0xde, 0x47, 0xda, 0xf7, 0xa8, 0x4e, 0x50, 0x06, 0x69, 0x1f, 0x73, 0x18, 0x7a, 0x15,
+	0x46, 0x43, 0xc2, 0x56, 0xc5, 0x22, 0x65, 0xe5, 0xd8, 0x32, 0x1b, 0x48, 0x78, 0x3e, 0xac, 0xc1,
+	0xb0, 0x81, 0x99, 0xb0, 0xf2, 0x83, 0x5d, 0x58, 0xf9, 0x67, 0x60, 0x88, 0xfd, 0x50, 0x2b, 0x40,
+	0xcd, 0xc6, 0x0a, 0x2f, 0xc6, 0x12, 0x9e, 0x5e, 0x30, 0xc3, 0x7d, 0x2e, 0x98, 0x4f, 0xc2, 0x78,
+	0xd5, 0x21, 0xbb, 0x81, 0xbf, 0xe4, 0x37, 0x5b, 0x81, 0xeb, 0xc7, 0x68, 0x1a, 0x4a, 0xec, 0x76,
+	0xe0, 0x7b, 0xbb, 0x44, 0x29, 0xe0, 0x12, 0x65, 0xcc, 0xed, 0x2d, 0x38, 0x57, 0x0d, 0x1e, 0xf8,
+	0x0f, 0x9c, 0xb0, 0x39, 0x5f, 0x5b, 0xd1, 0xe4, 0xdc, 0x35, 0x29, 0x67, 0x71, 0x7b, 0x99, 0xcc,
+	0x33, 0x55, 0xab, 0xc9, 0xef, 0xda, 0x65, 0xd7, 0x23, 0x39, 0xda, 0x88, 0xbf, 0x59, 0x30, 0x5a,
+	0x4a, 0xf0, 0xd5, 0x83, 0x91, 0x95, 0xfb, 0x60, 0xf4, 0x26, 0x0c, 0x6f, 0xba, 0xc4, 0x6b, 0x62,
+	0xb2, 0x29, 0x96, 0xd8, 0xd3, 0xf9, 0x26, 0x00, 0xcb, 0x14, 0x53, 0x6a, 0x9f, 0xb8, 0x94, 0xb6,
+	0x2c, 0x2a, 0x63, 0x45, 0x06, 0xed, 0xc0, 0xa4, 0x14, 0x03, 0x24, 0x54, 0x2c, 0xb8, 0x67, 0xba,
+	0xc9, 0x16, 0x26, 0xf1, 0xb3, 0x87, 0x07, 0x95, 0x49, 0x9c, 0x22, 0x83, 0x3b, 0x08, 0x53, 0xb1,
+	0x6c, 0x97, 0x1e, 0xad, 0x25, 0x36, 0xfc, 0x4c, 0x2c, 0x63, 0x12, 0x26, 0x2b, 0xb5, 0x7f, 0xc2,
+	0x82, 0x0b, 0x1d, 0x23, 0x23, 0x24, 0xed, 0x13, 0x9e, 0x85, 0xb4, 0xe4, 0x5b, 0xe8, 0x2d, 0xf9,
+	0xda, 0xff, 0xc0, 0x82, 0xb3, 0x4b, 0xbb, 0xad, 0x78, 0xbf, 0xea, 0x9a, 0xaf, 0x3b, 0xaf, 0xc0,
+	0xe0, 0x2e, 0x69, 0xba, 0xed, 0x5d, 0x31, 0x73, 0x15, 0x79, 0xfc, 0xac, 0xb2, 0xd2, 0xa3, 0x83,
+	0xca, 0x58, 0x3d, 0x0e, 0x42, 0x67, 0x8b, 0xf0, 0x02, 0x2c, 0xd0, 0xd9, 0x21, 0xee, 0xbe, 0x4f,
+	0xee, 0xb8, 0xbb, 0xae, 0x34, 0xe9, 0xe8, 0xaa, 0x3b, 0x9b, 0x95, 0x03, 0x3a, 0xfb, 0x66, 0xdb,
+	0xf1, 0x63, 0x37, 0xde, 0x17, 0x0f, 0x33, 0x92, 0x08, 0x4e, 0xe8, 0xd9, 0xdf, 0xb4, 0x60, 0x42,
+	0xae, 0xfb, 0xf9, 0x66, 0x33, 0x24, 0x51, 0x84, 0x66, 0xa0, 0xe0, 0xb6, 0x44, 0x2f, 0x41, 0xf4,
+	0xb2, 0xb0, 0x52, 0xc3, 0x05, 0xb7, 0x85, 0x6a, 0x50, 0xe6, 0x96, 0x21, 0xc9, 0xe2, 0xea, 0xcb,
+	0xbe, 0x84, 0xf5, 0x60, 0x5d, 0xd6, 0xc4, 0x09, 0x11, 0xc9, 0xc1, 0xb1, 0x33, 0xb3, 0x68, 0xbe,
+	0x7a, 0xdd, 0x12, 0xe5, 0x58, 0x61, 0xa0, 0xeb, 0x30, 0xec, 0x07, 0x4d, 0x6e, 0xa8, 0xc3, 0x6f,
+	0x3f, 0xb6, 0x64, 0xd7, 0x44, 0x19, 0x56, 0x50, 0xfb, 0x87, 0x2d, 0x18, 0x95, 0x5f, 0xd6, 0x27,
+	0x33, 0x49, 0xb7, 0x56, 0xc2, 0x48, 0x26, 0x5b, 0x8b, 0x32, 0x83, 0x0c, 0x62, 0xf0, 0x80, 0xc5,
+	0xe3, 0xf0, 0x80, 0xf6, 0x8f, 0x17, 0x60, 0x5c, 0x76, 0xa7, 0xde, 0xde, 0x88, 0x48, 0x8c, 0xd6,
+	0xa1, 0xec, 0xf0, 0x21, 0x27, 0x72, 0xc5, 0x3e, 0x95, 0x2d, 0x7c, 0x18, 0xf3, 0x93, 0x5c, 0xcb,
+	0xf3, 0xb2, 0x36, 0x4e, 0x08, 0x21, 0x0f, 0xa6, 0xfc, 0x20, 0x66, 0x47, 0xb4, 0x82, 0x77, 0x7b,
+	0x02, 0x49, 0x53, 0xbf, 0x28, 0xa8, 0x4f, 0xad, 0xa5, 0xa9, 0xe0, 0x4e, 0xc2, 0x68, 0x49, 0x2a,
+	0x3c, 0x8a, 0xf9, 0xe2, 0x86, 0x3e, 0x0b, 0xd9, 0xfa, 0x0e, 0xfb, 0xd7, 0x2c, 0x28, 0x4b, 0xb4,
+	0xd3, 0x78, 0xed, 0x5a, 0x85, 0xa1, 0x88, 0x4d, 0x82, 0x1c, 0x1a, 0xbb, 0x5b, 0xc7, 0xf9, 0x7c,
+	0x25, 0x37, 0x0f, 0xff, 0x1f, 0x61, 0x49, 0x83, 0xe9, 0xbb, 0x55, 0xf7, 0x3f, 0x22, 0xfa, 0x6e,
+	0xd5, 0x9f, 0x9c, 0x1b, 0xe6, 0xbf, 0xb2, 0x3e, 0x6b, 0x62, 0x2d, 0x65, 0x90, 0x5a, 0x21, 0xd9,
+	0x74, 0x1f, 0xa6, 0x19, 0xa4, 0x1a, 0x2b, 0xc5, 0x02, 0x8a, 0xde, 0x81, 0xd1, 0x86, 0x54, 0x74,
+	0x26, 0xc7, 0xc0, 0xb5, 0xae, 0x4a, 0x77, 0xf5, 0x3e, 0xc3, 0x8d, 0x78, 0x17, 0xb5, 0xfa, 0xd8,
+	0xa0, 0x66, 0x3e, 0xb7, 0x17, 0x7b, 0x3d, 0xb7, 0x27, 0x74, 0xf3, 0x1f, 0x9f, 0x7f, 0xd2, 0x82,
+	0x41, 0xae, 0x2e, 0xeb, 0x4f, 0xbf, 0xa8, 0x3d, 0x57, 0x25, 0x63, 0x77, 0x9f, 0x16, 0x8a, 0xe7,
+	0x27, 0xb4, 0x0a, 0x65, 0xf6, 0x83, 0xa9, 0x0d, 0x8a, 0xf9, 0xd6, 0xcb, 0xbc, 0x55, 0xbd, 0x83,
+	0xf7, 0x65, 0x35, 0x9c, 0x50, 0xb0, 0x7f, 0xb4, 0x48, 0x8f, 0xaa, 0x04, 0xd5, 0xb8, 0xc1, 0xad,
+	0xc7, 0x77, 0x83, 0x17, 0x1e, 0xd7, 0x0d, 0xbe, 0x05, 0x13, 0x0d, 0xed, 0x71, 0x2b, 0x99, 0xc9,
+	0xeb, 0x5d, 0x17, 0x89, 0xf6, 0x0e, 0xc6, 0x55, 0x46, 0x8b, 0x26, 0x11, 0x9c, 0xa6, 0x8a, 0xbe,
+	0x13, 0x46, 0xf9, 0x3c, 0x8b, 0x56, 0xb8, 0xc5, 0xc2, 0x27, 0xf2, 0xd7, 0x8b, 0xde, 0x04, 0x5b,
+	0x89, 0x75, 0xad, 0x3a, 0x36, 0x88, 0xd9, 0xbf, 0x32, 0x0c, 0x03, 0x4b, 0x7b, 0xc4, 0x8f, 0x4f,
+	0xe1, 0x40, 0x6a, 0xc0, 0xb8, 0xeb, 0xef, 0x05, 0xde, 0x1e, 0x69, 0x72, 0xf8, 0x71, 0x2e, 0xd7,
+	0xf3, 0x82, 0xf4, 0xf8, 0x8a, 0x41, 0x02, 0xa7, 0x48, 0x3e, 0x0e, 0x09, 0xf3, 0x26, 0x0c, 0xf2,
+	0xb9, 0x17, 0xe2, 0x65, 0xa6, 0x32, 0x98, 0x0d, 0xa2, 0xd8, 0x05, 0x89, 0xf4, 0xcb, 0xb5, 0xcf,
+	0xa2, 0x3a, 0x7a, 0x17, 0xc6, 0x37, 0xdd, 0x30, 0x8a, 0xa9, 0x68, 0x18, 0xc5, 0xce, 0x6e, 0xeb,
+	0x11, 0x24, 0x4a, 0x35, 0x0e, 0xcb, 0x06, 0x25, 0x9c, 0xa2, 0x8c, 0xb6, 0x60, 0x8c, 0x0a, 0x39,
+	0x49, 0x53, 0x43, 0xc7, 0x6e, 0x4a, 0xa9, 0x8c, 0xee, 0xe8, 0x84, 0xb0, 0x49, 0x97, 0x1e, 0x26,
+	0x0d, 0x26, 0x14, 0x0d, 0x33, 0x8e, 0x42, 0x1d, 0x26, 0x5c, 0x1a, 0xe2, 0x30, 0x7a, 0x26, 0x31,
+	0xb3, 0x95, 0xb2, 0x79, 0x26, 0x69, 0xc6, 0x29, 0x5f, 0x86, 0x32, 0xa1, 0x43, 0x48, 0x09, 0x0b,
+	0xc5, 0xf8, 0x5c, 0x7f, 0x7d, 0x5d, 0x75, 0x1b, 0x61, 0x60, 0xca, 0xf2, 0x4b, 0x92, 0x12, 0x4e,
+	0x88, 0xa2, 0x45, 0x18, 0x8c, 0x48, 0xe8, 0x92, 0x48, 0xa8, 0xc8, 0xbb, 0x4c, 0x23, 0x43, 0xe3,
+	0x66, 0xee, 0xfc, 0x37, 0x16, 0x55, 0xe9, 0xf2, 0x72, 0x98, 0x34, 0xc4, 0xb4, 0xe2, 0xda, 0xf2,
+	0x9a, 0x67, 0xa5, 0x58, 0x40, 0xd1, 0x1b, 0x30, 0x14, 0x12, 0x8f, 0x29, 0x8b, 0xc6, 0xfa, 0x5f,
+	0xe4, 0x5c, 0xf7, 0xc4, 0xeb, 0x61, 0x49, 0x00, 0xdd, 0x06, 0x14, 0x12, 0xca, 0x43, 0xb8, 0xfe,
+	0x96, 0x32, 0xe6, 0x10, 0xba, 0xee, 0x27, 0x44, 0xfb, 0x67, 0x70, 0x82, 0x21, 0x0d, 0x60, 0x71,
+	0x46, 0x35, 0x74, 0x13, 0xa6, 0x54, 0xe9, 0x8a, 0x1f, 0xc5, 0x8e, 0xdf, 0x20, 0x4c, 0xcd, 0x5d,
+	0x4e, 0xb8, 0x22, 0x9c, 0x46, 0xc0, 0x9d, 0x75, 0xec, 0x9f, 0xa3, 0xec, 0x0c, 0x1d, 0xad, 0x53,
+	0xe0, 0x05, 0x5e, 0x37, 0x79, 0x81, 0x8b, 0xb9, 0x33, 0x97, 0xc3, 0x07, 0x1c, 0x5a, 0x30, 0xa2,
+	0xcd, 0x6c, 0xb2, 0x66, 0xad, 0x2e, 0x6b, 0xb6, 0x0d, 0x93, 0x74, 0xa5, 0xdf, 0xdd, 0x60, 0x1e,
+	0x5f, 0x4d, 0xb6, 0x30, 0x0b, 0x8f, 0xb6, 0x30, 0xd5, 0x2b, 0xf3, 0x9d, 0x14, 0x41, 0xdc, 0xd1,
+	0x04, 0x7a, 0x45, 0x6a, 0x4e, 0x8a, 0x86, 0x91, 0x16, 0xd7, 0x8a, 0x1c, 0x1d, 0x54, 0x26, 0xb5,
+	0x0f, 0xd1, 0x35, 0x25, 0xf6, 0x97, 0xe5, 0x37, 0xaa, 0xd7, 0xfc, 0x86, 0x5a, 0x2c, 0xa9, 0xd7,
+	0x7c, 0xb5, 0x1c, 0x70, 0x82, 0x43, 0xf7, 0x28, 0x15, 0x41, 0xd2, 0xaf, 0xf9, 0x54, 0x40, 0xc1,
+	0x0c, 0x62, 0xbf, 0x08, 0xb0, 0xf4, 0x90, 0x34, 0xf8, 0x52, 0xd7, 0x1f, 0x20, 0xad, 0xfc, 0x07,
+	0x48, 0xfb, 0x3f, 0x58, 0x30, 0xbe, 0xbc, 0x68, 0x88, 0x89, 0xb3, 0x00, 0x5c, 0x36, 0x7a, 0xeb,
+	0xad, 0x35, 0xa9, 0x5b, 0xe7, 0xea, 0x51, 0x55, 0x8a, 0x35, 0x0c, 0x74, 0x11, 0x8a, 0x5e, 0xdb,
+	0x17, 0x22, 0xcb, 0xd0, 0xe1, 0x41, 0xa5, 0x78, 0xa7, 0xed, 0x63, 0x5a, 0xa6, 0x59, 0x08, 0x16,
+	0xfb, 0xb6, 0x10, 0xec, 0xe9, 0xc9, 0x85, 0x2a, 0x30, 0xf0, 0xe0, 0x81, 0xdb, 0xe4, 0xf6, 0xf2,
+	0x42, 0xef, 0xff, 0xd6, 0x5b, 0x2b, 0xd5, 0x08, 0xf3, 0x72, 0xfb, 0xab, 0x45, 0x98, 0x59, 0xf6,
+	0xc8, 0xc3, 0x0f, 0xe8, 0x33, 0xd0, 0xaf, 0x7d, 0xe3, 0xf1, 0xf8, 0xc5, 0xe3, 0xda, 0xb0, 0xf6,
+	0x1e, 0x8f, 0x4d, 0x18, 0xe2, 0x8f, 0xd9, 0xd2, 0x83, 0xe0, 0xb5, 0xac, 0xd6, 0xf3, 0x07, 0x64,
+	0x96, 0x3f, 0x8a, 0x0b, 0xcf, 0x01, 0x75, 0xd3, 0x8a, 0x52, 0x2c, 0x89, 0xcf, 0x7c, 0x06, 0x46,
+	0x75, 0xcc, 0x63, 0x19, 0xae, 0xff, 0xa5, 0x22, 0x4c, 0xd2, 0x1e, 0x3c, 0xd6, 0x89, 0xb8, 0xd7,
+	0x39, 0x11, 0x27, 0x6d, 0x51, 0xdc, 0x7b, 0x36, 0xde, 0x49, 0xcf, 0xc6, 0x0b, 0x79, 0xb3, 0x71,
+	0xda, 0x73, 0xf0, 0xbd, 0x16, 0x9c, 0x59, 0xf6, 0x82, 0xc6, 0x4e, 0xca, 0xea, 0xf7, 0x65, 0x18,
+	0xa1, 0xe7, 0x78, 0x64, 0x38, 0x2c, 0x19, 0x2e, 0x6c, 0x02, 0x84, 0x75, 0x3c, 0xad, 0xda, 0xbd,
+	0x7b, 0x2b, 0xd5, 0x2c, 0xcf, 0x37, 0x01, 0xc2, 0x3a, 0x9e, 0xfd, 0x0d, 0x0b, 0x2e, 0xdf, 0x5c,
+	0x5c, 0x4a, 0x96, 0x62, 0x96, 0x93, 0x41, 0xab, 0xa9, 0x75, 0x25, 0x91, 0x02, 0xab, 0xac, 0x17,
+	0x02, 0xfa, 0x51, 0x71, 0x2c, 0xfd, 0x59, 0x0b, 0xce, 0xdc, 0x74, 0x63, 0x7a, 0x2d, 0xa7, 0xdd,
+	0xc0, 0xe8, 0xbd, 0x1c, 0xb9, 0x71, 0x10, 0xee, 0xa7, 0xdd, 0xc0, 0xb0, 0x82, 0x60, 0x0d, 0x8b,
+	0xb7, 0xbc, 0xe7, 0x32, 0x33, 0xaa, 0x82, 0xa9, 0x8a, 0xc2, 0xa2, 0x1c, 0x2b, 0x0c, 0xfa, 0x61,
+	0x4d, 0x37, 0x64, 0xa2, 0xc4, 0xbe, 0x38, 0x61, 0xd5, 0x87, 0x55, 0x25, 0x00, 0x27, 0x38, 0xf6,
+	0x4f, 0x58, 0x70, 0xee, 0xa6, 0xd7, 0x8e, 0x62, 0x12, 0x6e, 0x46, 0x46, 0x67, 0x5f, 0x84, 0x32,
+	0x91, 0xe2, 0xba, 0xe8, 0xab, 0x62, 0x30, 0x95, 0x1c, 0xcf, 0x7d, 0xd0, 0x14, 0x5e, 0x1f, 0x9e,
+	0x03, 0xc7, 0xf3, 0x52, 0xfb, 0xc5, 0x02, 0x8c, 0xdd, 0x5a, 0x5f, 0xaf, 0xdd, 0x24, 0xb1, 0xb8,
+	0xc5, 0x7a, 0xab, 0x9a, 0xb1, 0xa6, 0x31, 0xeb, 0x26, 0x14, 0xb5, 0x63, 0xd7, 0x9b, 0xe5, 0x4e,
+	0xcf, 0xb3, 0x2b, 0x7e, 0x7c, 0x37, 0xac, 0xc7, 0xa1, 0xeb, 0x6f, 0x65, 0xea, 0xd8, 0xe4, 0x5d,
+	0x5b, 0xcc, 0xbb, 0x6b, 0xd1, 0x8b, 0x30, 0xc8, 0xbc, 0xae, 0xa5, 0x78, 0xf2, 0x84, 0x92, 0x29,
+	0x58, 0xe9, 0xd1, 0x41, 0xa5, 0x7c, 0x0f, 0xaf, 0xf0, 0x3f, 0x58, 0xa0, 0xa2, 0x7b, 0x30, 0xb2,
+	0x1d, 0xc7, 0xad, 0x5b, 0xc4, 0x69, 0x92, 0x50, 0x9e, 0x0e, 0x57, 0xb2, 0x4e, 0x07, 0x3a, 0x08,
+	0x1c, 0x2d, 0xd9, 0x50, 0x49, 0x59, 0x84, 0x75, 0x3a, 0x76, 0x1d, 0x20, 0x81, 0x9d, 0x90, 0x7e,
+	0xc1, 0xfe, 0x03, 0x0b, 0x86, 0xb8, 0x03, 0x5c, 0x88, 0x3e, 0x0b, 0x25, 0xf2, 0x90, 0x34, 0x04,
+	0xe7, 0x98, 0xd9, 0xe1, 0x84, 0xf1, 0xe0, 0xda, 0x72, 0xfa, 0x1f, 0xb3, 0x5a, 0xe8, 0x16, 0x0c,
+	0xd1, 0xde, 0xde, 0x54, 0xde, 0x80, 0x4f, 0xe6, 0x7d, 0xb1, 0x9a, 0x76, 0xce, 0xab, 0x88, 0x22,
+	0x2c, 0xab, 0x33, 0xcd, 0x6f, 0xa3, 0x55, 0xa7, 0x07, 0x58, 0xdc, 0xed, 0x9e, 0x5d, 0x5f, 0xac,
+	0x71, 0x24, 0x41, 0x8d, 0x6b, 0x7e, 0x65, 0x21, 0x4e, 0x88, 0xd8, 0xeb, 0x50, 0xa6, 0x93, 0x3a,
+	0xef, 0xb9, 0x4e, 0x77, 0xa5, 0xf3, 0xb3, 0x50, 0x96, 0x0a, 0xe0, 0x48, 0xf8, 0x50, 0x31, 0xaa,
+	0x52, 0x3f, 0x1c, 0xe1, 0x04, 0x6e, 0x6f, 0xc2, 0x59, 0xf6, 0xf2, 0xef, 0xc4, 0xdb, 0xc6, 0x1e,
+	0xeb, 0xbd, 0x98, 0x9f, 0x13, 0x82, 0x18, 0x9f, 0x99, 0x69, 0xcd, 0x77, 0x60, 0x54, 0x52, 0x4c,
+	0x84, 0x32, 0xfb, 0x8f, 0x4a, 0xf0, 0xc4, 0x4a, 0x3d, 0xdf, 0x37, 0xf2, 0x55, 0x18, 0xe5, 0x6c,
+	0x1a, 0x5d, 0xda, 0x8e, 0x27, 0xda, 0x55, 0xef, 0x62, 0xeb, 0x1a, 0x0c, 0x1b, 0x98, 0xe8, 0x32,
+	0x14, 0xdd, 0xf7, 0xfc, 0xb4, 0x19, 0xee, 0xca, 0x9b, 0x6b, 0x98, 0x96, 0x53, 0x30, 0xe5, 0xf8,
+	0xf8, 0x51, 0xaa, 0xc0, 0x8a, 0xeb, 0x7b, 0x1d, 0xc6, 0xdd, 0xa8, 0x11, 0xb9, 0x2b, 0x3e, 0x3d,
+	0x67, 0x12, 0xbf, 0xda, 0x44, 0x49, 0x40, 0x3b, 0xad, 0xa0, 0x38, 0x85, 0xad, 0x9d, 0xeb, 0x03,
+	0x7d, 0x73, 0x8d, 0x3d, 0x3d, 0x7d, 0x28, 0x43, 0xdc, 0x62, 0x5f, 0x17, 0x31, 0xa3, 0x36, 0xc1,
+	0x10, 0xf3, 0x0f, 0x8e, 0xb0, 0x84, 0x51, 0x09, 0xac, 0xb1, 0xed, 0xb4, 0xe6, 0xdb, 0xf1, 0x76,
+	0xd5, 0x8d, 0x1a, 0xc1, 0x1e, 0x09, 0xf7, 0x99, 0xf0, 0x3c, 0x9c, 0x48, 0x60, 0x0a, 0xb0, 0x78,
+	0x6b, 0xbe, 0x46, 0x31, 0x71, 0x67, 0x1d, 0x93, 0x2b, 0x84, 0x93, 0xe0, 0x0a, 0xe7, 0x61, 0x42,
+	0x36, 0x53, 0x27, 0x11, 0xbb, 0x23, 0x46, 0x58, 0xc7, 0x94, 0xa9, 0xad, 0x28, 0x56, 0xdd, 0x4a,
+	0xe3, 0xa3, 0x57, 0x60, 0xcc, 0xf5, 0xdd, 0xd8, 0x75, 0xe2, 0x20, 0x64, 0x37, 0x2c, 0x97, 0x93,
+	0x99, 0x25, 0xdb, 0x8a, 0x0e, 0xc0, 0x26, 0x9e, 0xfd, 0x87, 0x25, 0x98, 0x62, 0xd3, 0xf6, 0xad,
+	0x15, 0xf6, 0x91, 0x59, 0x61, 0xf7, 0x3a, 0x57, 0xd8, 0x49, 0xb0, 0xbb, 0x1f, 0xe6, 0x32, 0x7b,
+	0x17, 0xca, 0xca, 0x16, 0x58, 0x3a, 0x03, 0x58, 0x39, 0xce, 0x00, 0xbd, 0xb9, 0x0f, 0xf9, 0x8c,
+	0x5b, 0xcc, 0x7c, 0xc6, 0xfd, 0xdb, 0x16, 0x24, 0x26, 0x91, 0xe8, 0x16, 0x94, 0x5b, 0x01, 0x33,
+	0x3b, 0x08, 0xa5, 0x2d, 0xcf, 0x13, 0x99, 0x17, 0x15, 0xbf, 0x14, 0xf9, 0xf8, 0xd5, 0x64, 0x0d,
+	0x9c, 0x54, 0x46, 0x0b, 0x30, 0xd4, 0x0a, 0x49, 0x3d, 0x66, 0xde, 0xb6, 0x3d, 0xe9, 0xf0, 0x35,
+	0xc2, 0xf1, 0xb1, 0xac, 0x68, 0xff, 0x92, 0x05, 0xc0, 0x5f, 0x4a, 0x1d, 0x7f, 0x8b, 0x9c, 0x82,
+	0xf6, 0xb7, 0x0a, 0xa5, 0xa8, 0x45, 0x1a, 0xdd, 0x0c, 0x42, 0x92, 0xfe, 0xd4, 0x5b, 0xa4, 0x91,
+	0x0c, 0x38, 0xfd, 0x87, 0x59, 0x6d, 0xfb, 0xfb, 0x00, 0xc6, 0x13, 0xb4, 0x95, 0x98, 0xec, 0xa2,
+	0xe7, 0x0d, 0x97, 0xb8, 0x8b, 0x29, 0x97, 0xb8, 0x32, 0xc3, 0xd6, 0x14, 0x8d, 0xef, 0x42, 0x71,
+	0xd7, 0x79, 0x28, 0x34, 0x49, 0xcf, 0x76, 0xef, 0x06, 0xa5, 0x3f, 0xbb, 0xea, 0x3c, 0xe4, 0x32,
+	0xd3, 0xb3, 0x72, 0x81, 0xac, 0x3a, 0x0f, 0x8f, 0xb8, 0xd9, 0x07, 0x3b, 0xa4, 0xee, 0xb8, 0x51,
+	0xfc, 0x95, 0xff, 0x9c, 0xfc, 0x67, 0xcb, 0x8e, 0x36, 0xc2, 0xda, 0x72, 0x7d, 0xf1, 0x6e, 0xd8,
+	0x57, 0x5b, 0xae, 0x9f, 0x6e, 0xcb, 0xf5, 0xfb, 0x68, 0xcb, 0xf5, 0xd1, 0xfb, 0x30, 0x24, 0xde,
+	0xe8, 0x99, 0xad, 0xb7, 0xa9, 0xa5, 0xca, 0x6b, 0x4f, 0x3c, 0xf1, 0xf3, 0x36, 0xe7, 0xa4, 0x4c,
+	0x28, 0x4a, 0x7b, 0xb6, 0x2b, 0x1b, 0x44, 0x7f, 0xc3, 0x82, 0x71, 0xf1, 0x1b, 0x93, 0xf7, 0xda,
+	0x24, 0x8a, 0x05, 0xef, 0xf9, 0xe9, 0xfe, 0xfb, 0x20, 0x2a, 0xf2, 0xae, 0x7c, 0x5a, 0x1e, 0xb3,
+	0x26, 0xb0, 0x67, 0x8f, 0x52, 0xbd, 0x40, 0xff, 0xc8, 0x82, 0xb3, 0xbb, 0xce, 0x43, 0xde, 0x22,
+	0x2f, 0xc3, 0x4e, 0xec, 0x06, 0xc2, 0x76, 0xfd, 0xb3, 0xfd, 0x4d, 0x7f, 0x47, 0x75, 0xde, 0x49,
+	0x69, 0xe6, 0x7a, 0x36, 0x0b, 0xa5, 0x67, 0x57, 0x33, 0xfb, 0x35, 0xb3, 0x09, 0xc3, 0x72, 0xbd,
+	0x65, 0x48, 0xde, 0x55, 0x9d, 0xb1, 0x3e, 0xb6, 0x89, 0x84, 0xee, 0x97, 0x46, 0xdb, 0x11, 0x6b,
+	0xed, 0xb1, 0xb6, 0xf3, 0x2e, 0x8c, 0xea, 0x6b, 0xec, 0xb1, 0xb6, 0xf5, 0x1e, 0x9c, 0xc9, 0x58,
+	0x4b, 0x8f, 0xb5, 0xc9, 0x07, 0x70, 0x31, 0x77, 0x7d, 0x3c, 0xce, 0x86, 0xed, 0x5f, 0xb4, 0xf4,
+	0x73, 0xf0, 0x14, 0x54, 0xf0, 0x8b, 0xa6, 0x0a, 0xfe, 0x4a, 0xf7, 0x9d, 0x93, 0xa3, 0x87, 0x7f,
+	0x47, 0xef, 0x34, 0x3d, 0xd5, 0xd1, 0x1b, 0x30, 0xe8, 0xd1, 0x12, 0x69, 0x1c, 0x62, 0xf7, 0xde,
+	0x91, 0x09, 0x2f, 0xc5, 0xca, 0x23, 0x2c, 0x28, 0xd8, 0xbf, 0x6a, 0x41, 0xe9, 0x14, 0x46, 0x02,
+	0x9b, 0x23, 0xf1, 0x7c, 0x2e, 0x69, 0x11, 0x3d, 0x6d, 0x16, 0x3b, 0x0f, 0x96, 0x64, 0x84, 0xb8,
+	0x9c, 0x81, 0xf9, 0x2e, 0x38, 0x73, 0x27, 0x70, 0x9a, 0x0b, 0x8e, 0xe7, 0xf8, 0x0d, 0x12, 0xae,
+	0xf8, 0x5b, 0x3d, 0xad, 0x94, 0x74, 0x9b, 0xa2, 0x42, 0x2f, 0x9b, 0x22, 0x7b, 0x1b, 0x90, 0xde,
+	0x80, 0xb0, 0xe3, 0xc4, 0x30, 0xe4, 0xf2, 0xa6, 0xc4, 0xf0, 0x3f, 0x9d, 0xcd, 0xdd, 0x75, 0xf4,
+	0x4c, 0xb3, 0x50, 0xe4, 0x05, 0x58, 0x12, 0xb2, 0x5f, 0x85, 0x4c, 0xdf, 0xad, 0xde, 0x6a, 0x03,
+	0xfb, 0x65, 0x98, 0x62, 0x35, 0x8f, 0x27, 0xd2, 0xda, 0x3f, 0x60, 0xc1, 0xc4, 0x5a, 0x2a, 0x36,
+	0xc5, 0x35, 0xf6, 0xd6, 0x97, 0xa1, 0xf7, 0xad, 0xb3, 0x52, 0x2c, 0xa0, 0x27, 0xae, 0x5f, 0xfa,
+	0x33, 0x0b, 0x12, 0x57, 0xc9, 0x53, 0x60, 0xaa, 0x16, 0x0d, 0xa6, 0x2a, 0x53, 0xef, 0xa1, 0xba,
+	0x93, 0xc7, 0x53, 0xa1, 0xdb, 0x2a, 0x2e, 0x40, 0x17, 0x95, 0x47, 0x42, 0x86, 0x7b, 0x91, 0x8f,
+	0x9b, 0xc1, 0x03, 0x64, 0xa4, 0x00, 0x66, 0x26, 0xa4, 0x70, 0x3f, 0x22, 0x66, 0x42, 0xaa, 0x3f,
+	0x39, 0xbb, 0xaf, 0xa6, 0x75, 0x99, 0x9d, 0x4a, 0xdf, 0xce, 0xcc, 0xbe, 0x1d, 0xcf, 0x7d, 0x9f,
+	0xa8, 0xe0, 0x26, 0x15, 0x61, 0xc6, 0x2d, 0x4a, 0x8f, 0x0e, 0x2a, 0x63, 0xea, 0x1f, 0x0f, 0xb6,
+	0x95, 0x54, 0xb1, 0x6f, 0xc1, 0x44, 0x6a, 0xc0, 0xd0, 0xcb, 0x30, 0xd0, 0xda, 0x76, 0x22, 0x92,
+	0x32, 0x8d, 0x1c, 0xa8, 0xd1, 0xc2, 0xa3, 0x83, 0xca, 0xb8, 0xaa, 0xc0, 0x4a, 0x30, 0xc7, 0xb6,
+	0xff, 0xa7, 0x05, 0xa5, 0xb5, 0xa0, 0x79, 0x1a, 0x8b, 0xe9, 0x75, 0x63, 0x31, 0x5d, 0xca, 0x0b,
+	0x55, 0x98, 0xbb, 0x8e, 0x96, 0x53, 0xeb, 0xe8, 0x4a, 0x2e, 0x85, 0xee, 0x4b, 0x68, 0x17, 0x46,
+	0x58, 0x00, 0x44, 0x61, 0xaa, 0xf9, 0xa2, 0xc1, 0xdf, 0x57, 0x52, 0xfc, 0xfd, 0x84, 0x86, 0xaa,
+	0x71, 0xf9, 0xcf, 0xc0, 0x90, 0x30, 0x17, 0x4c, 0x1b, 0xb8, 0x0b, 0x5c, 0x2c, 0xe1, 0xf6, 0x4f,
+	0x16, 0xc1, 0x08, 0xb8, 0x88, 0x7e, 0xcd, 0x82, 0xd9, 0x90, 0x7b, 0x0c, 0x36, 0xab, 0xed, 0xd0,
+	0xf5, 0xb7, 0xea, 0x8d, 0x6d, 0xd2, 0x6c, 0x7b, 0xae, 0xbf, 0xb5, 0xb2, 0xe5, 0x07, 0xaa, 0x78,
+	0xe9, 0x21, 0x69, 0xb4, 0x99, 0xce, 0xbf, 0x47, 0x74, 0x47, 0x65, 0x8e, 0x73, 0xe3, 0xf0, 0xa0,
+	0x32, 0x8b, 0x8f, 0x45, 0x1b, 0x1f, 0xb3, 0x2f, 0xe8, 0x1b, 0x16, 0xcc, 0xf1, 0x38, 0x84, 0xfd,
+	0xf7, 0xbf, 0x8b, 0x34, 0x54, 0x93, 0xa4, 0x12, 0x22, 0xeb, 0x24, 0xdc, 0x5d, 0x78, 0x45, 0x0c,
+	0xe8, 0x5c, 0xed, 0x78, 0x6d, 0xe1, 0xe3, 0x76, 0xce, 0xfe, 0x97, 0x45, 0x18, 0x13, 0xce, 0xea,
+	0x22, 0x0a, 0xca, 0xcb, 0xc6, 0x92, 0x78, 0x32, 0xb5, 0x24, 0xa6, 0x0c, 0xe4, 0x93, 0x09, 0x80,
+	0x12, 0xc1, 0x94, 0xe7, 0x44, 0xf1, 0x2d, 0xe2, 0x84, 0xf1, 0x06, 0x71, 0xb8, 0x99, 0x4a, 0xf1,
+	0xd8, 0x26, 0x35, 0x4a, 0xfd, 0x72, 0x27, 0x4d, 0x0c, 0x77, 0xd2, 0x47, 0x7b, 0x80, 0x98, 0xad,
+	0x4d, 0xe8, 0xf8, 0x11, 0xff, 0x16, 0x57, 0xbc, 0x07, 0x1c, 0xaf, 0xd5, 0x19, 0xd1, 0x2a, 0xba,
+	0xd3, 0x41, 0x0d, 0x67, 0xb4, 0xa0, 0xd9, 0x50, 0x0d, 0xf4, 0x6b, 0x43, 0x35, 0xd8, 0xc3, 0x8b,
+	0xc4, 0x87, 0xc9, 0x8e, 0x78, 0x03, 0x6f, 0x43, 0x59, 0xd9, 0xba, 0x89, 0x43, 0xa7, 0x7b, 0xd8,
+	0x8e, 0x34, 0x05, 0xae, 0x22, 0x49, 0xec, 0x2c, 0x13, 0x72, 0xf6, 0x3f, 0x2e, 0x18, 0x0d, 0xf2,
+	0x49, 0x5c, 0x83, 0x61, 0x27, 0x8a, 0xdc, 0x2d, 0x9f, 0x34, 0xc5, 0x8e, 0xfd, 0x78, 0xde, 0x8e,
+	0x35, 0x9a, 0x61, 0xf6, 0x86, 0xf3, 0xa2, 0x26, 0x56, 0x34, 0xd0, 0x2d, 0x6e, 0x0c, 0xb4, 0x27,
+	0xf9, 0xf9, 0xfe, 0xa8, 0x81, 0x34, 0x17, 0xda, 0x23, 0x58, 0xd4, 0x47, 0x5f, 0xe4, 0xd6, 0x5a,
+	0xb7, 0xfd, 0xe0, 0x81, 0x7f, 0x33, 0x08, 0xa4, 0x87, 0x59, 0x7f, 0x04, 0xa7, 0xa4, 0x8d, 0x96,
+	0xaa, 0x8e, 0x4d, 0x6a, 0xfd, 0xc5, 0xe4, 0xf9, 0x6e, 0x38, 0x43, 0x49, 0x9b, 0x7e, 0x22, 0x11,
+	0x22, 0x30, 0x21, 0x22, 0x21, 0xc8, 0x32, 0x31, 0x76, 0x99, 0xac, 0xba, 0x59, 0x3b, 0x51, 0xe8,
+	0xdd, 0x36, 0x49, 0xe0, 0x34, 0x4d, 0xfb, 0x67, 0x2c, 0x60, 0x16, 0xee, 0xa7, 0xc0, 0x32, 0x7c,
+	0xce, 0x64, 0x19, 0xa6, 0xf3, 0x06, 0x39, 0x87, 0x5b, 0x78, 0x89, 0xaf, 0xac, 0x5a, 0x18, 0x3c,
+	0xdc, 0x17, 0x2f, 0xe5, 0x7d, 0x70, 0xa9, 0xff, 0xc7, 0xe2, 0x87, 0x98, 0x72, 0x3a, 0x47, 0xdf,
+	0x03, 0xc3, 0x0d, 0xa7, 0xe5, 0x34, 0x78, 0x74, 0xe0, 0x5c, 0x8d, 0x8d, 0x51, 0x69, 0x76, 0x51,
+	0xd4, 0xe0, 0x1a, 0x08, 0x19, 0x51, 0x63, 0x58, 0x16, 0xf7, 0xd4, 0x3a, 0xa8, 0x26, 0x67, 0x76,
+	0x60, 0xcc, 0x20, 0xf6, 0x58, 0xc5, 0xd5, 0xef, 0xe1, 0x57, 0xac, 0x8a, 0x00, 0xb3, 0x0b, 0x53,
+	0xbe, 0xf6, 0x9f, 0x5e, 0x28, 0x52, 0x04, 0xf9, 0x78, 0xaf, 0x4b, 0x94, 0xdd, 0x3e, 0x9a, 0x05,
+	0x7f, 0x8a, 0x0c, 0xee, 0xa4, 0x6c, 0xff, 0x94, 0x05, 0x17, 0x74, 0x44, 0x2d, 0x1e, 0x40, 0x2f,
+	0x1d, 0x70, 0x15, 0x86, 0x83, 0x16, 0x09, 0x9d, 0x38, 0x08, 0xc5, 0xad, 0x71, 0x5d, 0x0e, 0xfa,
+	0x5d, 0x51, 0x7e, 0x24, 0xc2, 0x34, 0x4a, 0xea, 0xb2, 0x1c, 0xab, 0x9a, 0xc8, 0x86, 0x41, 0x36,
+	0x18, 0x91, 0x88, 0xd5, 0xc0, 0xce, 0x00, 0xf6, 0x1c, 0x1a, 0x61, 0x01, 0xb1, 0xff, 0xc8, 0xe2,
+	0x0b, 0x4b, 0xef, 0x3a, 0x7a, 0x0f, 0x26, 0x77, 0x9d, 0xb8, 0xb1, 0xbd, 0xf4, 0xb0, 0x15, 0x72,
+	0xd5, 0xb7, 0x1c, 0xa7, 0x67, 0x7b, 0x8d, 0x93, 0xf6, 0x91, 0x89, 0x01, 0xda, 0x6a, 0x8a, 0x18,
+	0xee, 0x20, 0x8f, 0x36, 0x60, 0x84, 0x95, 0x31, 0x4b, 0xe7, 0xa8, 0x1b, 0x6b, 0x90, 0xd7, 0x9a,
+	0x7a, 0x51, 0x5e, 0x4d, 0xe8, 0x60, 0x9d, 0xa8, 0xfd, 0x95, 0x22, 0xdf, 0xed, 0x8c, 0xdb, 0x7e,
+	0x06, 0x86, 0x5a, 0x41, 0x73, 0x71, 0xa5, 0x8a, 0xc5, 0x2c, 0xa8, 0x6b, 0xa4, 0xc6, 0x8b, 0xb1,
+	0x84, 0xa3, 0xd7, 0x00, 0xc8, 0xc3, 0x98, 0x84, 0xbe, 0xe3, 0x29, 0x83, 0x10, 0x65, 0x02, 0x59,
+	0x0d, 0xd6, 0x82, 0xf8, 0x5e, 0x44, 0xbe, 0x6b, 0x49, 0xa1, 0x60, 0x0d, 0x1d, 0xdd, 0x00, 0x68,
+	0x85, 0xc1, 0x9e, 0xdb, 0x64, 0xae, 0x73, 0x45, 0xd3, 0x5c, 0xa2, 0xa6, 0x20, 0x58, 0xc3, 0x42,
+	0xaf, 0xc1, 0x58, 0xdb, 0x8f, 0x38, 0x87, 0xe2, 0x6c, 0x88, 0xc8, 0x83, 0xc3, 0x89, 0xe5, 0xc2,
+	0x3d, 0x1d, 0x88, 0x4d, 0x5c, 0x34, 0x0f, 0x83, 0xb1, 0xc3, 0xec, 0x1d, 0x06, 0xf2, 0xed, 0x16,
+	0xd7, 0x29, 0x86, 0x1e, 0x9b, 0x96, 0x56, 0xc0, 0xa2, 0x22, 0x7a, 0x5b, 0xfa, 0x21, 0xf0, 0xb3,
+	0x5e, 0x18, 0x0c, 0xf7, 0x77, 0x2f, 0x68, 0x5e, 0x08, 0xc2, 0x10, 0xd9, 0xa0, 0x65, 0x7f, 0xa3,
+	0x0c, 0x90, 0xb0, 0xe3, 0xe8, 0xfd, 0x8e, 0xf3, 0xe8, 0xb9, 0xee, 0x0c, 0xfc, 0xc9, 0x1d, 0x46,
+	0xe8, 0xfb, 0x2d, 0x18, 0x71, 0x3c, 0x2f, 0x68, 0x38, 0x31, 0x1b, 0xe5, 0x42, 0xf7, 0xf3, 0x50,
+	0xb4, 0x3f, 0x9f, 0xd4, 0xe0, 0x5d, 0x78, 0x51, 0x2e, 0x3c, 0x0d, 0xd2, 0xb3, 0x17, 0x7a, 0xc3,
+	0xe8, 0x53, 0x52, 0x4a, 0xe3, 0xcb, 0x63, 0x26, 0x2d, 0xa5, 0x95, 0xd9, 0xd1, 0xaf, 0x09, 0x68,
+	0xe8, 0x9e, 0x11, 0x54, 0xae, 0x94, 0x1f, 0x5f, 0xc1, 0xe0, 0x4a, 0x7b, 0xc5, 0x93, 0x43, 0x35,
+	0xdd, 0x71, 0x6a, 0x20, 0x3f, 0x08, 0x89, 0x26, 0xfe, 0xf4, 0x70, 0x9a, 0x7a, 0x17, 0x26, 0x9a,
+	0xe6, 0xdd, 0x2e, 0x56, 0xd3, 0xd3, 0x79, 0x74, 0x53, 0xac, 0x40, 0x72, 0x9b, 0xa7, 0x00, 0x38,
+	0x4d, 0x18, 0xd5, 0xb8, 0x0b, 0xdb, 0x8a, 0xbf, 0x19, 0x08, 0xc3, 0x73, 0x3b, 0x77, 0x2e, 0xf7,
+	0xa3, 0x98, 0xec, 0x52, 0xcc, 0xe4, 0xd2, 0x5e, 0x13, 0x75, 0xb1, 0xa2, 0x82, 0xde, 0x80, 0x41,
+	0xe6, 0x03, 0x1b, 0x4d, 0x0f, 0xe7, 0x2b, 0x0a, 0xcd, 0xf0, 0x0d, 0xc9, 0xa6, 0x62, 0x7f, 0x23,
+	0x2c, 0x28, 0xa0, 0x5b, 0x32, 0xc6, 0x4b, 0xb4, 0xe2, 0xdf, 0x8b, 0x08, 0x8b, 0xf1, 0x52, 0x5e,
+	0xf8, 0x78, 0x12, 0xbe, 0x85, 0x97, 0x67, 0x46, 0xa1, 0x37, 0x6a, 0x52, 0xe6, 0x48, 0xfc, 0x97,
+	0xc1, 0xed, 0xa7, 0x21, 0xbf, 0x7b, 0x66, 0x00, 0xfc, 0x64, 0x38, 0xef, 0x9b, 0x24, 0x70, 0x9a,
+	0x26, 0x65, 0x34, 0xf9, 0xce, 0x15, 0xa6, 0xeb, 0xbd, 0xf6, 0x3f, 0x97, 0xaf, 0xd9, 0x25, 0xc3,
+	0x4b, 0xb0, 0xa8, 0x7f, 0xaa, 0xb7, 0xfe, 0x8c, 0x0f, 0x93, 0xe9, 0x2d, 0xfa, 0x58, 0xb9, 0x8c,
+	0x3f, 0x28, 0xc1, 0xb8, 0xb9, 0xa4, 0xd0, 0x1c, 0x94, 0x05, 0x11, 0x15, 0x70, 0x54, 0xed, 0x92,
+	0x55, 0x09, 0xc0, 0x09, 0x0e, 0x8b, 0x33, 0xcb, 0xaa, 0x6b, 0x26, 0x87, 0x49, 0x9c, 0x59, 0x05,
+	0xc1, 0x1a, 0x16, 0x95, 0x97, 0x36, 0x82, 0x20, 0x56, 0x97, 0x8a, 0x5a, 0x77, 0x0b, 0xac, 0x14,
+	0x0b, 0x28, 0xbd, 0x4c, 0x76, 0x48, 0xe8, 0x13, 0xcf, 0x8c, 0x63, 0xa6, 0x2e, 0x93, 0xdb, 0x3a,
+	0x10, 0x9b, 0xb8, 0xf4, 0x96, 0x0c, 0x22, 0xb6, 0x90, 0x85, 0x54, 0x96, 0x98, 0x70, 0xd6, 0xb9,
+	0x37, 0xb9, 0x84, 0xa3, 0x2f, 0xc0, 0x05, 0xe5, 0xfc, 0x8d, 0xb9, 0x12, 0x5a, 0xb6, 0x38, 0x68,
+	0x28, 0x51, 0x2e, 0x2c, 0x66, 0xa3, 0xe1, 0xbc, 0xfa, 0xe8, 0x75, 0x18, 0x17, 0x9c, 0xbb, 0xa4,
+	0x38, 0x64, 0xda, 0x45, 0xdc, 0x36, 0xa0, 0x38, 0x85, 0x2d, 0x23, 0xb1, 0x31, 0xe6, 0x59, 0x52,
+	0x18, 0xee, 0x8c, 0xc4, 0xa6, 0xc3, 0x71, 0x47, 0x0d, 0x34, 0x0f, 0x13, 0x9c, 0xb5, 0x72, 0xfd,
+	0x2d, 0x3e, 0x27, 0xc2, 0xb3, 0x44, 0x6d, 0xa9, 0xbb, 0x26, 0x18, 0xa7, 0xf1, 0xd1, 0xab, 0x30,
+	0xea, 0x84, 0x8d, 0x6d, 0x37, 0x26, 0x8d, 0xb8, 0x1d, 0x72, 0x97, 0x13, 0xcd, 0xb0, 0x64, 0x5e,
+	0x83, 0x61, 0x03, 0xd3, 0x7e, 0x1f, 0xce, 0x64, 0x38, 0xa5, 0xd1, 0x85, 0xe3, 0xb4, 0x5c, 0xf9,
+	0x4d, 0x29, 0x63, 0xcc, 0xf9, 0xda, 0x8a, 0xfc, 0x1a, 0x0d, 0x8b, 0xae, 0x4e, 0xe6, 0xbc, 0xa6,
+	0xe5, 0xb2, 0x50, 0xab, 0x73, 0x59, 0x02, 0x70, 0x82, 0x63, 0xff, 0xaf, 0x02, 0x4c, 0x64, 0x28,
+	0xd6, 0x59, 0x3e, 0x85, 0x94, 0xec, 0x91, 0xa4, 0x4f, 0x30, 0x03, 0xfb, 0x15, 0x8e, 0x11, 0xd8,
+	0xaf, 0xd8, 0x2b, 0xb0, 0x5f, 0xe9, 0x83, 0x04, 0xf6, 0x33, 0x47, 0x6c, 0xa0, 0xaf, 0x11, 0xcb,
+	0x08, 0x06, 0x38, 0x78, 0xcc, 0x60, 0x80, 0xc6, 0xa0, 0x0f, 0xf5, 0x31, 0xe8, 0x3f, 0x5a, 0x80,
+	0xc9, 0xb4, 0x01, 0xdc, 0x29, 0xa8, 0x63, 0xdf, 0x30, 0xd4, 0xb1, 0xd9, 0xd9, 0x49, 0xd2, 0x66,
+	0x79, 0x79, 0xaa, 0x59, 0x9c, 0x52, 0xcd, 0x7e, 0xb2, 0x2f, 0x6a, 0xdd, 0xd5, 0xb4, 0x7f, 0xb7,
+	0x00, 0xe7, 0xd2, 0x55, 0x16, 0x3d, 0xc7, 0xdd, 0x3d, 0x85, 0xb1, 0xb9, 0x6b, 0x8c, 0xcd, 0xf3,
+	0xfd, 0x7c, 0x0d, 0xeb, 0x5a, 0xee, 0x00, 0xbd, 0x95, 0x1a, 0xa0, 0xb9, 0xfe, 0x49, 0x76, 0x1f,
+	0xa5, 0x6f, 0x16, 0xe1, 0x4a, 0x66, 0xbd, 0x44, 0x9b, 0xb9, 0x6c, 0x68, 0x33, 0x6f, 0xa4, 0xb4,
+	0x99, 0x76, 0xf7, 0xda, 0x27, 0xa3, 0xde, 0x14, 0xde, 0x82, 0x2c, 0xf8, 0xdb, 0x23, 0xaa, 0x36,
+	0x0d, 0x6f, 0x41, 0x45, 0x08, 0x9b, 0x74, 0xff, 0x22, 0xa9, 0x34, 0xff, 0xad, 0x05, 0x17, 0x33,
+	0xe7, 0xe6, 0x14, 0x54, 0x58, 0x6b, 0xa6, 0x0a, 0xeb, 0x99, 0xbe, 0x57, 0x6b, 0x8e, 0x4e, 0xeb,
+	0x0f, 0x8b, 0x39, 0xdf, 0xc2, 0x04, 0xf4, 0xbb, 0x30, 0xe2, 0x34, 0x1a, 0x24, 0x8a, 0x56, 0x83,
+	0xa6, 0x0a, 0x86, 0xf6, 0x3c, 0x93, 0xb3, 0x92, 0xe2, 0xa3, 0x83, 0xca, 0x4c, 0x9a, 0x44, 0x02,
+	0xc6, 0x3a, 0x05, 0x33, 0x7e, 0x63, 0xe1, 0x44, 0xe3, 0x37, 0xde, 0x00, 0xd8, 0x53, 0xdc, 0x7a,
+	0x5a, 0xc8, 0xd7, 0xf8, 0x78, 0x0d, 0x0b, 0x7d, 0x11, 0x86, 0x23, 0x71, 0x8d, 0x8b, 0xa5, 0xf8,
+	0x62, 0x9f, 0x73, 0xe5, 0x6c, 0x10, 0xcf, 0x74, 0x4b, 0x57, 0xfa, 0x10, 0x45, 0x12, 0x7d, 0x07,
+	0x4c, 0x46, 0x3c, 0xea, 0xc9, 0xa2, 0xe7, 0x44, 0xcc, 0xc7, 0x41, 0xac, 0x42, 0xe6, 0x6b, 0x5e,
+	0x4f, 0xc1, 0x70, 0x07, 0x36, 0x5a, 0x96, 0x1f, 0xc5, 0x42, 0xb4, 0xf0, 0x85, 0x79, 0x2d, 0xf9,
+	0x20, 0x91, 0xcd, 0xe9, 0x6c, 0x7a, 0xf8, 0xd9, 0xc0, 0x6b, 0x35, 0xed, 0x1f, 0x2d, 0xc1, 0x13,
+	0x5d, 0x0e, 0x31, 0x34, 0x6f, 0xbe, 0x51, 0x3e, 0x9b, 0x96, 0x7e, 0x67, 0x32, 0x2b, 0x1b, 0xe2,
+	0x70, 0x6a, 0xad, 0x14, 0x3e, 0xf0, 0x5a, 0xf9, 0x21, 0x4b, 0xd3, 0x4b, 0x70, 0x4b, 0xba, 0xcf,
+	0x1d, 0xf3, 0x70, 0x3e, 0x41, 0x45, 0xc5, 0x66, 0x86, 0xb4, 0x7f, 0xa3, 0xef, 0xee, 0xf4, 0x2d,
+	0xfe, 0x9f, 0xae, 0x76, 0xf6, 0x2b, 0x16, 0x3c, 0x99, 0xd9, 0x5f, 0xc3, 0xa6, 0x62, 0x0e, 0xca,
+	0x0d, 0x5a, 0xa8, 0xf9, 0x4d, 0x25, 0x0e, 0xa5, 0x12, 0x80, 0x13, 0x1c, 0xc3, 0x74, 0xa2, 0xd0,
+	0xd3, 0x74, 0xe2, 0x5f, 0x58, 0xd0, 0xb1, 0x80, 0x4f, 0xe1, 0x24, 0x5d, 0x31, 0x4f, 0xd2, 0x8f,
+	0xf7, 0x33, 0x97, 0x39, 0x87, 0xe8, 0xbf, 0x99, 0x84, 0xf3, 0x39, 0x8e, 0x12, 0x7b, 0x30, 0xb5,
+	0xd5, 0x20, 0xa6, 0x47, 0x9a, 0xf8, 0x98, 0x4c, 0xe7, 0xbd, 0xae, 0xee, 0x6b, 0x2c, 0x0d, 0xcf,
+	0x54, 0x07, 0x0a, 0xee, 0x6c, 0x02, 0x7d, 0xc5, 0x82, 0xb3, 0xce, 0x83, 0xa8, 0x23, 0xd9, 0xa2,
+	0x58, 0x33, 0x2f, 0x65, 0x6a, 0x29, 0x7a, 0x24, 0x67, 0xe4, 0x79, 0x89, 0xb2, 0xb0, 0x70, 0x66,
+	0x5b, 0x08, 0x8b, 0xf8, 0x95, 0x94, 0xdf, 0xee, 0xe2, 0x33, 0x99, 0xe5, 0xd1, 0xc2, 0xcf, 0x54,
+	0x09, 0xc1, 0x8a, 0x0e, 0xba, 0x0f, 0xe5, 0x2d, 0xe9, 0x66, 0x26, 0xce, 0xec, 0xcc, 0x4b, 0x30,
+	0xd3, 0x17, 0x8d, 0xbf, 0x1b, 0x2a, 0x10, 0x4e, 0x48, 0xa1, 0xd7, 0xa1, 0xe8, 0x6f, 0x46, 0xdd,
+	0xb2, 0xec, 0xa4, 0x4c, 0x8d, 0xb8, 0x3f, 0xf2, 0xda, 0x72, 0x1d, 0xd3, 0x8a, 0xe8, 0x16, 0x14,
+	0xc3, 0x8d, 0xa6, 0x50, 0xac, 0x65, 0xf2, 0xa5, 0x78, 0xa1, 0x9a, 0xbd, 0x48, 0x38, 0x25, 0xbc,
+	0x50, 0xc5, 0x94, 0x04, 0xaa, 0xc1, 0x00, 0xf3, 0x29, 0x10, 0xfa, 0xb3, 0x4c, 0x86, 0xb4, 0x8b,
+	0x6f, 0x0e, 0x77, 0x5a, 0x66, 0x08, 0x98, 0x13, 0x42, 0xeb, 0x30, 0xd8, 0x60, 0x19, 0x59, 0x44,
+	0xc8, 0xe4, 0x4f, 0x65, 0xaa, 0xd0, 0xba, 0xa4, 0xaa, 0x11, 0x1a, 0x25, 0x86, 0x81, 0x05, 0x2d,
+	0x46, 0x95, 0xb4, 0xb6, 0x37, 0x23, 0x26, 0x82, 0xe7, 0x51, 0xed, 0x92, 0x81, 0x49, 0x50, 0x65,
+	0x18, 0x58, 0xd0, 0x42, 0x9f, 0x81, 0xc2, 0x66, 0x43, 0xb8, 0x1c, 0x64, 0xea, 0xd2, 0x4c, 0x97,
+	0xf2, 0x85, 0xc1, 0xc3, 0x83, 0x4a, 0x61, 0x79, 0x11, 0x17, 0x36, 0x1b, 0x68, 0x0d, 0x86, 0x36,
+	0xb9, 0x13, 0xaa, 0x50, 0x97, 0x3d, 0x9d, 0xed, 0x1f, 0xdb, 0xe1, 0xa7, 0xca, 0x4d, 0xe5, 0x05,
+	0x00, 0x4b, 0x22, 0x2c, 0x08, 0xa4, 0x72, 0xa6, 0x15, 0xd1, 0x90, 0x67, 0x8f, 0xe7, 0x00, 0xcd,
+	0xdd, 0xdb, 0x13, 0x97, 0x5c, 0xac, 0x51, 0x44, 0x5f, 0x86, 0xb2, 0x23, 0xd3, 0xfc, 0x89, 0x68,
+	0x11, 0x2f, 0x66, 0x6e, 0xcc, 0xee, 0x19, 0x10, 0xf9, 0xaa, 0x56, 0x48, 0x38, 0x21, 0x8a, 0x76,
+	0x60, 0x6c, 0x2f, 0x6a, 0x6d, 0x13, 0xb9, 0x91, 0x59, 0xf0, 0x88, 0x9c, 0x8b, 0xeb, 0xbe, 0x40,
+	0x74, 0xc3, 0xb8, 0xed, 0x78, 0x1d, 0x67, 0x0f, 0x7b, 0x6c, 0xbe, 0xaf, 0x13, 0xc3, 0x26, 0x6d,
+	0x3a, 0xfc, 0xef, 0xb5, 0x83, 0x8d, 0xfd, 0x98, 0x88, 0xf0, 0xc9, 0x99, 0xc3, 0xff, 0x26, 0x47,
+	0xe9, 0x1c, 0x7e, 0x01, 0xc0, 0x92, 0x08, 0xfa, 0x12, 0x8c, 0x34, 0x92, 0x64, 0x61, 0x2c, 0x70,
+	0x72, 0xce, 0x7b, 0x54, 0x4e, 0x4e, 0x31, 0x1e, 0xcd, 0x4e, 0x03, 0x62, 0x9d, 0x20, 0x3b, 0x23,
+	0x5b, 0xdb, 0x41, 0x1c, 0xf8, 0xa9, 0xf3, 0x79, 0x2a, 0xff, 0x8c, 0xac, 0x65, 0xe0, 0x77, 0x9e,
+	0x91, 0x59, 0x58, 0x38, 0xb3, 0x2d, 0xd4, 0x84, 0xf1, 0x56, 0x10, 0xc6, 0x0f, 0x82, 0x50, 0xae,
+	0x33, 0xd4, 0x45, 0xec, 0x37, 0x30, 0x45, 0x8b, 0x2c, 0xac, 0xb7, 0x09, 0xc1, 0x29, 0x9a, 0xe8,
+	0xf3, 0x30, 0x14, 0x35, 0x1c, 0x8f, 0xac, 0xdc, 0x9d, 0x3e, 0x93, 0x7f, 0xf9, 0xd4, 0x39, 0x4a,
+	0xce, 0x2a, 0x63, 0x93, 0x24, 0x50, 0xb0, 0x24, 0x87, 0x96, 0x61, 0x80, 0xc5, 0xe6, 0x67, 0x11,
+	0xa0, 0x73, 0xa2, 0x13, 0x75, 0x18, 0x77, 0xf2, 0x33, 0x8a, 0x15, 0x63, 0x5e, 0x9d, 0xee, 0x05,
+	0xc1, 0xfd, 0x06, 0xd1, 0xf4, 0xb9, 0xfc, 0xbd, 0x20, 0x98, 0xe6, 0xbb, 0xf5, 0x6e, 0x7b, 0x41,
+	0x21, 0xe1, 0x84, 0x28, 0x3d, 0xa1, 0xe9, 0xa9, 0x7a, 0xbe, 0x8b, 0xbd, 0x49, 0xee, 0x99, 0xca,
+	0x4e, 0x68, 0x7a, 0xa2, 0x52, 0x12, 0xf4, 0x0e, 0x72, 0x64, 0x6e, 0xd7, 0xe9, 0x0b, 0xf9, 0x77,
+	0x50, 0x66, 0x02, 0x58, 0x6d, 0xb7, 0xb2, 0x65, 0x91, 0x90, 0xb2, 0x7f, 0x6f, 0xa8, 0x93, 0x13,
+	0x62, 0x72, 0xd8, 0x5f, 0xb6, 0x3a, 0x9e, 0xe8, 0x3e, 0xdd, 0xaf, 0x5a, 0xe8, 0x04, 0x79, 0xe0,
+	0xaf, 0x58, 0x70, 0xbe, 0x95, 0x39, 0x40, 0x82, 0xad, 0xe8, 0x4f, 0xbb, 0xc4, 0x87, 0x41, 0x45,
+	0x7f, 0xcf, 0x86, 0xe3, 0x9c, 0x96, 0xd2, 0x72, 0x46, 0xf1, 0x03, 0xcb, 0x19, 0xab, 0x30, 0xcc,
+	0x58, 0xd7, 0x1e, 0x19, 0xd0, 0xd2, 0x5e, 0x6e, 0x8c, 0x41, 0x59, 0x14, 0x15, 0xb1, 0x22, 0x81,
+	0x7e, 0xd8, 0x82, 0xcb, 0xe9, 0xae, 0x63, 0xc2, 0xc0, 0x22, 0x56, 0x3a, 0x17, 0x01, 0x97, 0xc5,
+	0xf7, 0x5f, 0xae, 0x75, 0x43, 0x3e, 0xea, 0x85, 0x80, 0xbb, 0x37, 0x86, 0xaa, 0x19, 0x32, 0xe8,
+	0xa0, 0xa9, 0x77, 0xef, 0x43, 0x0e, 0x7d, 0x09, 0x46, 0x77, 0x83, 0xb6, 0x1f, 0x0b, 0xb3, 0x17,
+	0xe1, 0x84, 0xc8, 0xde, 0x99, 0x57, 0xb5, 0x72, 0x6c, 0x60, 0xa5, 0xa4, 0xd7, 0xe1, 0x47, 0x95,
+	0x5e, 0xd1, 0x3b, 0xa9, 0x94, 0xda, 0xe5, 0xfc, 0x98, 0x7c, 0x42, 0xd0, 0x3f, 0x46, 0x62, 0xed,
+	0xd3, 0x95, 0xb8, 0x7e, 0xce, 0xca, 0x10, 0x15, 0xb8, 0x0c, 0xfe, 0x59, 0x53, 0x06, 0xbf, 0x96,
+	0x96, 0xc1, 0x3b, 0x74, 0xae, 0x86, 0xf8, 0xdd, 0x7f, 0x60, 0xe7, 0x7e, 0x23, 0xa5, 0xd9, 0x1e,
+	0x5c, 0xed, 0x75, 0xdd, 0x31, 0xfb, 0xa7, 0xa6, 0x7a, 0x61, 0x4b, 0xec, 0x9f, 0x9a, 0x2b, 0x55,
+	0xcc, 0x20, 0x7d, 0xe7, 0xeb, 0xfc, 0x6f, 0x16, 0x14, 0x6b, 0x41, 0xf3, 0x14, 0x74, 0xc8, 0x9f,
+	0x33, 0x74, 0xc8, 0x4f, 0xe4, 0xa4, 0x3a, 0xcf, 0xd5, 0x18, 0x2f, 0xa5, 0x34, 0xc6, 0x97, 0xf3,
+	0x08, 0x74, 0xd7, 0x0f, 0xff, 0x74, 0x11, 0xf4, 0xc4, 0xec, 0xe8, 0x5f, 0x3d, 0x8a, 0xf1, 0x71,
+	0xb1, 0x5b, 0xae, 0x76, 0x41, 0x99, 0x99, 0x4d, 0x49, 0xbf, 0xba, 0x3f, 0x67, 0x36, 0xc8, 0x6f,
+	0x11, 0x77, 0x6b, 0x3b, 0x26, 0xcd, 0xf4, 0xe7, 0x9c, 0x9e, 0x0d, 0xf2, 0x7f, 0xb1, 0x60, 0x22,
+	0xd5, 0x3a, 0xf2, 0x60, 0xcc, 0xd3, 0x15, 0x80, 0x62, 0x9d, 0x3e, 0x92, 0xee, 0x50, 0xd8, 0x70,
+	0x6a, 0x45, 0xd8, 0x24, 0x8e, 0x66, 0x01, 0xd4, 0x03, 0x9d, 0xd4, 0xab, 0x31, 0xa9, 0x42, 0xbd,
+	0xe0, 0x45, 0x58, 0xc3, 0x40, 0x2f, 0xc3, 0x48, 0x1c, 0xb4, 0x02, 0x2f, 0xd8, 0xda, 0xbf, 0x4d,
+	0x64, 0xf0, 0x16, 0x65, 0x99, 0xb5, 0x9e, 0x80, 0xb0, 0x8e, 0x67, 0xff, 0x6c, 0x11, 0xd2, 0xc9,
+	0xfc, 0xbf, 0xb5, 0x26, 0x3f, 0x9a, 0x6b, 0xf2, 0x9b, 0x16, 0x4c, 0xd2, 0xd6, 0x99, 0x95, 0x88,
+	0xbc, 0x6c, 0x55, 0x82, 0x19, 0xab, 0x4b, 0x82, 0x99, 0x6b, 0xf4, 0xec, 0x6a, 0x06, 0xed, 0x58,
+	0xe8, 0xe5, 0xb4, 0xc3, 0x89, 0x96, 0x62, 0x01, 0x15, 0x78, 0x24, 0x0c, 0x85, 0xeb, 0x93, 0x8e,
+	0x47, 0xc2, 0x10, 0x0b, 0xa8, 0xcc, 0x3f, 0x53, 0xca, 0xc9, 0x3f, 0xc3, 0x42, 0xd1, 0x09, 0x7b,
+	0x02, 0xc1, 0xf6, 0x68, 0xa1, 0xe8, 0xa4, 0xa1, 0x41, 0x82, 0x63, 0xff, 0x62, 0x11, 0x46, 0x6b,
+	0x41, 0x33, 0x79, 0x22, 0x7b, 0xc9, 0x78, 0x22, 0xbb, 0x9a, 0x7a, 0x22, 0x9b, 0xd4, 0x71, 0xbf,
+	0xf5, 0x20, 0xf6, 0x61, 0x3d, 0x88, 0xfd, 0x73, 0x8b, 0xcd, 0x5a, 0x75, 0xad, 0x2e, 0xf2, 0xdf,
+	0xbe, 0x00, 0x23, 0xec, 0x40, 0x62, 0xbe, 0x76, 0xf2, 0xdd, 0x88, 0x09, 0xe3, 0x6b, 0x49, 0x31,
+	0xd6, 0x71, 0xd0, 0x75, 0x18, 0x8e, 0x88, 0x13, 0x36, 0xb6, 0xd5, 0x19, 0x27, 0x5e, 0x55, 0x78,
+	0x19, 0x56, 0x50, 0xf4, 0x66, 0x12, 0x05, 0xad, 0x98, 0x9f, 0xc9, 0x55, 0xef, 0x0f, 0xdf, 0x22,
+	0xf9, 0xa1, 0xcf, 0xec, 0xb7, 0x00, 0x75, 0xe2, 0xf7, 0x11, 0xef, 0xa8, 0x62, 0xc6, 0x3b, 0x2a,
+	0x77, 0xc4, 0x3a, 0xfa, 0x53, 0x0b, 0xc6, 0x6b, 0x41, 0x93, 0x6e, 0xdd, 0xbf, 0x48, 0xfb, 0x54,
+	0x0f, 0x01, 0x39, 0xd8, 0x25, 0x04, 0xe4, 0xdf, 0xb3, 0x60, 0xa8, 0x16, 0x34, 0x4f, 0x41, 0x9b,
+	0xff, 0x59, 0x53, 0x9b, 0x7f, 0x21, 0x67, 0x49, 0xe4, 0x28, 0xf0, 0x7f, 0xb9, 0x08, 0x63, 0xb4,
+	0x9f, 0xc1, 0x96, 0x9c, 0x25, 0x63, 0x44, 0xac, 0x3e, 0x46, 0x84, 0xb2, 0xb9, 0x81, 0xe7, 0x05,
+	0x0f, 0xd2, 0x33, 0xb6, 0xcc, 0x4a, 0xb1, 0x80, 0xa2, 0xe7, 0x60, 0xb8, 0x15, 0x92, 0x3d, 0x37,
+	0x10, 0xfc, 0xa3, 0xf6, 0x36, 0x52, 0x13, 0xe5, 0x58, 0x61, 0x50, 0xb9, 0x2b, 0x72, 0xfd, 0x06,
+	0x91, 0x69, 0xa4, 0x4b, 0x2c, 0xd3, 0x14, 0x8f, 0xed, 0xac, 0x95, 0x63, 0x03, 0x0b, 0xbd, 0x05,
+	0x65, 0xf6, 0x9f, 0x9d, 0x28, 0xc7, 0xcf, 0x8c, 0x23, 0x12, 0x2a, 0x08, 0x02, 0x38, 0xa1, 0x85,
+	0x6e, 0x00, 0xc4, 0x32, 0xfe, 0x6f, 0x24, 0xc2, 0xd6, 0x28, 0x5e, 0x5b, 0x45, 0x06, 0x8e, 0xb0,
+	0x86, 0x85, 0x9e, 0x85, 0x72, 0xec, 0xb8, 0xde, 0x1d, 0xd7, 0x27, 0x11, 0x53, 0x69, 0x17, 0x65,
+	0xbe, 0x04, 0x51, 0x88, 0x13, 0x38, 0xe5, 0x75, 0x98, 0x4f, 0x37, 0xcf, 0xab, 0x35, 0xcc, 0xb0,
+	0x19, 0xaf, 0x73, 0x47, 0x95, 0x62, 0x0d, 0xc3, 0x7e, 0x15, 0xce, 0xd5, 0x82, 0x66, 0x2d, 0x08,
+	0xe3, 0xe5, 0x20, 0x7c, 0xe0, 0x84, 0x4d, 0x39, 0x7f, 0x15, 0x19, 0xba, 0x9f, 0x9e, 0x3d, 0x03,
+	0x7c, 0x67, 0x1a, 0x41, 0xf9, 0x5f, 0x64, 0xdc, 0xce, 0x31, 0x7d, 0x39, 0x1a, 0xec, 0xde, 0x55,
+	0x29, 0xf4, 0x6e, 0x3a, 0x31, 0x41, 0x77, 0x59, 0xda, 0xad, 0xe4, 0x0a, 0x12, 0xd5, 0x9f, 0xd1,
+	0xd2, 0x6e, 0x25, 0xc0, 0xcc, 0x3b, 0xcb, 0xac, 0x6f, 0xff, 0x7a, 0x91, 0x9d, 0x46, 0xa9, 0x8c,
+	0x72, 0xe8, 0x4b, 0x30, 0x1e, 0x91, 0x3b, 0xae, 0xdf, 0x7e, 0x28, 0x85, 0xf0, 0x2e, 0xde, 0x38,
+	0xf5, 0x25, 0x1d, 0x93, 0xab, 0x08, 0xcd, 0x32, 0x9c, 0xa2, 0x46, 0xe7, 0x29, 0x6c, 0xfb, 0xf3,
+	0xd1, 0xbd, 0x88, 0x84, 0x22, 0xa3, 0x19, 0x9b, 0x27, 0x2c, 0x0b, 0x71, 0x02, 0xa7, 0xeb, 0x92,
+	0xfd, 0x59, 0x0b, 0x7c, 0x1c, 0x04, 0xb1, 0x5c, 0xc9, 0x2c, 0x27, 0x8e, 0x56, 0x8e, 0x0d, 0x2c,
+	0xb4, 0x0c, 0x28, 0x6a, 0xb7, 0x5a, 0x1e, 0x7b, 0xcf, 0x77, 0xbc, 0x9b, 0x61, 0xd0, 0x6e, 0xf1,
+	0xb7, 0xd4, 0xe2, 0xc2, 0x79, 0x7a, 0x85, 0xd5, 0x3b, 0xa0, 0x38, 0xa3, 0x06, 0x3d, 0x7d, 0x36,
+	0x23, 0xf6, 0x9b, 0xad, 0xee, 0xa2, 0x50, 0xdf, 0xd7, 0x59, 0x11, 0x96, 0x30, 0xba, 0x98, 0x58,
+	0xf3, 0x1c, 0x73, 0x30, 0x59, 0x4c, 0x58, 0x95, 0x62, 0x0d, 0x03, 0x2d, 0xc1, 0x50, 0xb4, 0x1f,
+	0x35, 0x62, 0x11, 0x64, 0x29, 0x27, 0x37, 0x65, 0x9d, 0xa1, 0x68, 0xf9, 0x12, 0x78, 0x15, 0x2c,
+	0xeb, 0xda, 0xdf, 0xc3, 0x2e, 0x43, 0x96, 0xff, 0x2a, 0x6e, 0x87, 0x04, 0xed, 0xc2, 0x58, 0x8b,
+	0x4d, 0xb9, 0x88, 0xce, 0x2c, 0xe6, 0xed, 0xa5, 0x3e, 0xa5, 0xda, 0x07, 0xf4, 0xa0, 0x51, 0x5a,
+	0x27, 0x26, 0x2e, 0xd4, 0x74, 0x72, 0xd8, 0xa4, 0x6e, 0xff, 0xe0, 0x14, 0x3b, 0x73, 0xeb, 0x5c,
+	0x54, 0x1d, 0x12, 0x16, 0xc5, 0x82, 0x2f, 0x9f, 0xc9, 0xd7, 0x99, 0x24, 0x5f, 0x24, 0xac, 0x92,
+	0xb1, 0xac, 0x8b, 0xde, 0x64, 0x6f, 0xdf, 0xfc, 0xa0, 0xeb, 0x95, 0x86, 0x98, 0x63, 0x19, 0xcf,
+	0xdc, 0xa2, 0x22, 0xd6, 0x88, 0xa0, 0x3b, 0x30, 0x26, 0xd2, 0x25, 0x09, 0xa5, 0x58, 0xd1, 0x50,
+	0x7a, 0x8c, 0x61, 0x1d, 0x78, 0x94, 0x2e, 0xc0, 0x66, 0x65, 0xb4, 0x05, 0x97, 0xb5, 0xdc, 0x81,
+	0x37, 0x43, 0x87, 0xbd, 0x87, 0xba, 0x6c, 0x13, 0x69, 0xe7, 0xe6, 0x93, 0x87, 0x07, 0x95, 0xcb,
+	0xeb, 0xdd, 0x10, 0x71, 0x77, 0x3a, 0xe8, 0x2e, 0x9c, 0xe3, 0x8e, 0x7b, 0x55, 0xe2, 0x34, 0x3d,
+	0xd7, 0x57, 0x07, 0x33, 0x5f, 0x87, 0x17, 0x0f, 0x0f, 0x2a, 0xe7, 0xe6, 0xb3, 0x10, 0x70, 0x76,
+	0x3d, 0xf4, 0x59, 0x28, 0x37, 0xfd, 0x48, 0x8c, 0xc1, 0xa0, 0x91, 0x16, 0xb3, 0x5c, 0x5d, 0xab,
+	0xab, 0xef, 0x4f, 0xfe, 0xe0, 0xa4, 0x02, 0xda, 0xe2, 0x8a, 0x31, 0x25, 0x87, 0x0e, 0xe5, 0xa7,
+	0x40, 0x17, 0x4b, 0xc2, 0x70, 0xdd, 0xe1, 0x1a, 0x61, 0x65, 0xfa, 0x6a, 0x78, 0xf5, 0x18, 0x84,
+	0xd1, 0x1b, 0x80, 0x28, 0xa3, 0xe6, 0x36, 0xc8, 0x7c, 0x83, 0x05, 0xc9, 0x66, 0x7a, 0xc4, 0x61,
+	0xc3, 0x55, 0x02, 0xd5, 0x3b, 0x30, 0x70, 0x46, 0x2d, 0x74, 0x8b, 0x1e, 0x64, 0x7a, 0xa9, 0x30,
+	0xe1, 0x95, 0xcc, 0xfd, 0x74, 0x95, 0xb4, 0x42, 0xd2, 0x70, 0x62, 0xd2, 0x34, 0x29, 0xe2, 0x54,
+	0x3d, 0x7a, 0x97, 0xaa, 0x7c, 0x39, 0x60, 0x46, 0xc2, 0xe8, 0xcc, 0x99, 0x43, 0xe5, 0xe2, 0xed,
+	0x20, 0x8a, 0xd7, 0x48, 0xfc, 0x20, 0x08, 0x77, 0x44, 0xe0, 0xb1, 0x24, 0x06, 0x66, 0x02, 0xc2,
+	0x3a, 0x1e, 0xe5, 0x83, 0xd9, 0xe3, 0xf3, 0x4a, 0x95, 0xbd, 0x00, 0x0e, 0x27, 0xfb, 0xe4, 0x16,
+	0x2f, 0xc6, 0x12, 0x2e, 0x51, 0x57, 0x6a, 0x8b, 0xec, 0x35, 0x2f, 0x85, 0xba, 0x52, 0x5b, 0xc4,
+	0x12, 0x8e, 0x48, 0x67, 0xca, 0xd1, 0xf1, 0x7c, 0xad, 0x66, 0xe7, 0x75, 0xd0, 0x67, 0xd6, 0x51,
+	0x1f, 0x26, 0x55, 0xb2, 0x53, 0x1e, 0x91, 0x2d, 0x9a, 0x9e, 0x60, 0x8b, 0xa4, 0xff, 0x70, 0x6e,
+	0x4a, 0x4f, 0xbc, 0x92, 0xa2, 0x84, 0x3b, 0x68, 0x1b, 0xb1, 0x49, 0x26, 0x7b, 0xe6, 0x3b, 0x9a,
+	0x83, 0x72, 0xd4, 0xde, 0x68, 0x06, 0xbb, 0x8e, 0xeb, 0xb3, 0x47, 0x37, 0x8d, 0xc9, 0xaa, 0x4b,
+	0x00, 0x4e, 0x70, 0xd0, 0x32, 0x0c, 0x3b, 0x52, 0x09, 0x8c, 0xf2, 0x83, 0x15, 0x28, 0xd5, 0x2f,
+	0xf7, 0xdf, 0x95, 0x6a, 0x5f, 0x55, 0x17, 0xbd, 0x06, 0x63, 0xc2, 0x5d, 0x8b, 0x87, 0x70, 0x60,
+	0x8f, 0x62, 0x9a, 0x3d, 0x7e, 0x5d, 0x07, 0x62, 0x13, 0x17, 0x7d, 0x11, 0xc6, 0x29, 0x95, 0xe4,
+	0x60, 0x9b, 0x3e, 0xdb, 0xcf, 0x89, 0xa8, 0xe5, 0xb1, 0xd0, 0x2b, 0xe3, 0x14, 0x31, 0xd4, 0x84,
+	0x4b, 0x4e, 0x3b, 0x0e, 0x98, 0x22, 0xdd, 0x5c, 0xff, 0xeb, 0xc1, 0x0e, 0xf1, 0xd9, 0xdb, 0xd8,
+	0xf0, 0xc2, 0xd5, 0xc3, 0x83, 0xca, 0xa5, 0xf9, 0x2e, 0x78, 0xb8, 0x2b, 0x15, 0x74, 0x0f, 0x46,
+	0xe2, 0xc0, 0x63, 0x96, 0xf1, 0x94, 0x95, 0x38, 0x9f, 0x1f, 0xdb, 0x67, 0x5d, 0xa1, 0xe9, 0x4a,
+	0x24, 0x55, 0x15, 0xeb, 0x74, 0xd0, 0x3a, 0xdf, 0x63, 0x2c, 0xea, 0x29, 0x89, 0xa6, 0x2f, 0xe4,
+	0x0f, 0x8c, 0x0a, 0x8e, 0x6a, 0x6e, 0x41, 0x51, 0x13, 0xeb, 0x64, 0xd0, 0x4d, 0x98, 0x6a, 0x85,
+	0x6e, 0xc0, 0x16, 0xb6, 0x7a, 0xc4, 0x98, 0x36, 0x53, 0x17, 0xd4, 0xd2, 0x08, 0xb8, 0xb3, 0x0e,
+	0x15, 0x32, 0x65, 0xe1, 0xf4, 0x45, 0x9e, 0x07, 0x8b, 0x33, 0xde, 0xbc, 0x0c, 0x2b, 0x28, 0x5a,
+	0x65, 0xe7, 0x32, 0x17, 0x07, 0xa7, 0x67, 0xf2, 0x83, 0x3c, 0xe8, 0x62, 0x23, 0xe7, 0x97, 0xd4,
+	0x5f, 0x9c, 0x50, 0xa0, 0xf7, 0x46, 0xb4, 0xed, 0x84, 0xa4, 0x16, 0x06, 0x0d, 0xc2, 0x3b, 0xc3,
+	0x8d, 0xf2, 0x9f, 0xe0, 0xc1, 0x19, 0xe9, 0xbd, 0x51, 0xcf, 0x42, 0xc0, 0xd9, 0xf5, 0x50, 0x53,
+	0x4b, 0xff, 0x4c, 0xd9, 0xd0, 0x68, 0xfa, 0x52, 0x17, 0x33, 0xa6, 0x14, 0xcf, 0x9a, 0xac, 0x45,
+	0xa3, 0x38, 0xc2, 0x29, 0x9a, 0x33, 0xdf, 0x0e, 0x53, 0x1d, 0xf7, 0xc5, 0xb1, 0xe2, 0x82, 0xff,
+	0xc9, 0x00, 0x94, 0x95, 0x2a, 0x1c, 0xcd, 0x99, 0x2f, 0x1c, 0x17, 0xd3, 0x2f, 0x1c, 0xc3, 0x94,
+	0x23, 0xd7, 0x1f, 0x35, 0xd6, 0x0d, 0xa3, 0xbb, 0x42, 0x7e, 0x16, 0x2e, 0x9d, 0xa7, 0xee, 0xe9,
+	0x61, 0xa7, 0x69, 0x36, 0x8a, 0x7d, 0x3f, 0x95, 0x94, 0xba, 0x2a, 0x4b, 0xfa, 0x4c, 0x82, 0x4b,
+	0x85, 0xff, 0x56, 0xd0, 0x5c, 0xa9, 0xa5, 0xb3, 0x42, 0xd6, 0x68, 0x21, 0xe6, 0x30, 0x26, 0xbe,
+	0x51, 0xe6, 0x86, 0x89, 0x6f, 0x43, 0x8f, 0x28, 0xbe, 0x49, 0x02, 0x38, 0xa1, 0x85, 0x3c, 0x98,
+	0x6a, 0x98, 0x09, 0x3d, 0x95, 0x57, 0xdd, 0x53, 0x3d, 0x53, 0x6b, 0xb6, 0xb5, 0xec, 0x69, 0x8b,
+	0x69, 0x2a, 0xb8, 0x93, 0x30, 0x7a, 0x0d, 0x86, 0xdf, 0x0b, 0x22, 0xb6, 0xf9, 0xc4, 0x0d, 0x2f,
+	0xbd, 0x8f, 0x86, 0xdf, 0xbc, 0x5b, 0x67, 0xe5, 0x47, 0x07, 0x95, 0x91, 0x5a, 0xd0, 0x94, 0x7f,
+	0xb1, 0xaa, 0x80, 0x1e, 0xc2, 0x39, 0xe3, 0x5c, 0x54, 0xdd, 0x85, 0xfe, 0xbb, 0x7b, 0x59, 0x34,
+	0x77, 0x6e, 0x25, 0x8b, 0x12, 0xce, 0x6e, 0x80, 0x1e, 0x36, 0x7e, 0x20, 0x92, 0xe1, 0x4a, 0x2e,
+	0x82, 0x31, 0x0b, 0x65, 0xdd, 0xf7, 0x3c, 0x85, 0x80, 0x3b, 0xeb, 0xd8, 0x5f, 0xe3, 0x2f, 0x07,
+	0x42, 0xbf, 0x48, 0xa2, 0xb6, 0x77, 0x1a, 0xb9, 0x96, 0x96, 0x0c, 0xd5, 0xe7, 0x23, 0xbf, 0x4e,
+	0xfd, 0xa6, 0xc5, 0x5e, 0xa7, 0xd6, 0xc9, 0x6e, 0xcb, 0xa3, 0x52, 0xee, 0xe3, 0xef, 0xf8, 0x9b,
+	0x30, 0x1c, 0x8b, 0xd6, 0xba, 0xa5, 0x87, 0xd2, 0x3a, 0xc5, 0x5e, 0xe8, 0x14, 0x7f, 0x21, 0x4b,
+	0xb1, 0x22, 0x63, 0xff, 0x53, 0x3e, 0x03, 0x12, 0x72, 0x0a, 0x6a, 0xa8, 0xaa, 0xa9, 0x86, 0xaa,
+	0xf4, 0xf8, 0x82, 0x1c, 0x75, 0xd4, 0x3f, 0x31, 0xfb, 0xcd, 0x44, 0xb9, 0x8f, 0xfa, 0xb3, 0xa8,
+	0xfd, 0x63, 0x16, 0x9c, 0xcd, 0xb2, 0x4f, 0xa2, 0x3c, 0x21, 0x17, 0x24, 0xd5, 0x33, 0xb1, 0x1a,
+	0xc1, 0xfb, 0xa2, 0x1c, 0x2b, 0x8c, 0xbe, 0x33, 0x2f, 0x1c, 0x2f, 0x3c, 0xdb, 0x5d, 0x18, 0xab,
+	0x85, 0x44, 0xbb, 0x03, 0x5e, 0xe7, 0x6e, 0x6c, 0xbc, 0x3f, 0xcf, 0x1d, 0xdb, 0x85, 0xcd, 0xfe,
+	0xf9, 0x02, 0x9c, 0xe5, 0xef, 0x3c, 0xf3, 0x7b, 0x81, 0xdb, 0xac, 0x05, 0x4d, 0x91, 0x35, 0xe3,
+	0x6d, 0x18, 0x6d, 0x69, 0xd2, 0x7f, 0xb7, 0x00, 0x51, 0xba, 0x96, 0x20, 0x91, 0xc2, 0xf4, 0x52,
+	0x6c, 0xd0, 0x42, 0x4d, 0x18, 0x25, 0x7b, 0x6e, 0x43, 0x3d, 0x16, 0x14, 0x8e, 0x7d, 0x37, 0xa8,
+	0x56, 0x96, 0x34, 0x3a, 0xd8, 0xa0, 0xfa, 0x18, 0x12, 0xa9, 0xd9, 0x3f, 0x6e, 0xc1, 0x85, 0x9c,
+	0x70, 0x52, 0xb4, 0xb9, 0x07, 0xec, 0x45, 0x4d, 0xe4, 0x64, 0x52, 0xcd, 0xf1, 0x77, 0x36, 0x2c,
+	0xa0, 0xe8, 0xf3, 0x00, 0xfc, 0x9d, 0x8c, 0x0a, 0x25, 0xbd, 0xe2, 0xee, 0x18, 0x21, 0x43, 0xb4,
+	0x50, 0x0f, 0xb2, 0x3e, 0xd6, 0x68, 0xd9, 0x3f, 0x53, 0x84, 0x01, 0xf6, 0x2e, 0x83, 0x96, 0x61,
+	0x68, 0x9b, 0x07, 0x4f, 0xee, 0x27, 0x4e, 0x73, 0x22, 0xdd, 0xf1, 0x02, 0x2c, 0x2b, 0xa3, 0x55,
+	0x38, 0xc3, 0x83, 0x4f, 0x7b, 0x55, 0xe2, 0x39, 0xfb, 0x52, 0x49, 0xc0, 0xf3, 0x18, 0xa9, 0xb0,
+	0x15, 0x2b, 0x9d, 0x28, 0x38, 0xab, 0x1e, 0x7a, 0x1d, 0xc6, 0x63, 0x77, 0x97, 0x04, 0xed, 0x58,
+	0x52, 0xe2, 0x61, 0xa7, 0x15, 0x1b, 0xb7, 0x6e, 0x40, 0x71, 0x0a, 0x9b, 0x8a, 0x3b, 0xad, 0x0e,
+	0x75, 0xc8, 0x40, 0x22, 0xee, 0x98, 0x2a, 0x10, 0x13, 0x97, 0x19, 0x10, 0xb5, 0x99, 0xb9, 0xd4,
+	0xfa, 0x76, 0x48, 0xa2, 0xed, 0xc0, 0x6b, 0x8a, 0x34, 0xd8, 0x89, 0x01, 0x51, 0x0a, 0x8e, 0x3b,
+	0x6a, 0x50, 0x2a, 0x9b, 0x8e, 0xeb, 0xb5, 0x43, 0x92, 0x50, 0x19, 0x34, 0xa9, 0x2c, 0xa7, 0xe0,
+	0xb8, 0xa3, 0x06, 0x5d, 0x47, 0xe7, 0x44, 0x5e, 0x6a, 0xe9, 0x4c, 0xaf, 0xac, 0xc2, 0x86, 0xa4,
+	0x5b, 0x51, 0x97, 0x68, 0x32, 0xc2, 0x6e, 0x46, 0x65, 0xb6, 0xd6, 0xb4, 0x78, 0xc2, 0xa1, 0x48,
+	0x52, 0x79, 0x94, 0xec, 0xc8, 0xbf, 0x67, 0xc1, 0x99, 0x0c, 0xeb, 0x56, 0x7e, 0x54, 0x6d, 0xb9,
+	0x51, 0xac, 0x72, 0xb5, 0x68, 0x47, 0x15, 0x2f, 0xc7, 0x0a, 0x83, 0xee, 0x07, 0x7e, 0x18, 0xa6,
+	0x0f, 0x40, 0x61, 0xdd, 0x25, 0xa0, 0xc7, 0x3b, 0x00, 0xd1, 0x55, 0x28, 0xb5, 0x23, 0x22, 0xe3,
+	0x40, 0xa9, 0xf3, 0x9b, 0xe9, 0x75, 0x19, 0x84, 0xb2, 0xa6, 0x5b, 0x4a, 0xa5, 0xaa, 0xb1, 0xa6,
+	0x5c, 0x4f, 0xca, 0x61, 0xf6, 0x57, 0x8b, 0x70, 0x31, 0xd7, 0x8e, 0x9d, 0x76, 0x69, 0x37, 0xf0,
+	0xdd, 0x38, 0x50, 0x6f, 0x7e, 0x3c, 0x12, 0x09, 0x69, 0x6d, 0xaf, 0x8a, 0x72, 0xac, 0x30, 0xd0,
+	0x35, 0x99, 0x21, 0x3d, 0x9d, 0x8d, 0x66, 0xa1, 0x6a, 0x24, 0x49, 0xef, 0x37, 0xd3, 0xd7, 0x53,
+	0x50, 0x6a, 0x05, 0x81, 0x97, 0x3e, 0x8c, 0x68, 0x77, 0x83, 0xc0, 0xc3, 0x0c, 0x88, 0x3e, 0x21,
+	0xc6, 0x21, 0xf5, 0xc8, 0x85, 0x9d, 0x66, 0x10, 0x69, 0x83, 0xf1, 0x0c, 0x0c, 0xed, 0x90, 0xfd,
+	0xd0, 0xf5, 0xb7, 0xd2, 0x8f, 0x9f, 0xb7, 0x79, 0x31, 0x96, 0x70, 0x33, 0x19, 0xc3, 0xd0, 0x49,
+	0xa7, 0xe8, 0x1a, 0xee, 0x79, 0xb5, 0xfd, 0x50, 0x11, 0x26, 0xf0, 0x42, 0xf5, 0x5b, 0x13, 0x71,
+	0xaf, 0x73, 0x22, 0x4e, 0x3a, 0x45, 0x57, 0xef, 0xd9, 0xf8, 0x65, 0x0b, 0x26, 0x58, 0xc0, 0x62,
+	0x11, 0xff, 0xc2, 0x0d, 0xfc, 0x53, 0x60, 0xdd, 0x9e, 0x82, 0x81, 0x90, 0x36, 0x9a, 0xce, 0xbb,
+	0xc3, 0x7a, 0x82, 0x39, 0x0c, 0x5d, 0x82, 0x12, 0xeb, 0x02, 0x9d, 0xbc, 0x51, 0x9e, 0xb2, 0xa0,
+	0xea, 0xc4, 0x0e, 0x66, 0xa5, 0xcc, 0xa9, 0x1b, 0x93, 0x96, 0xe7, 0xf2, 0x4e, 0x27, 0x0f, 0x0a,
+	0x1f, 0x0d, 0xa7, 0xee, 0xcc, 0xae, 0x7d, 0x30, 0xa7, 0xee, 0x6c, 0x92, 0xdd, 0xc5, 0xa2, 0xff,
+	0x5e, 0x80, 0x2b, 0x99, 0xf5, 0xfa, 0x76, 0xea, 0xee, 0x5e, 0xfb, 0x64, 0x6c, 0x58, 0xb2, 0x4d,
+	0x4b, 0x8a, 0xa7, 0x68, 0x5a, 0x52, 0xea, 0x97, 0x73, 0x1c, 0xe8, 0xc3, 0xd7, 0x3a, 0x73, 0xc8,
+	0x3e, 0x22, 0xbe, 0xd6, 0x99, 0x7d, 0xcb, 0x11, 0xeb, 0xfe, 0xac, 0x90, 0xf3, 0x2d, 0x4c, 0xc0,
+	0xbb, 0x4e, 0xcf, 0x19, 0x06, 0x8c, 0x04, 0x27, 0x3c, 0xca, 0xcf, 0x18, 0x5e, 0x86, 0x15, 0x14,
+	0xb9, 0x9a, 0xd7, 0x72, 0x21, 0x3f, 0x2b, 0x63, 0x6e, 0x53, 0xb3, 0xe6, 0xfb, 0x8f, 0x1a, 0x82,
+	0x0c, 0x0f, 0xe6, 0x55, 0x4d, 0x28, 0x2f, 0xf6, 0x2f, 0x94, 0x8f, 0x66, 0x0b, 0xe4, 0x68, 0x1e,
+	0x26, 0x76, 0x5d, 0x9f, 0x65, 0xd9, 0x37, 0x59, 0x51, 0x15, 0xc4, 0x63, 0xd5, 0x04, 0xe3, 0x34,
+	0xfe, 0xcc, 0x6b, 0x30, 0xf6, 0xe8, 0xea, 0xc8, 0x6f, 0x16, 0xe1, 0x89, 0x2e, 0xdb, 0x9e, 0x9f,
+	0xf5, 0xc6, 0x1c, 0x68, 0x67, 0x7d, 0xc7, 0x3c, 0xd4, 0xe0, 0xec, 0x66, 0xdb, 0xf3, 0xf6, 0x99,
+	0xf5, 0x26, 0x69, 0x4a, 0x0c, 0xc1, 0x2b, 0x5e, 0x92, 0x49, 0x22, 0x96, 0x33, 0x70, 0x70, 0x66,
+	0x4d, 0xf4, 0x06, 0xa0, 0x40, 0xa4, 0x84, 0xbd, 0x49, 0x7c, 0xa1, 0x55, 0x67, 0x03, 0x5f, 0x4c,
+	0x36, 0xe3, 0xdd, 0x0e, 0x0c, 0x9c, 0x51, 0x8b, 0x32, 0xfd, 0xf4, 0x56, 0xda, 0x57, 0xdd, 0x4a,
+	0x31, 0xfd, 0x58, 0x07, 0x62, 0x13, 0x17, 0xdd, 0x84, 0x29, 0x67, 0xcf, 0x71, 0x79, 0x70, 0x3b,
+	0x49, 0x80, 0x73, 0xfd, 0x4a, 0x09, 0x36, 0x9f, 0x46, 0xc0, 0x9d, 0x75, 0x52, 0x6e, 0xd3, 0x83,
+	0xf9, 0x6e, 0xd3, 0xdd, 0xcf, 0xc5, 0x5e, 0x3a, 0x5d, 0xfb, 0x3f, 0x59, 0xf4, 0xfa, 0xca, 0x48,
+	0xeb, 0x4e, 0xc7, 0x41, 0xe9, 0x26, 0x35, 0x0f, 0xe6, 0x73, 0x9a, 0x7d, 0x46, 0x02, 0xc4, 0x26,
+	0x2e, 0x5f, 0x10, 0x51, 0xe2, 0xe2, 0x62, 0xb0, 0xee, 0x22, 0x44, 0x81, 0xc2, 0x40, 0x5f, 0x80,
+	0xa1, 0xa6, 0xbb, 0xe7, 0x46, 0x41, 0x28, 0x36, 0xcb, 0x31, 0x1d, 0x05, 0x92, 0x73, 0xb0, 0xca,
+	0xc9, 0x60, 0x49, 0xcf, 0xfe, 0xa1, 0x02, 0x8c, 0xc9, 0x16, 0xdf, 0x6c, 0x07, 0xb1, 0x73, 0x0a,
+	0xd7, 0xf2, 0x4d, 0xe3, 0x5a, 0xfe, 0x44, 0xb7, 0x38, 0x0d, 0xac, 0x4b, 0xb9, 0xd7, 0xf1, 0xdd,
+	0xd4, 0x75, 0xfc, 0x74, 0x6f, 0x52, 0xdd, 0xaf, 0xe1, 0x7f, 0x66, 0xc1, 0x94, 0x81, 0x7f, 0x0a,
+	0xb7, 0xc1, 0xb2, 0x79, 0x1b, 0x3c, 0xd9, 0xf3, 0x1b, 0x72, 0x6e, 0x81, 0xef, 0x2b, 0xa6, 0xfa,
+	0xce, 0x4e, 0xff, 0xf7, 0xa0, 0xb4, 0xed, 0x84, 0xcd, 0x6e, 0xf1, 0x60, 0x3b, 0x2a, 0xcd, 0xde,
+	0x72, 0xc2, 0x26, 0x3f, 0xc3, 0x9f, 0x53, 0x89, 0x24, 0x9d, 0xb0, 0xd9, 0xd3, 0xa3, 0x8b, 0x35,
+	0x85, 0x5e, 0x85, 0xc1, 0xa8, 0x11, 0xb4, 0x94, 0xbd, 0xe5, 0x55, 0x9e, 0x64, 0x92, 0x96, 0x1c,
+	0x1d, 0x54, 0x90, 0xd9, 0x1c, 0x2d, 0xc6, 0x02, 0x1f, 0xbd, 0x0d, 0x63, 0xec, 0x97, 0xb2, 0x3b,
+	0x28, 0xe6, 0x67, 0x21, 0xa8, 0xeb, 0x88, 0xdc, 0x7c, 0xc5, 0x28, 0xc2, 0x26, 0xa9, 0x99, 0x2d,
+	0x28, 0xab, 0xcf, 0x7a, 0xac, 0x9e, 0x38, 0xff, 0xbe, 0x08, 0x67, 0x32, 0xd6, 0x1c, 0x8a, 0x8c,
+	0x99, 0x78, 0xa1, 0xcf, 0xa5, 0xfa, 0x01, 0xe7, 0x22, 0x62, 0xd2, 0x50, 0x53, 0xac, 0xad, 0xbe,
+	0x1b, 0xbd, 0x17, 0x91, 0x74, 0xa3, 0xb4, 0xa8, 0x77, 0xa3, 0xb4, 0xb1, 0x53, 0x1b, 0x6a, 0xda,
+	0x90, 0xea, 0xe9, 0x63, 0x9d, 0xd3, 0x3f, 0x2e, 0xc2, 0xd9, 0xac, 0xd0, 0x31, 0xe8, 0xbb, 0x53,
+	0xd9, 0x66, 0x5e, 0xea, 0x37, 0xe8, 0x0c, 0x4f, 0x41, 0x23, 0x72, 0x27, 0xcf, 0x9a, 0xf9, 0x67,
+	0x7a, 0x0e, 0xb3, 0x68, 0x93, 0xb9, 0x6f, 0x86, 0x3c, 0x4b, 0x90, 0x3c, 0x3e, 0x3e, 0xdd, 0x77,
+	0x07, 0x44, 0x7a, 0xa1, 0x28, 0xe5, 0xbe, 0x29, 0x8b, 0x7b, 0xbb, 0x6f, 0xca, 0x96, 0x67, 0x5c,
+	0x18, 0xd1, 0xbe, 0xe6, 0xb1, 0xce, 0xf8, 0x0e, 0xbd, 0xad, 0xb4, 0x7e, 0x3f, 0xd6, 0x59, 0xff,
+	0x71, 0x0b, 0x52, 0xc6, 0x8d, 0x4a, 0xdd, 0x65, 0xe5, 0xaa, 0xbb, 0xae, 0x42, 0x29, 0x0c, 0x3c,
+	0x92, 0x4e, 0x00, 0x83, 0x03, 0x8f, 0x60, 0x06, 0xa1, 0x18, 0x71, 0xa2, 0xec, 0x18, 0xd5, 0x05,
+	0x39, 0x21, 0xa2, 0x3d, 0x05, 0x03, 0x1e, 0xd9, 0x23, 0x5e, 0x3a, 0xba, 0xfa, 0x1d, 0x5a, 0x88,
+	0x39, 0xcc, 0xfe, 0xe5, 0x12, 0x5c, 0xee, 0xea, 0x58, 0x4d, 0xc5, 0xa1, 0x2d, 0x27, 0x26, 0x0f,
+	0x9c, 0xfd, 0x74, 0x18, 0xe4, 0x9b, 0xbc, 0x18, 0x4b, 0x38, 0xb3, 0xf7, 0xe6, 0x61, 0x0f, 0x53,
+	0xca, 0x41, 0x11, 0xed, 0x50, 0x40, 0x1f, 0x43, 0xde, 0xf8, 0x1b, 0x00, 0x51, 0xe4, 0x2d, 0xf9,
+	0x94, 0xbb, 0x6b, 0x0a, 0x43, 0xf2, 0x24, 0x3c, 0x66, 0xfd, 0x8e, 0x80, 0x60, 0x0d, 0x0b, 0x55,
+	0x61, 0xb2, 0x15, 0x06, 0x31, 0xd7, 0xb5, 0x56, 0xb9, 0x99, 0xcf, 0x80, 0xe9, 0x7b, 0x5a, 0x4b,
+	0xc1, 0x71, 0x47, 0x0d, 0xf4, 0x32, 0x8c, 0x08, 0x7f, 0xd4, 0x5a, 0x10, 0x78, 0x42, 0x0d, 0xa4,
+	0x8c, 0x46, 0xea, 0x09, 0x08, 0xeb, 0x78, 0x5a, 0x35, 0xa6, 0xc0, 0x1d, 0xca, 0xac, 0xc6, 0x95,
+	0xb8, 0x1a, 0x5e, 0x2a, 0x8c, 0xd4, 0x70, 0x5f, 0x61, 0xa4, 0x12, 0xc5, 0x58, 0xb9, 0xef, 0x37,
+	0x2b, 0xe8, 0xa9, 0x4a, 0xfa, 0x85, 0x12, 0x9c, 0x11, 0x0b, 0xe7, 0x71, 0x2f, 0x97, 0xc7, 0x94,
+	0xdd, 0xfe, 0x5b, 0x6b, 0xe6, 0xb4, 0xd7, 0xcc, 0x0f, 0x5b, 0x60, 0xb2, 0x57, 0xe8, 0xff, 0xcb,
+	0x8d, 0x23, 0xff, 0x72, 0x2e, 0xbb, 0xd6, 0x94, 0x17, 0xc8, 0x07, 0x8c, 0x28, 0x6f, 0xff, 0x47,
+	0x0b, 0x9e, 0xec, 0x49, 0x11, 0x2d, 0x41, 0x99, 0xf1, 0x80, 0x9a, 0x74, 0xf6, 0xb4, 0x32, 0x03,
+	0x94, 0x80, 0x1c, 0x96, 0x34, 0xa9, 0x89, 0x96, 0x3a, 0x02, 0xf6, 0x3f, 0x93, 0x11, 0xb0, 0xff,
+	0x9c, 0x31, 0x3c, 0x8f, 0x18, 0xb1, 0xff, 0x6b, 0x45, 0x18, 0xe4, 0x2b, 0xfe, 0x14, 0xc4, 0xb0,
+	0x65, 0xa1, 0xb7, 0xed, 0x12, 0xa7, 0x8a, 0xf7, 0x65, 0xb6, 0xea, 0xc4, 0x0e, 0x67, 0x13, 0xd4,
+	0x6d, 0x95, 0x68, 0x78, 0xd1, 0xac, 0x71, 0x9f, 0xcd, 0xa4, 0x14, 0x93, 0xc0, 0x69, 0x68, 0xb7,
+	0xdb, 0x97, 0x00, 0x22, 0x96, 0xc8, 0x9e, 0xd2, 0x10, 0x11, 0xcf, 0x3e, 0xd9, 0xa5, 0xf5, 0xba,
+	0x42, 0xe6, 0x7d, 0x48, 0x76, 0xba, 0x02, 0x60, 0x8d, 0xe2, 0xcc, 0x2b, 0x50, 0x56, 0xc8, 0xbd,
+	0xb4, 0x38, 0xa3, 0x3a, 0x73, 0xf1, 0x39, 0x98, 0x48, 0xb5, 0x75, 0x2c, 0x25, 0xd0, 0xaf, 0x58,
+	0x30, 0xc1, 0xbb, 0xbc, 0xe4, 0xef, 0x89, 0x33, 0xf5, 0x7d, 0x38, 0xeb, 0x65, 0x9c, 0x6d, 0x62,
+	0x46, 0xfb, 0x3f, 0x0b, 0x95, 0xd2, 0x27, 0x0b, 0x8a, 0x33, 0xdb, 0x40, 0xd7, 0xe9, 0xba, 0xa5,
+	0x67, 0x97, 0xe3, 0x09, 0xdf, 0xa1, 0x51, 0xbe, 0x66, 0x79, 0x19, 0x56, 0x50, 0xfb, 0x77, 0x2c,
+	0x98, 0xe2, 0x3d, 0xbf, 0x4d, 0xf6, 0xd5, 0x0e, 0xff, 0x30, 0xfb, 0x2e, 0x72, 0x68, 0x14, 0x72,
+	0x72, 0x68, 0xe8, 0x9f, 0x56, 0xec, 0xfa, 0x69, 0x3f, 0x6f, 0x81, 0x58, 0x81, 0xa7, 0x20, 0xca,
+	0x7f, 0xbb, 0x29, 0xca, 0xcf, 0xe4, 0x2f, 0xea, 0x1c, 0x19, 0xfe, 0x4f, 0x2d, 0x98, 0xe4, 0x08,
+	0xc9, 0x5b, 0xf2, 0x87, 0x3a, 0x0f, 0xfd, 0x24, 0xc3, 0x53, 0xd9, 0xaf, 0xb3, 0x3f, 0xca, 0x98,
+	0xac, 0x52, 0xd7, 0xc9, 0x6a, 0xca, 0x0d, 0x74, 0x8c, 0x24, 0x8f, 0xc7, 0x8e, 0x45, 0x6d, 0xff,
+	0x91, 0x05, 0x88, 0x37, 0x63, 0xb0, 0x3f, 0x94, 0xa9, 0x60, 0xa5, 0xda, 0x75, 0x91, 0x1c, 0x35,
+	0x0a, 0x82, 0x35, 0xac, 0x13, 0x19, 0x9e, 0x94, 0x41, 0x40, 0xb1, 0xb7, 0x41, 0xc0, 0x31, 0x46,
+	0xf4, 0x6b, 0x25, 0x48, 0x1b, 0xf3, 0xa3, 0xfb, 0x30, 0xda, 0x70, 0x5a, 0xce, 0x86, 0xeb, 0xb9,
+	0xb1, 0x4b, 0xa2, 0x6e, 0x96, 0x44, 0x8b, 0x1a, 0x9e, 0x78, 0xea, 0xd5, 0x4a, 0xb0, 0x41, 0x07,
+	0xcd, 0x02, 0xb4, 0x42, 0x77, 0xcf, 0xf5, 0xc8, 0x16, 0xd3, 0x38, 0x30, 0x6f, 0x45, 0x6e, 0x1e,
+	0x23, 0x4b, 0xb1, 0x86, 0x91, 0xe1, 0x78, 0x56, 0x7c, 0x7c, 0x8e, 0x67, 0xa5, 0x63, 0x3a, 0x9e,
+	0x0d, 0xf4, 0xe5, 0x78, 0x86, 0xe1, 0xbc, 0x64, 0x91, 0xe8, 0xff, 0x65, 0xd7, 0x23, 0x82, 0x2f,
+	0xe6, 0x3e, 0x8c, 0x33, 0x87, 0x07, 0x95, 0xf3, 0x38, 0x13, 0x03, 0xe7, 0xd4, 0x44, 0x9f, 0x87,
+	0x69, 0xc7, 0xf3, 0x82, 0x07, 0x6a, 0xd4, 0x96, 0xa2, 0x86, 0xe3, 0x71, 0x8d, 0xfd, 0x10, 0xa3,
+	0x7a, 0xe9, 0xf0, 0xa0, 0x32, 0x3d, 0x9f, 0x83, 0x83, 0x73, 0x6b, 0xa7, 0xfc, 0xd6, 0x86, 0x7b,
+	0xf9, 0xad, 0xd9, 0x3b, 0x70, 0xa6, 0x4e, 0x42, 0x97, 0xa5, 0xa0, 0x6c, 0x26, 0x5b, 0x72, 0x1d,
+	0xca, 0x61, 0xea, 0x10, 0xea, 0x2b, 0xb0, 0x91, 0x16, 0x66, 0x57, 0x1e, 0x3a, 0x09, 0x21, 0xfb,
+	0x4f, 0x2c, 0x18, 0x12, 0x0e, 0x05, 0xa7, 0xc0, 0xfb, 0xcc, 0x1b, 0x2a, 0xe8, 0x4a, 0xf6, 0x41,
+	0xcd, 0x3a, 0x93, 0xab, 0x7c, 0x5e, 0x49, 0x29, 0x9f, 0x9f, 0xec, 0x46, 0xa4, 0xbb, 0xda, 0xf9,
+	0x6f, 0x15, 0x61, 0xdc, 0x74, 0xa6, 0x38, 0x85, 0x21, 0x58, 0x83, 0xa1, 0x48, 0x78, 0xee, 0x14,
+	0xf2, 0x6d, 0x9f, 0xd3, 0x93, 0x98, 0x18, 0x36, 0x09, 0x5f, 0x1d, 0x49, 0x24, 0xd3, 0x25, 0xa8,
+	0xf8, 0x18, 0x5d, 0x82, 0x7a, 0xf9, 0xb3, 0x94, 0x4e, 0xc2, 0x9f, 0xc5, 0xfe, 0x3a, 0xbb, 0x2c,
+	0xf4, 0xf2, 0x53, 0xe0, 0x23, 0x6e, 0x9a, 0xd7, 0x8a, 0xdd, 0x65, 0x65, 0x89, 0x4e, 0xe5, 0xf0,
+	0x13, 0xbf, 0x64, 0xc1, 0xe5, 0x8c, 0xaf, 0xd2, 0x98, 0x8b, 0xe7, 0x60, 0xd8, 0x69, 0x37, 0x5d,
+	0xb5, 0x97, 0xb5, 0x87, 0xa8, 0x79, 0x51, 0x8e, 0x15, 0x06, 0x5a, 0x84, 0x29, 0xf2, 0xb0, 0xe5,
+	0xf2, 0x97, 0x40, 0xdd, 0xfa, 0xb0, 0xc8, 0x43, 0xc8, 0x2e, 0xa5, 0x81, 0xb8, 0x13, 0x5f, 0xb9,
+	0x43, 0x17, 0x73, 0xdd, 0xa1, 0xff, 0xa1, 0x05, 0x23, 0xa2, 0xdb, 0xa7, 0x30, 0xda, 0xdf, 0x61,
+	0x8e, 0xf6, 0x13, 0x5d, 0x46, 0x3b, 0x67, 0x98, 0xff, 0x4e, 0x41, 0xf5, 0xb7, 0x16, 0x84, 0x71,
+	0x1f, 0x4c, 0xcb, 0xab, 0x30, 0xdc, 0x0a, 0x83, 0x38, 0x68, 0x04, 0x9e, 0xe0, 0x59, 0x2e, 0x25,
+	0xde, 0xfa, 0xbc, 0xfc, 0x48, 0xfb, 0x8d, 0x15, 0x36, 0x1b, 0xbd, 0x20, 0x8c, 0x05, 0x9f, 0x90,
+	0x8c, 0x5e, 0x10, 0xc6, 0x98, 0x41, 0x50, 0x13, 0x20, 0x76, 0xc2, 0x2d, 0x12, 0xd3, 0x32, 0x11,
+	0xf8, 0x23, 0xff, 0xf0, 0x68, 0xc7, 0xae, 0x37, 0xeb, 0xfa, 0x71, 0x14, 0x87, 0xb3, 0x2b, 0x7e,
+	0x7c, 0x37, 0xe4, 0x22, 0x90, 0xe6, 0x7e, 0xaf, 0x68, 0x61, 0x8d, 0xae, 0xf4, 0x91, 0x64, 0x6d,
+	0x0c, 0x98, 0x4f, 0xda, 0x6b, 0xa2, 0x1c, 0x2b, 0x0c, 0xfb, 0x15, 0x76, 0x95, 0xb0, 0x01, 0x3a,
+	0x9e, 0x67, 0xfc, 0x37, 0x86, 0xd5, 0xd0, 0xb2, 0xf7, 0xac, 0xaa, 0xee, 0x7f, 0xdf, 0xfd, 0xe4,
+	0xa6, 0x0d, 0xeb, 0x9e, 0x30, 0x89, 0x93, 0x3e, 0xfa, 0xce, 0x0e, 0x4b, 0x87, 0xe7, 0x7b, 0x5c,
+	0x01, 0xc7, 0xb0, 0x6d, 0x60, 0x61, 0xad, 0x59, 0xf8, 0xdf, 0x95, 0x9a, 0x58, 0xe4, 0x5a, 0x58,
+	0x6b, 0x01, 0xc0, 0x09, 0x0e, 0x9a, 0x13, 0x02, 0x74, 0xc9, 0xc8, 0x3e, 0x27, 0x05, 0x68, 0xf9,
+	0xf9, 0x9a, 0x04, 0xfd, 0x02, 0x8c, 0xa8, 0x2c, 0x74, 0x35, 0x9e, 0xcc, 0x4b, 0x84, 0x41, 0x59,
+	0x4a, 0x8a, 0xb1, 0x8e, 0x83, 0xd6, 0x61, 0x22, 0xe2, 0xda, 0x13, 0x15, 0xed, 0x8e, 0x6b, 0xa1,
+	0x3e, 0x29, 0x2d, 0x24, 0xea, 0x26, 0xf8, 0x88, 0x15, 0xf1, 0xa3, 0x43, 0x3a, 0x3a, 0xa6, 0x49,
+	0xa0, 0xd7, 0x61, 0xdc, 0xd3, 0x73, 0xb9, 0xd7, 0x84, 0x92, 0x4a, 0x19, 0x10, 0x1b, 0x99, 0xde,
+	0x6b, 0x38, 0x85, 0x4d, 0x79, 0x1d, 0xbd, 0x44, 0x44, 0x68, 0x74, 0xfc, 0x2d, 0x12, 0x89, 0x1c,
+	0x5a, 0x8c, 0xd7, 0xb9, 0x93, 0x83, 0x83, 0x73, 0x6b, 0xa3, 0x57, 0x61, 0x54, 0x7e, 0xbe, 0xe6,
+	0xc6, 0x9b, 0x98, 0xa9, 0x6b, 0x30, 0x6c, 0x60, 0xa2, 0x07, 0x70, 0x4e, 0xfe, 0x5f, 0x0f, 0x9d,
+	0xcd, 0x4d, 0xb7, 0x21, 0xbc, 0xa8, 0xb9, 0xaf, 0xce, 0xbc, 0x74, 0xfe, 0x59, 0xca, 0x42, 0x3a,
+	0x3a, 0xa8, 0x5c, 0x15, 0xa3, 0x96, 0x09, 0x67, 0x93, 0x98, 0x4d, 0x1f, 0xad, 0xc2, 0x99, 0x6d,
+	0xe2, 0x78, 0xf1, 0xf6, 0xe2, 0x36, 0x69, 0xec, 0xc8, 0x4d, 0xc4, 0x9c, 0x83, 0x35, 0xe3, 0xee,
+	0x5b, 0x9d, 0x28, 0x38, 0xab, 0x1e, 0x7a, 0x07, 0xa6, 0x5b, 0xed, 0x0d, 0xcf, 0x8d, 0xb6, 0xd7,
+	0x82, 0x98, 0x19, 0x65, 0xa8, 0x24, 0x6e, 0xc2, 0x8b, 0x58, 0x39, 0x46, 0xd7, 0x72, 0xf0, 0x70,
+	0x2e, 0x05, 0xf4, 0x3e, 0x9c, 0x4b, 0x2d, 0x06, 0xe1, 0xd3, 0x38, 0x9e, 0x1f, 0xb6, 0xb4, 0x9e,
+	0x55, 0x41, 0xf8, 0x28, 0x66, 0x81, 0x70, 0x76, 0x13, 0x1f, 0xcc, 0x54, 0xe7, 0x3d, 0x5a, 0x59,
+	0x63, 0xca, 0xd0, 0x97, 0x61, 0x54, 0x5f, 0x45, 0xe2, 0x82, 0xb9, 0x96, 0xcd, 0xb3, 0x68, 0xab,
+	0x8d, 0xb3, 0x74, 0x6a, 0x45, 0xe9, 0x30, 0x6c, 0x50, 0xb4, 0x09, 0x64, 0x7f, 0x1f, 0xba, 0x03,
+	0xc3, 0x0d, 0xcf, 0x25, 0x7e, 0xbc, 0x52, 0xeb, 0x16, 0x74, 0x63, 0x51, 0xe0, 0x88, 0x01, 0x13,
+	0x01, 0x42, 0x79, 0x19, 0x56, 0x14, 0xec, 0xdf, 0x28, 0x40, 0xa5, 0x47, 0x14, 0xdb, 0x94, 0x46,
+	0xd9, 0xea, 0x4b, 0xa3, 0x3c, 0x2f, 0x53, 0xd2, 0xad, 0xa5, 0xc4, 0xec, 0x54, 0xba, 0xb9, 0x44,
+	0xd8, 0x4e, 0xe3, 0xf7, 0x6d, 0xe1, 0xab, 0x2b, 0xa5, 0x4b, 0x3d, 0x6d, 0xcf, 0x8d, 0xc7, 0xa8,
+	0x81, 0xfe, 0x05, 0x91, 0xdc, 0x87, 0x05, 0xfb, 0xeb, 0x05, 0x38, 0xa7, 0x86, 0xf0, 0x2f, 0xee,
+	0xc0, 0xdd, 0xeb, 0x1c, 0xb8, 0x13, 0x78, 0x96, 0xb1, 0xef, 0xc2, 0x20, 0x0f, 0x5a, 0xd2, 0x07,
+	0x03, 0xf4, 0x94, 0x19, 0xe1, 0x4a, 0x5d, 0xd3, 0x46, 0x94, 0xab, 0xbf, 0x62, 0xc1, 0xc4, 0xfa,
+	0x62, 0xad, 0x1e, 0x34, 0x76, 0x48, 0x3c, 0xcf, 0x19, 0x56, 0x2c, 0xf8, 0x1f, 0xeb, 0x11, 0xf9,
+	0x9a, 0x2c, 0x8e, 0xe9, 0x2a, 0x94, 0xb6, 0x83, 0x28, 0x4e, 0xbf, 0xd9, 0xde, 0x0a, 0xa2, 0x18,
+	0x33, 0x88, 0xfd, 0xbb, 0x16, 0x0c, 0xb0, 0x44, 0xaa, 0xbd, 0xb2, 0xfb, 0xf6, 0xf3, 0x5d, 0xe8,
+	0x65, 0x18, 0x24, 0x9b, 0x9b, 0xa4, 0x11, 0x8b, 0x59, 0x95, 0x0e, 0xa5, 0x83, 0x4b, 0xac, 0x94,
+	0x5e, 0xfa, 0xac, 0x31, 0xfe, 0x17, 0x0b, 0x64, 0xf4, 0x16, 0x94, 0x63, 0x77, 0x97, 0xcc, 0x37,
+	0x9b, 0xe2, 0xd5, 0xeb, 0x11, 0xfc, 0x77, 0xd7, 0x25, 0x01, 0x9c, 0xd0, 0xb2, 0xbf, 0x5a, 0x00,
+	0x48, 0x5c, 0xef, 0x7b, 0x7d, 0xe2, 0x42, 0xc7, 0x7b, 0xc8, 0xb5, 0x8c, 0xf7, 0x10, 0x94, 0x10,
+	0xcc, 0x78, 0x0c, 0x51, 0xc3, 0x54, 0xec, 0x6b, 0x98, 0x4a, 0xc7, 0x19, 0xa6, 0x45, 0x98, 0x4a,
+	0x42, 0x07, 0x98, 0x71, 0x54, 0x98, 0x90, 0xb2, 0x9e, 0x06, 0xe2, 0x4e, 0x7c, 0x9b, 0xc0, 0x55,
+	0x19, 0xd1, 0x52, 0xde, 0x35, 0xcc, 0xa8, 0xf2, 0x18, 0x89, 0x9e, 0x93, 0x07, 0x9f, 0x42, 0xee,
+	0x83, 0xcf, 0x4f, 0x59, 0x70, 0x36, 0xdd, 0x0e, 0xf3, 0x5e, 0xfb, 0x01, 0x0b, 0xce, 0xb1, 0x67,
+	0x2f, 0xd6, 0x6a, 0xe7, 0x23, 0xdb, 0x4b, 0xd9, 0x21, 0x15, 0xba, 0xf7, 0x38, 0xf1, 0x5c, 0x5e,
+	0xcd, 0x22, 0x8d, 0xb3, 0x5b, 0xb4, 0xbf, 0xdf, 0x02, 0xe1, 0x24, 0xd4, 0xc7, 0xc6, 0x7e, 0x5b,
+	0xa6, 0x42, 0x35, 0x02, 0x78, 0x5f, 0xcd, 0xf7, 0x9a, 0x12, 0x61, 0xbb, 0xd5, 0x45, 0x6a, 0x04,
+	0xeb, 0x36, 0x68, 0xd9, 0x4d, 0x10, 0xd0, 0x2a, 0x61, 0x7a, 0xa2, 0xde, 0xbd, 0xb9, 0x01, 0xd0,
+	0x64, 0xb8, 0x5a, 0x42, 0x44, 0x75, 0x6c, 0x57, 0x15, 0x04, 0x6b, 0x58, 0xf6, 0x8f, 0x14, 0x60,
+	0x44, 0x06, 0x8c, 0x6e, 0xfb, 0xfd, 0x48, 0x73, 0xc7, 0xca, 0x4b, 0xc3, 0x32, 0x88, 0x52, 0xc2,
+	0xb5, 0x44, 0x08, 0x4e, 0x32, 0x88, 0x4a, 0x00, 0x4e, 0x70, 0xd0, 0x33, 0x30, 0x14, 0xb5, 0x37,
+	0x18, 0x7a, 0xca, 0xf5, 0xa5, 0xce, 0x8b, 0xb1, 0x84, 0xa3, 0xcf, 0xc3, 0x24, 0xaf, 0x17, 0x06,
+	0x2d, 0x67, 0x8b, 0x2b, 0x0d, 0x07, 0x94, 0x2f, 0xea, 0xe4, 0x6a, 0x0a, 0x76, 0x74, 0x50, 0x39,
+	0x9b, 0x2e, 0x63, 0xea, 0xe6, 0x0e, 0x2a, 0xf6, 0x97, 0x01, 0x75, 0xc6, 0xc0, 0x46, 0x6f, 0x70,
+	0x03, 0x24, 0x37, 0x24, 0xcd, 0x6e, 0x7a, 0x64, 0xdd, 0x75, 0x52, 0x9a, 0x9f, 0xf3, 0x5a, 0x58,
+	0xd5, 0xb7, 0xff, 0x5a, 0x11, 0x26, 0xd3, 0x8e, 0x74, 0xe8, 0x16, 0x0c, 0xf2, 0x0b, 0x46, 0x90,
+	0xef, 0xf2, 0x4c, 0xa9, 0xb9, 0xdf, 0xb1, 0xad, 0x26, 0xee, 0x28, 0x51, 0x1f, 0xbd, 0x03, 0x23,
+	0xcd, 0xe0, 0x81, 0xff, 0xc0, 0x09, 0x9b, 0xf3, 0xb5, 0x15, 0xb1, 0x2e, 0x33, 0xf9, 0xd4, 0x6a,
+	0x82, 0xa6, 0xbb, 0xf4, 0x31, 0x95, 0x7c, 0x02, 0xc2, 0x3a, 0x39, 0xb4, 0xce, 0xe2, 0xfa, 0x6d,
+	0xba, 0x5b, 0xab, 0x4e, 0xab, 0x9b, 0x35, 0xea, 0xa2, 0x44, 0xd2, 0x28, 0x8f, 0x89, 0xe0, 0x7f,
+	0x1c, 0x80, 0x13, 0x42, 0xe8, 0xbb, 0xe1, 0x4c, 0x94, 0xa3, 0xda, 0xca, 0x4b, 0xb5, 0xd0, 0x4d,
+	0xdb, 0xb3, 0x70, 0x81, 0x4a, 0x10, 0x59, 0x4a, 0xb0, 0xac, 0x66, 0xec, 0xc3, 0x33, 0x60, 0xec,
+	0x46, 0x23, 0xef, 0x8e, 0x75, 0x42, 0x79, 0x77, 0x30, 0x0c, 0x93, 0xdd, 0x56, 0xbc, 0x5f, 0x75,
+	0xc3, 0x6e, 0x89, 0xdb, 0x96, 0x04, 0x4e, 0x27, 0x4d, 0x09, 0xc1, 0x8a, 0x4e, 0x76, 0x72, 0xa4,
+	0xe2, 0x87, 0x98, 0x1c, 0xa9, 0x74, 0x8a, 0xc9, 0x91, 0xd6, 0x60, 0x68, 0xcb, 0x8d, 0x31, 0x69,
+	0x05, 0x82, 0xb5, 0xcb, 0x5c, 0x87, 0x37, 0x39, 0x4a, 0x67, 0x22, 0x0e, 0x01, 0xc0, 0x92, 0x08,
+	0x7a, 0x43, 0xed, 0xc0, 0xc1, 0x7c, 0xc9, 0xa8, 0xf3, 0x3d, 0x2d, 0x73, 0x0f, 0x8a, 0x64, 0x48,
+	0x43, 0x8f, 0x9a, 0x0c, 0x69, 0x59, 0xa6, 0x30, 0x1a, 0xce, 0x37, 0x1d, 0x67, 0x19, 0x8a, 0x7a,
+	0x24, 0x2e, 0x32, 0x92, 0x3d, 0x95, 0x4f, 0x2e, 0xd9, 0xd3, 0xf7, 0x5b, 0x70, 0xae, 0x95, 0x95,
+	0xf7, 0x4c, 0x24, 0x1e, 0x7a, 0xb9, 0xef, 0xc4, 0x6e, 0x46, 0x83, 0x4c, 0x44, 0xce, 0x44, 0xc3,
+	0xd9, 0xcd, 0xd1, 0x81, 0x0e, 0x37, 0x9a, 0x22, 0x5b, 0xd1, 0x53, 0x39, 0x59, 0xa3, 0xba, 0xe4,
+	0x8a, 0x5a, 0xcf, 0xc8, 0x50, 0xf4, 0xf1, 0xbc, 0x0c, 0x45, 0x7d, 0xe7, 0x25, 0x7a, 0x43, 0xe5,
+	0x8b, 0x1a, 0xcb, 0x5f, 0x4a, 0x3c, 0x1b, 0x54, 0xcf, 0x2c, 0x51, 0x6f, 0xa8, 0x2c, 0x51, 0x5d,
+	0xe2, 0x9b, 0xf1, 0x1c, 0x50, 0x3d, 0x73, 0x43, 0x69, 0xf9, 0x9d, 0x26, 0x4e, 0x26, 0xbf, 0x93,
+	0x71, 0xd5, 0x74, 0x49, 0x30, 0xa4, 0xdd, 0x27, 0x9d, 0x09, 0x86, 0x72, 0x2f, 0x1b, 0x9e, 0xcb,
+	0x6a, 0xea, 0x91, 0x72, 0x59, 0xdd, 0xd7, 0x73, 0x43, 0xa1, 0x1e, 0x39, 0x66, 0x28, 0x52, 0x9f,
+	0x19, 0xa1, 0xee, 0xeb, 0x17, 0xe0, 0x99, 0x7c, 0xba, 0xea, 0x9e, 0xeb, 0xa4, 0x9b, 0x79, 0x05,
+	0x76, 0x64, 0x9a, 0x3a, 0x7b, 0x3a, 0x99, 0xa6, 0xce, 0x3d, 0x86, 0x4c, 0x53, 0xe7, 0x4f, 0x2d,
+	0xd3, 0xd4, 0x85, 0x0f, 0x35, 0xd3, 0xd4, 0xf4, 0x63, 0xc8, 0x34, 0xb5, 0x96, 0x64, 0x9a, 0xba,
+	0x98, 0x3f, 0x35, 0x19, 0x76, 0xad, 0x39, 0xf9, 0xa5, 0xee, 0x43, 0xb9, 0x25, 0x23, 0x3e, 0x88,
+	0x40, 0x6c, 0xd9, 0x49, 0x6f, 0xb3, 0xc2, 0x42, 0xf0, 0xf5, 0xaa, 0x40, 0x38, 0x21, 0x45, 0xe9,
+	0x26, 0xf9, 0xa6, 0x9e, 0xe8, 0xa2, 0x0c, 0xcd, 0x52, 0x33, 0x75, 0xc9, 0x32, 0x65, 0xe4, 0x86,
+	0xba, 0x74, 0x72, 0xb9, 0xa1, 0xfe, 0x6a, 0x01, 0xae, 0x74, 0xdf, 0x37, 0x89, 0xee, 0xab, 0x96,
+	0xbc, 0xd5, 0xa4, 0x74, 0x5f, 0x5c, 0x88, 0x4a, 0xb0, 0xfa, 0x0e, 0xb7, 0x73, 0x13, 0xa6, 0x94,
+	0xa1, 0xac, 0xe7, 0x36, 0xf6, 0xb5, 0x24, 0xbb, 0xca, 0x21, 0xb0, 0x9e, 0x46, 0xc0, 0x9d, 0x75,
+	0xd0, 0x3c, 0x4c, 0x18, 0x85, 0x2b, 0x55, 0x21, 0x2c, 0x29, 0x65, 0x5b, 0xdd, 0x04, 0xe3, 0x34,
+	0xbe, 0xfd, 0x73, 0x16, 0x5c, 0xc8, 0x49, 0xc2, 0xd0, 0x77, 0x34, 0x99, 0x4d, 0x98, 0x68, 0x99,
+	0x55, 0x7b, 0x04, 0x9d, 0x32, 0x52, 0x3d, 0xa8, 0xbe, 0xa6, 0x00, 0x38, 0x4d, 0x74, 0xe1, 0xfa,
+	0x6f, 0xfd, 0xfe, 0x95, 0x8f, 0xfd, 0xf6, 0xef, 0x5f, 0xf9, 0xd8, 0xef, 0xfc, 0xfe, 0x95, 0x8f,
+	0xfd, 0xff, 0x87, 0x57, 0xac, 0xdf, 0x3a, 0xbc, 0x62, 0xfd, 0xf6, 0xe1, 0x15, 0xeb, 0x77, 0x0e,
+	0xaf, 0x58, 0xbf, 0x77, 0x78, 0xc5, 0xfa, 0xea, 0x1f, 0x5c, 0xf9, 0xd8, 0xdb, 0x85, 0xbd, 0x17,
+	0xfe, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x60, 0x08, 0xf7, 0x9c, 0xf8, 0xe6, 0x00, 0x00,
 }
diff --git a/staging/src/k8s.io/api/core/v1/types.go b/staging/src/k8s.io/api/core/v1/types.go
index d9f4869fbc..5417d75199 100644
--- a/staging/src/k8s.io/api/core/v1/types.go
+++ b/staging/src/k8s.io/api/core/v1/types.go
@@ -133,9 +133,9 @@ type VolumeSource struct {
 	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 	// +optional
 	Quobyte *QuobyteVolumeSource `json:"quobyte,omitempty" protobuf:"bytes,21,opt,name=quobyte"`
-	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
+	// CascadeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine
 	// +optional
-	AzureDisk *AzureDiskVolumeSource `json:"azureDisk,omitempty" protobuf:"bytes,22,opt,name=azureDisk"`
+	CascadeDisk *CascadeDiskVolumeSource `json:"vkeDisk,omitempty" protobuf:"bytes,22,opt,name=cascadeDisk"`
 	// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 	PhotonPersistentDisk *PhotonPersistentDiskVolumeSource `json:"photonPersistentDisk,omitempty" protobuf:"bytes,23,opt,name=photonPersistentDisk"`
 	// Items for all in one resources secrets, configmaps, and downward API
@@ -149,6 +149,9 @@ type VolumeSource struct {
 	// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 	// +optional
 	StorageOS *StorageOSVolumeSource `json:"storageos,omitempty" protobuf:"bytes,27,opt,name=storageos"`
+	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
+	// +optional
+	AzureDisk *AzureDiskVolumeSource `json:"azureDisk,omitempty" protobuf:"bytes,28,opt,name=azureDisk"`
 }
 
 // PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
@@ -228,9 +231,9 @@ type PersistentVolumeSource struct {
 	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 	// +optional
 	Quobyte *QuobyteVolumeSource `json:"quobyte,omitempty" protobuf:"bytes,15,opt,name=quobyte"`
-	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
+	// CascadeDisk represents a Cascade persistent disk attached and mounted on kubelets host machine
 	// +optional
-	AzureDisk *AzureDiskVolumeSource `json:"azureDisk,omitempty" protobuf:"bytes,16,opt,name=azureDisk"`
+	CascadeDisk *CascadeDiskVolumeSource `json:"vkeDisk,omitempty" protobuf:"bytes,16,opt,name=cascadeDisk"`
 	// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 	PhotonPersistentDisk *PhotonPersistentDiskVolumeSource `json:"photonPersistentDisk,omitempty" protobuf:"bytes,17,opt,name=photonPersistentDisk"`
 	// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
@@ -249,6 +252,9 @@ type PersistentVolumeSource struct {
 	// CSI represents storage that handled by an external CSI driver (Beta feature).
 	// +optional
 	CSI *CSIPersistentVolumeSource `json:"csi,omitempty" protobuf:"bytes,22,opt,name=csi"`
+	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
+	// +optional
+	AzureDisk *AzureDiskVolumeSource `json:"azureDisk,omitempty" protobuf:"bytes,23,opt,name=azureDisk"`
 }
 
 const (
@@ -1446,6 +1452,16 @@ type StorageOSPersistentVolumeSource struct {
 	SecretRef *ObjectReference `json:"secretRef,omitempty" protobuf:"bytes,5,opt,name=secretRef"`
 }
 
+// Represents a Photon Controller persistent disk resource.
+type CascadeDiskVolumeSource struct {
+	// ID that identifies Cascade persistent disk
+	DiskID string `json:"diskID" protobuf:"bytes,1,opt,name=diskID"`
+	// Filesystem type to mount.
+	// Must be a filesystem type supported by the host operating system.
+	// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
+	FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
+}
+
 // Adapts a ConfigMap into a volume.
 //
 // The contents of the target ConfigMap's Data field will be presented in a
-- 
2.17.2 (Apple Git-113)

