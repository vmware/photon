=== added file './cloudinit/distros/photon.py'
--- ./cloudinit/distros/photon.py	1970-01-01 00:00:00 +0000
+++ ./cloudinit/distros/photon.py	2015-03-06 01:28:00 +0000
@@ -0,0 +1,134 @@
+# vi: ts=4 expandtab
+#
+#    Author: Mahmoud Bassiouny <mbassiouny@vmware.com>
+#
+
+import os
+
+from cloudinit import distros
+from cloudinit import helpers
+from cloudinit import log as logging
+from cloudinit import util
+
+from cloudinit.distros.parsers.hostname import HostnameConf
+
+from cloudinit.settings import PER_INSTANCE
+
+LOG = logging.getLogger(__name__)
+
+class Distro(distros.Distro):
+    hostname_conf_fn = "/etc/hostname"
+    locale_conf_fn = "/etc/default/locale"
+    network_conf_dir = "/etc/systemd/network/"
+    resolve_conf_fn = "/etc/resolv.conf"
+    init_cmd = ['systemctl']  # init scripts
+
+    def __init__(self, name, cfg, paths):
+        distros.Distro.__init__(self, name, cfg, paths)
+        # This will be used to restrict certain
+        # calls from repeatly happening (when they
+        # should only happen say once per instance...)
+        self._runner = helpers.Runners(paths)
+        self.osfamily = 'photon'
+
+    def apply_locale(self, locale, out_fn=None):
+        if not out_fn:
+            out_fn = self.locale_conf_fn
+        util.subp(['locale-gen', locale], capture=False)
+        util.subp(['update-locale', locale], capture=False)
+        # "" provides trailing newline during join
+        lines = [
+            util.make_header(),
+            'LANG="%s"' % (locale),
+            "",
+        ]
+        util.write_file(out_fn, "\n".join(lines))
+
+    def install_packages(self, pkglist):
+        #self.update_package_sources()
+        self.package_command('install', pkgs=pkglist)
+
+    def _write_network(self, settings):
+        entries = net_util.translate_network(settings)
+        LOG.debug("Translated ubuntu style network settings %s into %s",
+                  settings, entries)
+        dev_names = entries.keys()
+        dev_index = 10;
+        # Format for systemd
+        for (dev, info) in entries.items():
+            if dev == 'lo':
+                continue
+            nameservers = []
+            net_fn = self.network_conf_dir + str(dev_index) + '-' + dev + '.network'
+            dhcp_enabled = 'no'
+            if info.get('bootproto') == 'dhcp':
+                dhcp_enabled = 'yes'        
+            net_cfg = {
+                'Name': dev,
+                'DHCP': dhcp_enabled,
+                'Address': "%s/%s" % (info.get('address'),
+                                          info.get('netmask')),
+                'MACAddress': info.get('hwaddress'),
+                'Gateway': info.get('gateway'),
+                'DNS': str(tuple(info.get('dns-nameservers'))).replace(',', '')
+            }
+            if info.get('auto'):
+                self._write_interface_file(net_fn, net_cfg)
+            if 'dns-nameservers' in info:
+                nameservers.extend(info['dns-nameservers'])
+            dev_index = dev_index + 1;
+
+        if nameservers:
+            util.write_file(self.resolve_conf_fn,
+                            convert_resolv_conf(nameservers))
+
+        return dev_names
+
+    def _write_interface_file(self, net_fn, net_cfg):
+        if not net_cfg['Name']:
+            return
+        content = "[Match]\n"
+        content += "Name=%s\n" % (net_cfg['Name'])
+        if net_cfg['MACAddress']:
+            content += "MACAddress=%s\n" % (net_cfg['MACAddress'])
+        content += "[Network]\n"
+        if net_cfg['DHCP'] == 'yes':
+            content += "DHCP=%s\n" % (net_cfg['DHCP'])
+        else:
+            if net_cfg['Address']:
+                content += "Address=%s\n" % (net_cfg['Address'])
+            if net_cfg['Gateway']:
+                content += "Gateway=%s\n" % (net_cfg['Gateway'])
+        try:
+            tf = tempfile.NamedTemporaryFile(dir=os.path.dirname(net_fn),
+                                         delete=False, mode="wb")
+            tf.write(content)
+            tf.close()
+            os.chmod(tf.name, 0o644)
+            os.rename(tf.name, net_fn)
+        except Exception as e:
+            if tf is not None:
+                os.unlink(tf.name)
+            raise e
+
+
+    def _bring_up_interfaces(self, device_names):
+        cmd = ['systemctl', 'restart', 'systemd-networkd']
+        LOG.debug("Attempting to run bring up interfaces using command %s",
+                  cmd)
+        try:
+            (_out, err) = util.subp(cmd)
+            if len(err):
+                LOG.warn("Running %s resulted in stderr output: %s", cmd, err)
+            return True
+        except util.ProcessExecutionError:
+            util.logexc(LOG, "Running network bringup command %s failed", cmd)
+            return False
+
+    def _select_hostname(self, hostname, fqdn):
+        # Prefer the short hostname over the long
+        # fully qualified domain name
+        if not hostname:
+            return fqdn
+        return hostname
+
+    def _write_hostname(self, your_hostname, out_fn):
+        conf = None
+        try:
+            # Try to update the previous one
+            # so lets see if we can read it first.
+            conf = self._read_hostname_conf(out_fn)
+        except IOError:
+            pass
+        if not conf:
+            conf = HostnameConf('')
+        conf.set_hostname(your_hostname)
+        util.write_file(out_fn, str(conf), 0644)
+
+    def _read_system_hostname(self):
+        sys_hostname = self._read_hostname(self.hostname_conf_fn)
+        return (self.hostname_conf_fn, sys_hostname)
+
+    def _read_hostname_conf(self, filename):
+        conf = HostnameConf(util.load_file(filename))
+        conf.parse()
+        return conf
+
+    def _read_hostname(self, filename, default=None):
+        hostname = None
+        try:
+            conf = self._read_hostname_conf(filename)
+            hostname = conf.hostname
+        except IOError:
+            pass
+        if not hostname:
+            return default
+        return hostname
+
+    def _get_localhost_ip(self):
+        return "127.0.1.1"
+
+    def set_timezone(self, tz):
+        distros.set_etc_timezone(tz=tz, tz_file=self._find_tz_file(tz))
+
+    def package_command(self, command, args=None, pkgs=None):
+        if pkgs is None:
+            pkgs = []
+
+        cmd = ['tdnf']
+        # Determines whether or not tdnf prompts for confirmation
+        # of critical actions. We don't want to prompt...
+        cmd.append("-y")
+
+        if args and isinstance(args, str):
+            cmd.append(args)
+        elif args and isinstance(args, list):
+            cmd.extend(args)
+
+        cmd.append(command)
+
+        pkglist = util.expand_package_list('%s-%s', pkgs)
+        cmd.extend(pkglist)
+
+        # Allow the output of this to flow outwards (ie not be captured)
+        util.subp(cmd, capture=False)
+
+    def update_package_sources(self):
+        self._runner.run("update-sources", self.package_command,
+                         ["makecache"], freq=PER_INSTANCE)
+
+def convert_resolv_conf(settings):
+    """Returns a settings string formatted for resolv.conf."""
+    result = ''
+    if isinstance(settings, list):
+        for ns in settings:
+            result = result + 'nameserver %s\n' % ns
+    return result
