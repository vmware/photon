From 32957298010e50c83e355aba5980d60d3ab6805a Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Fri, 17 Jun 2022 14:32:26 +0000
Subject: [PATCH 1/8] scripts-kallsyms: Extra kallsyms parsing

From: Keerthana K <keerthanak@vmware.com>

Adding new option "--extra-symbols=<kallsyms-file>" to scripts/kallsyms.c
This helps in adding required symbols to vmlinux when CONFIG_KALLSYMS_ALL
is disabled.

Signed-off-by: Keerthana K <keerthanak@vmware.com>
[Ajay: Regenerated the patch for v6.1.45]
Signed-off-by: Ajay Kaher <akaher@vmware.com>
---
 scripts/kallsyms.c      | 114 +++++++++++++++++++++++++++++++++++-----
 scripts/link-vmlinux.sh |   2 +
 2 files changed, 102 insertions(+), 14 deletions(-)

diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 653b92f6d..46f239755 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -27,6 +27,8 @@
 #include <string.h>
 #include <ctype.h>
 #include <limits.h>
+#include <getopt.h>
+#include <errno.h>

 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

@@ -48,6 +50,10 @@ struct addr_range {

 static unsigned long long _text;
 static unsigned long long relative_base;
+
+char **extra_sym_tbl = NULL;
+int extra_sym_tbl_size = 0;
+
 static struct addr_range text_ranges[] = {
	{ "_stext",     "_etext"     },
	{ "_sinittext", "_einittext" },
@@ -62,6 +68,7 @@ static struct addr_range percpu_range = {
 static struct sym_entry **table;
 static unsigned int table_size, table_cnt;
 static int all_symbols;
+static int extra_symbols;
 static int absolute_percpu;
 static int base_relative;
 static int lto_clang;
@@ -75,7 +82,7 @@ static unsigned char best_table_len[256];

 static void usage(void)
 {
-	fprintf(stderr, "Usage: kallsyms [--all-symbols] [--absolute-percpu] "
+	fprintf(stderr, "Usage: kallsyms --extra-symbols=<kallsyms-file> [--all-symbols] [--absolute-percpu] "
			"[--base-relative] [--lto-clang] in.map > out.S\n");
	exit(1);
 }
@@ -121,6 +128,55 @@ static void check_symbol_range(const char *sym, unsigned long long addr,
	}
 }

+// Read extra-kallsyms and populate extra-kallsyms table
+static void populate_extra_symbol_table(char *file_name)
+{
+	size_t i = 0;
+	FILE *f = NULL;
+	char sym_name[KSYM_NAME_LEN];
+
+	if (!file_name) {
+		fprintf(stderr, "File name is NULL\n");
+		exit(1);
+	}
+
+	f = fopen(file_name, "r");
+	if (f == NULL) {
+		fprintf(stderr, "Unable to open %s\n", file_name);
+		exit(1);
+	}
+
+	while (fscanf(f, "%s", sym_name) == 1) {
+		extra_sym_tbl_size++;
+	}
+	if (extra_sym_tbl_size == 0) {
+		fprintf(stderr, "Symbol file format error: %d %s\n",
+			errno, strerror(errno));
+		goto ret;
+	}
+	extra_sym_tbl = (char **)malloc(extra_sym_tbl_size * sizeof(char*));
+	fseek(f, 0, SEEK_SET);
+	while (fscanf(f, "%s", sym_name) == 1) {
+		extra_sym_tbl[i++] = strdup(sym_name);
+	}
+	if (!feof(f)) {
+		fprintf(stderr, "Symbol file %s format error: %d %s\n",
+			file_name, errno, strerror(errno));
+		goto ret;
+	}
+ret:
+	fclose(f);
+}
+
+static void free_extra_symbol_table(void)
+{
+	size_t i = 0;
+
+	for (i = 0; i < extra_sym_tbl_size; i++)
+		free(extra_sym_tbl[i]);
+	free(extra_sym_tbl);
+}
+
 static struct sym_entry *read_symbol(FILE *in, char **buf, size_t *buf_len)
 {
	char *name, type, *p;
@@ -207,10 +263,17 @@ static int symbol_in_range(const struct sym_entry *s,
 static int symbol_valid(const struct sym_entry *s)
 {
	const char *name = sym_name(s);
+	unsigned int i = 0;

	/* if --all-symbols is not specified, then symbols outside the text
	 * and inittext sections are discarded */
	if (!all_symbols) {
+		if (extra_symbols) {
+			for (i = 0; i < extra_sym_tbl_size; i++) {
+				if (strcmp(name, extra_sym_tbl[i]) == 0)
+					return 1;
+			}
+		}
		if (symbol_in_range(s, text_ranges,
				    ARRAY_SIZE(text_ranges)) == 0)
			return 0;
@@ -809,26 +872,48 @@ static void record_relative_base(void)

 int main(int argc, char **argv)
 {
-	while (1) {
-		static const struct option long_options[] = {
-			{"all-symbols",     no_argument, &all_symbols,     1},
-			{"absolute-percpu", no_argument, &absolute_percpu, 1},
-			{"base-relative",   no_argument, &base_relative,   1},
-			{"lto-clang",       no_argument, &lto_clang,       1},
-			{},
-		};
-
-		int c = getopt_long(argc, argv, "", long_options, NULL);
-
-		if (c == -1)
+	char *sym_file = NULL;
+	int opt = 0, index = 0;
+
+	static struct option long_options[] = {
+		{"all-symbols",     no_argument,       NULL, 'l'},
+		{"absolute-percpu", no_argument,       NULL, 'a'},
+		{"base-relative",   no_argument,       NULL, 'b'},
+		{"lto-clang",       no_argument,       NULL, 'c'},
+		{"extra-symbols",   required_argument, NULL, 's'},
+		{},
+	};
+
+	while ((opt = getopt_long_only(argc, argv, "",
+			long_options, &index)) != -1) {
+		switch (opt) {
+		case 'l':
+			all_symbols = 1;
+			break;
+		case 'a':
+			absolute_percpu = 1;
+			break;
+		case 'b':
+			base_relative = 1;
			break;
-		if (c != 0)
+		case 'c':
+			lto_clang = 1;
+			break;
+		case 's':
+			extra_symbols = 1;
+			sym_file = optarg;
+			break;
+		default:
			usage();
+		}
	}

	if (optind >= argc)
		usage();

+	if (extra_symbols) {
+		populate_extra_symbol_table(sym_file);
+	}
	read_map(argv[optind]);
	shrink_table();
	if (absolute_percpu)
@@ -839,5 +924,6 @@ int main(int argc, char **argv)
	optimize_token_table();
	write_src();

+	free_extra_symbol_table();
	return 0;
 }
diff --git a/scripts/link-vmlinux.sh b/scripts/link-vmlinux.sh
index a432b171b..edbb10ef0 100755
--- a/scripts/link-vmlinux.sh
+++ b/scripts/link-vmlinux.sh
@@ -160,6 +160,8 @@ kallsyms()
		kallsymopt="${kallsymopt} --lto-clang"
	fi

+	kallsymopt="${kallsymopt} --extra-symbols=crypto/fips_canister-kallsyms"
+
	info KSYMS ${2}
	scripts/kallsyms ${kallsymopt} ${1} > ${2}
 }
--
2.41.0
