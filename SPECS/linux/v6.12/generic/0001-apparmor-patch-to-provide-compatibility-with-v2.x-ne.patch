From 9dc38b5ce96a062a855bda4d399d4c24b05d7a18 Mon Sep 17 00:00:00 2001
From: John Johansen <john.johansen@canonical.com>
Date: Thu, 10 Oct 2024 09:43:58 +0000
Subject: [PATCH] apparmor: patch to provide compatibility with v2.x net rules

The networking rules upstreamed in 4.17 have a deliberate abi break
with the older 2.x network rules.

This patch provides compatibility with the older rules for those
still using an apparmor 2.x userspace and still want network rules
to work on a newer kernel.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Signed-off-by: Bo Gan <ganb@vmware.com>
Signed-off-by: Srivatsa S. Bhat (VMware) <srivatsa@csail.mit.edu>

[Srinidhi Rao<srinidhi.rao@broadcom.com> Back Ported this patch to v6.6.x]
Signed-off-by: srinidhira0 <srinidhi.rao@broadcom.com>
---
 security/apparmor/apparmorfs.c            |  1 +
 security/apparmor/include/apparmor.h      |  2 +-
 security/apparmor/include/net.h           | 11 +++++
 security/apparmor/include/policy.h        |  2 +
 security/apparmor/include/policy_compat.h |  2 +-
 security/apparmor/net.c                   | 30 +++++++++---
 security/apparmor/policy.c                |  1 +
 security/apparmor/policy_unpack.c         | 56 ++++++++++++++++++++++-
 8 files changed, 96 insertions(+), 9 deletions(-)

diff --git a/security/apparmor/apparmorfs.c b/security/apparmor/apparmorfs.c
index 01b923d97a44..28b9d59780b2 100644
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -2405,6 +2405,7 @@ static struct aa_sfs_entry aa_sfs_entry_features[] = {
 	AA_SFS_DIR("domain",			aa_sfs_entry_domain),
 	AA_SFS_DIR("file",			aa_sfs_entry_file),
 	AA_SFS_DIR("network_v8",		aa_sfs_entry_network),
+	AA_SFS_DIR("network",			aa_sfs_entry_network_compat),
 	AA_SFS_DIR("mount",			aa_sfs_entry_mount),
 	AA_SFS_DIR("namespaces",		aa_sfs_entry_ns),
 	AA_SFS_FILE_U64("capability",		VFS_CAP_FLAGS_MASK),
diff --git a/security/apparmor/include/apparmor.h b/security/apparmor/include/apparmor.h
index f83934913b0f..7e341cffbc73 100644
--- a/security/apparmor/include/apparmor.h
+++ b/security/apparmor/include/apparmor.h
@@ -20,7 +20,7 @@
 #define AA_CLASS_UNKNOWN	1
 #define AA_CLASS_FILE		2
 #define AA_CLASS_CAP		3
-#define AA_CLASS_DEPRECATED	4
+#define AA_CLASS_NET_COMPAT	4
 #define AA_CLASS_RLIMITS	5
 #define AA_CLASS_DOMAIN		6
 #define AA_CLASS_MOUNT		7
diff --git a/security/apparmor/include/net.h b/security/apparmor/include/net.h
index 67bf888c3bd6..d6e1fce67266 100644
--- a/security/apparmor/include/net.h
+++ b/security/apparmor/include/net.h
@@ -73,6 +73,16 @@ static inline struct aa_sk_ctx *aa_sock(const struct sock *sk)
 	DEFINE_AUDIT_NET(NAME, OP, SK, (SK)->sk_family, (SK)->sk_type,	\
 			 (SK)->sk_protocol)
 
+/* struct aa_net - network confinement data
+ * @allow: basic network families permissions
+ * @audit: which network permissions to force audit
+ * @quiet: which network permissions to quiet rejects
+ */
+struct aa_net_compat {
+	u16 allow[AF_MAX];
+	u16 audit[AF_MAX];
+	u16 quiet[AF_MAX];
+};
 
 #define af_select(FAMILY, FN, DEF_FN)		\
 ({						\
@@ -92,6 +102,7 @@ struct aa_secmark {
 };
 
 extern struct aa_sfs_entry aa_sfs_entry_network[];
+extern struct aa_sfs_entry aa_sfs_entry_network_compat[];
 
 void audit_net_cb(struct audit_buffer *ab, void *va);
 int aa_profile_af_perm(struct aa_profile *profile,
diff --git a/security/apparmor/include/policy.h b/security/apparmor/include/policy.h
index 75088cc310b6..188b21b753a2 100644
--- a/security/apparmor/include/policy.h
+++ b/security/apparmor/include/policy.h
@@ -155,6 +155,7 @@ struct aa_data {
  * @policy: general match rules governing policy
  * @file: The set of rules governing basic file access and domain transitions
  * @caps: capabilities for the profile
+ * @net_compat: v2 compat network controls for the profile
  * @rlimits: rlimits for the profile
  * @secmark_count: number of secmark entries
  * @secmark: secmark label match info
@@ -168,6 +169,7 @@ struct aa_ruleset {
 	struct aa_policydb *policy;
 	struct aa_policydb *file;
 	struct aa_caps caps;
+	struct aa_net_compat *net_compat;
 
 	struct aa_rlimit rlimits;
 
diff --git a/security/apparmor/include/policy_compat.h b/security/apparmor/include/policy_compat.h
index af0e174332df..3bcb10e69271 100644
--- a/security/apparmor/include/policy_compat.h
+++ b/security/apparmor/include/policy_compat.h
@@ -22,7 +22,7 @@
 
 #define v5	5	/* base version */
 #define v6	6	/* per entry policydb mediation check */
-#define v7	7
+#define v7	7       /* v2 compat networking */
 #define v8	8	/* full network masking */
 #define v9	9	/* xbits are used as permission bits in policydb */
 
diff --git a/security/apparmor/net.c b/security/apparmor/net.c
index 87e934b2b548..99679eea3a2c 100644
--- a/security/apparmor/net.c
+++ b/security/apparmor/net.c
@@ -24,6 +24,11 @@ struct aa_sfs_entry aa_sfs_entry_network[] = {
 	{ }
 };
 
+struct aa_sfs_entry aa_sfs_entry_network_compat[] = {
+	AA_SFS_FILE_STRING("af_mask",	AA_SFS_AF_MASK),
+	{ }
+};
+
 static const char * const net_mask_names[] = {
 	"unknown",
 	"send",
@@ -122,14 +127,27 @@ int aa_profile_af_perm(struct aa_profile *profile,
 	if (profile_unconfined(profile))
 		return 0;
 	state = RULE_MEDIATES(rules, AA_CLASS_NET);
-	if (!state)
+	if (state) {
+		if (!state)
+			return 0;
+		buffer[0] = cpu_to_be16(family);
+		buffer[1] = cpu_to_be16((u16) type);
+		state = aa_dfa_match_len(rules->policy->dfa, state,
+						(char *) &buffer, 4);
+		perms = *aa_lookup_perms(rules->policy, state);
+		aa_apply_modes_to_perms(profile, &perms);
+	} else if (rules->net_compat) {
+		/* 2.x socket mediation compat */
+		perms.allow = (rules->net_compat->allow[family] & (1 << type)) ?
+			ALL_PERMS_MASK : 0;
+		perms.audit = (rules->net_compat->audit[family] & (1 << type)) ?
+			ALL_PERMS_MASK : 0;
+		perms.quiet = (rules->net_compat->quiet[family] & (1 << type)) ?
+			ALL_PERMS_MASK : 0;
+	} else {
 		return 0;
+	}
 
-	buffer[0] = cpu_to_be16(family);
-	buffer[1] = cpu_to_be16((u16) type);
-	state = aa_dfa_match_len(rules->policy->dfa, state, (char *) &buffer,
-				 4);
-	perms = *aa_lookup_perms(rules->policy, state);
 	aa_apply_modes_to_perms(profile, &perms);
 
 	return aa_check_perms(profile, &perms, request, ad, audit_net_cb);
diff --git a/security/apparmor/policy.c b/security/apparmor/policy.c
index 14df15e35695..f6367e825528 100644
--- a/security/apparmor/policy.c
+++ b/security/apparmor/policy.c
@@ -252,6 +252,7 @@ static void free_ruleset(struct aa_ruleset *rules)
 	for (i = 0; i < rules->secmark_count; i++)
 		kfree_sensitive(rules->secmark[i].label);
 	kfree_sensitive(rules->secmark);
+	kfree_sensitive(rules->net_compat);
 	kfree_sensitive(rules);
 }
 
diff --git a/security/apparmor/policy_unpack.c b/security/apparmor/policy_unpack.c
index 5a570235427d..3ba33e98448f 100644
--- a/security/apparmor/policy_unpack.c
+++ b/security/apparmor/policy_unpack.c
@@ -270,6 +270,23 @@ static bool unpack_u8(struct aa_ext *e, u8 *data, const char *name)
 	return false;
 }
 
+static bool unpack_u16(struct aa_ext *e, u16 *data, const char *name)
+{
+	void *pos = e->pos;
+
+	if (aa_unpack_nameX(e, AA_U16, name)) {
+		if (!aa_inbounds(e, sizeof(u16)))
+			goto fail;
+		if (data)
+			*data = le16_to_cpu(get_unaligned((__le16 *) e->pos));
+		e->pos += sizeof(u16);
+		return true;
+	}
+fail:
+	e->pos = pos;
+	return false;
+}
+
 VISIBLE_IF_KUNIT bool aa_unpack_u32(struct aa_ext *e, u32 *data, const char *name)
 {
 	void *pos = e->pos;
@@ -824,9 +841,10 @@ static struct aa_profile *unpack_profile(struct aa_ext *e, char **ns_name)
 	struct rhashtable_params params = { 0 };
 	char *key = NULL, *disconnected = NULL;
 	struct aa_data *data;
-	int error = -EPROTO;
+	int error = -EPROTO, i = 0;
 	kernel_cap_t tmpcap;
 	u32 tmp;
+	u16 size = 0;
 
 	*ns_name = NULL;
 
@@ -992,6 +1010,42 @@ static struct aa_profile *unpack_profile(struct aa_ext *e, char **ns_name)
 		goto fail;
 	}
 
+	aa_unpack_array(e, "net_allowed_af", &size);
+	if (size || VERSION_LT(e->version, v8)) {
+		rules->net_compat = kzalloc(sizeof(struct aa_net_compat), GFP_KERNEL);
+		if (!rules->net_compat) {
+			info = "out of memory";
+			goto fail;
+		}
+		for (i = 0; i < size; i++) {
+			/* discard extraneous rules that this kernel will
+			 * never request
+			 */
+			if (i >= AF_MAX) {
+				u16 tmp;
+
+				if (!unpack_u16(e, &tmp, NULL) ||
+					!unpack_u16(e, &tmp, NULL) ||
+					!unpack_u16(e, &tmp, NULL))
+						goto fail;
+				continue;
+			}
+			if (!unpack_u16(e, &rules->net_compat->allow[i], NULL))
+				goto fail;
+			if (!unpack_u16(e, &rules->net_compat->audit[i], NULL))
+				goto fail;
+			if (!unpack_u16(e, &rules->net_compat->quiet[i], NULL))
+				goto fail;
+		}
+		if (size && !aa_unpack_nameX(e, AA_ARRAYEND, NULL))
+			goto fail;
+		if (VERSION_LT(e->version, v7)) {
+			/* pre v7 policy always allowed these */
+			rules->net_compat->allow[AF_UNIX] = 0xffff;
+			rules->net_compat->allow[AF_NETLINK] = 0xffff;
+		}
+	}
+
 	if (aa_unpack_nameX(e, AA_STRUCT, "policydb")) {
 		/* generic policy dfa - optional and may be NULL */
 		info = "failed to unpack policydb";
-- 
2.39.4

