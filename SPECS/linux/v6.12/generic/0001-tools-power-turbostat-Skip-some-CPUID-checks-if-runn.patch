From 3f7d953c5851efb29d494bb9b13382573363750e Mon Sep 17 00:00:00 2001
From: "Srivatsa S. Bhat (VMware)" <srivatsa@csail.mit.edu>
Date: Tue, 21 Feb 2023 13:38:44 -0800
Subject: [PATCH] tools/power turbostat: Skip some CPUID checks if running on
 VMware hypervisor

Turbostat hasn't really worked full-fledged within Linux guests on
ESXi, since some of the MSRs that it needs in order to gather data
have traditionally not been exposed to VMs by ESXi.

This is going to change in newer versions of ESXi, where these MSRs
will be accessible from guests for read operations. In preparation to
get turbostat working in the guest with these underlying changes, skip
some CPUID checks while accessing certain MSRs when running on VMware
hypervisor.

Skip CPUID checks for APERF/MPERF, CoreTmp and PkgTmp if running on
VMware hypervisor and query those MSRs directly.

(Note that some of the data reported by turbostat will only be
valid/reliable if the guest has its vCPUs exclusively pinned to pCPUs,
because the data actually pertains to the underlying physical CPU,
such as the CPU frequency, thermal and power statistics.)

Based-on-patch-by: Jim White <jameswhite@vmware.com>
Signed-off-by: Srivatsa S. Bhat (VMware) <srivatsa@csail.mit.edu>
---
 tools/power/x86/turbostat/turbostat.c | 38 ++++++++++++++++++++++++++-
 1 file changed, 37 insertions(+), 1 deletion(-)

diff --git a/tools/power/x86/turbostat/turbostat.c b/tools/power/x86/turbostat/turbostat.c
index 089220aaa5c9..ec3ed1b7df63 100644
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@ -7943,6 +7943,8 @@ void process_cpuid()
 	unsigned int fms, family, model, stepping, ecx_flags, edx_flags;
 	unsigned long long ucode_patch = 0;
 	bool ucode_patch_valid = false;
+	unsigned int hyper_vendor_id[3];
+	int retry_count;
 
 	eax = ebx = ecx = edx = 0;
 
@@ -7982,6 +7984,7 @@ void process_cpuid()
 	 * This is needed to check for invariant TSC.
 	 * This check is valid for both Intel and AMD.
 	 */
+
 	ebx = ecx = edx = 0;
 	__cpuid(0x80000000, max_extended_level, ebx, ecx, edx);
 
@@ -8025,13 +8028,46 @@ void process_cpuid()
 	 * this check is valid for both Intel and AMD
 	 */
 
+	/*
+	 * Skip CPUID checks for APERF/MPERF, CoreTmp and PkgTmp if running
+	 * on VMware hypervisor and query those MSRs directly.
+	 */
+	__cpuid(0x40000000, eax, hyper_vendor_id[0], hyper_vendor_id[1],
+		hyper_vendor_id[2]);
+
+	if (!memcmp(hyper_vendor_id, "VMwareVMware", 12)) {
+		/*
+		 * Verify that reading APERF/MPERF returns non-zero
+		 * values before marking them as available, to make
+		 * sure that the hypervisor does indeed support them.
+		 */
+		for (retry_count = 0; retry_count < 3; retry_count++) {
+			unsigned long long msr_aperf, msr_mperf;
+
+			get_msr(base_cpu, MSR_IA32_APERF, &msr_aperf);
+			get_msr(base_cpu, MSR_IA32_MPERF, &msr_mperf);
+			if (msr_aperf != 0 && msr_mperf != 0)
+				break;
+		}
+
+		if (retry_count < 3)
+			has_aperf = do_dts = do_ptm = 1;
+	}
+
 	__cpuid(0x6, eax, ebx, ecx, edx);
-	has_aperf = ecx & (1 << 0);
+
+	if (!has_aperf)
+		has_aperf = ecx & (1 << 0);
 	do_dts = eax & (1 << 0);
+
+	if (!do_dts)
+		do_dts = eax & (1 << 0);
 	if (do_dts)
 		BIC_PRESENT(BIC_CoreTmp);
 	has_turbo = eax & (1 << 1);
 	do_ptm = eax & (1 << 6);
+	if (!do_ptm)
+		do_ptm = eax & (1 << 6);
 	if (do_ptm)
 		BIC_PRESENT(BIC_PkgTmp);
 	has_hwp = eax & (1 << 7);
-- 
2.39.4

