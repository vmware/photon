From 2e3fe0b7a770ebf2bad685fd41e66eee03b56a0c Mon Sep 17 00:00:00 2001
From: Shivani Agarwal <shivani.agarwal@broadcom.com>
Date: Mon, 20 Jan 2025 08:14:33 +0000
Subject: [PATCH] crypto api return status prints for LKCM6 demo

---
 crypto/aead.c      | 41 ++++++++++++++++++++++++++++++++++++-----
 crypto/ahash.c     | 10 +++++++++-
 crypto/akcipher.c  | 10 ++++++++--
 crypto/algif_ecc.c | 39 +++++++++++++++++++++++++++++++++++----
 crypto/cipher.c    |  7 ++++++-
 crypto/kpp.c       | 10 ++++++++--
 crypto/rng.c       |  6 ++++++
 crypto/shash.c     | 27 ++++++++++++++++++++++++---
 crypto/skcipher.c  | 37 +++++++++++++++++++++++++++++++++----
 9 files changed, 165 insertions(+), 22 deletions(-)

diff --git a/crypto/aead.c b/crypto/aead.c
index cade53241..656e1c0cc 100644
--- a/crypto/aead.c
+++ b/crypto/aead.c
@@ -51,6 +51,11 @@ int crypto_aead_setkey(struct crypto_aead *tfm,
 	else
 		err = crypto_aead_alg(tfm)->setkey(tfm, key, keylen);
 
+	if(err < 0)
+		printk(KERN_ERR "%ps FAILED, returned %d", crypto_aead_alg(tfm)->setkey, err);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", crypto_aead_alg(tfm)->setkey, err);
+
 	if (unlikely(err)) {
 		crypto_aead_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
 		return err;
@@ -71,9 +76,12 @@ int crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
 
 	if (crypto_aead_alg(tfm)->setauthsize) {
 		err = crypto_aead_alg(tfm)->setauthsize(tfm, authsize);
-		if (err)
+		if (err) {
+			printk(KERN_ERR "%ps FAILED, returned %d", crypto_aead_alg(tfm)->setauthsize, err);
 			return err;
+		}
 	}
+	printk(KERN_INFO "%ps PASSED, returned %d", crypto_aead_alg(tfm)->setauthsize, err);
 
 	tfm->authsize = authsize;
 	return 0;
@@ -83,17 +91,26 @@ EXPORT_SYMBOL_GPL(crypto_aead_setauthsize);
 int crypto_aead_encrypt(struct aead_request *req)
 {
 	struct crypto_aead *aead = crypto_aead_reqtfm(req);
+	int ret;
 
 	if (crypto_aead_get_flags(aead) & CRYPTO_TFM_NEED_KEY)
 		return -ENOKEY;
 
-	return crypto_aead_alg(aead)->encrypt(req);
+	ret = crypto_aead_alg(aead)->encrypt(req);
+
+	if(ret < 0)
+		printk(KERN_ERR "%ps FAILED, returned %d", crypto_aead_alg(aead)->encrypt, ret);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", crypto_aead_alg(aead)->encrypt, ret);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_aead_encrypt);
 
 int crypto_aead_decrypt(struct aead_request *req)
 {
 	struct crypto_aead *aead = crypto_aead_reqtfm(req);
+	int ret;
 
 	if (crypto_aead_get_flags(aead) & CRYPTO_TFM_NEED_KEY)
 		return -ENOKEY;
@@ -101,7 +118,14 @@ int crypto_aead_decrypt(struct aead_request *req)
 	if (req->cryptlen < crypto_aead_authsize(aead))
 		return -EINVAL;
 
-	return crypto_aead_alg(aead)->decrypt(req);
+	ret = crypto_aead_alg(aead)->decrypt(req);
+
+	if(ret < 0)
+		printk(KERN_ERR "%ps FAILED, returned %d", crypto_aead_alg(aead)->decrypt, ret);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", crypto_aead_alg(aead)->decrypt, ret);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_aead_decrypt);
 
@@ -125,8 +149,15 @@ static int crypto_aead_init_tfm(struct crypto_tfm *tfm)
 	if (alg->exit)
 		aead->base.exit = crypto_aead_exit_tfm;
 
-	if (alg->init)
-		return alg->init(aead);
+	int err;
+	if (alg->init) {
+		err = alg->init(aead);
+		if(err)
+			printk(KERN_ERR "%ps FAILED, returned %d", alg->init, err);
+		else
+			printk(KERN_INFO "%ps PASSED, returned %d", alg->init, err);
+		return err;
+	}
 
 	return 0;
 }
diff --git a/crypto/ahash.c b/crypto/ahash.c
index bcd9de009..1dbf75c4c 100644
--- a/crypto/ahash.c
+++ b/crypto/ahash.c
@@ -328,11 +328,19 @@ static void ahash_restore_req(struct ahash_request *req, int err)
 int crypto_ahash_update(struct ahash_request *req)
 {
 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	int ret;
 
 	if (likely(tfm->using_shash))
 		return shash_ahash_update(req, ahash_request_ctx(req));
 
-	return crypto_ahash_alg(tfm)->update(req);
+	ret = crypto_ahash_alg(tfm)->update(req);
+
+	if(ret)
+		printk(KERN_ERR "%ps FAILED, returned %d", crypto_ahash_alg(tfm)->update, ret);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", crypto_ahash_alg(tfm)->update, ret);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_ahash_update);
 
diff --git a/crypto/akcipher.c b/crypto/akcipher.c
index e0ff5f4dd..83db94cbd 100644
--- a/crypto/akcipher.c
+++ b/crypto/akcipher.c
@@ -57,8 +57,14 @@ static int crypto_akcipher_init_tfm(struct crypto_tfm *tfm)
 	if (alg->exit)
 		akcipher->base.exit = crypto_akcipher_exit_tfm;
 
-	if (alg->init)
-		return alg->init(akcipher);
+        if (alg->init) {
+                int err = alg->init(akcipher);
+                if(err)
+                        printk(KERN_ERR "%ps FAILED, returned %d", alg->init, err);
+                else
+                        printk(KERN_INFO "%ps PASSED, returned %d", alg->init, err);
+                return err;
+        }
 
 	return 0;
 }
diff --git a/crypto/algif_ecc.c b/crypto/algif_ecc.c
index b88831187..cb3b10bfa 100644
--- a/crypto/algif_ecc.c
+++ b/crypto/algif_ecc.c
@@ -112,6 +112,10 @@ static int ecc_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 		ecc_swap_digits((u64 *)y_buf, pk.y, pk.ndigits);
 
 		ret = ecc_is_pubkey_valid_full(curve, &pk);
+		if(!ret)
+			printk(KERN_INFO "ecc_is_pubkey_valid_full PASSED, returned %d", ret);
+		else
+			printk(KERN_ERR "ecc_is_pubkey_valid_full FAILED, returned %d", ret);
 
 
 		kfree(pk.x);
@@ -161,8 +165,27 @@ static int ecc_recvmsg(struct socket *sock, struct msghdr *msg,
 	} else if(iov[3].iov_len == 521) {
 		curve = &nist_p521;
 		curve_id = 4;
-	} else
-		return -EINVAL;
+	} else {
+		int skip_gen_privkey = 0;
+		switch(iov[3].iov_len) {
+			case 1:  break;
+			case 2:  skip_gen_privkey = 1;
+				 break;
+			default: return -EINVAL;
+		}
+
+		if(!skip_gen_privkey) {
+			ret = ecc_gen_privkey(2, 0, (u64 *)d_buf);
+			if (ret < 0)
+				printk(KERN_ERR "ecc_gen_privkey FAILED, returned %d", ret);
+			return ret;
+		}
+
+		ret = ecc_make_pub_key(2, 0, (u64 *)d_buf, pubkey);
+		if (ret < 0)
+			printk(KERN_ERR "ecc_make_pub_key FAILED, returned %d", ret);
+		return ret;
+	}
 
         if (iov[0].iov_len != curve->g.ndigits * sizeof(u64) ||
             iov[1].iov_len != curve->g.ndigits * sizeof(u64) ||
@@ -170,12 +193,20 @@ static int ecc_recvmsg(struct socket *sock, struct msghdr *msg,
                 return -EINVAL;
 
         ret = ecc_gen_privkey(curve_id, curve->g.ndigits, (u64 *)d_buf);
-        if (ret < 0)
+        if (ret < 0) {
+		printk(KERN_ERR "ecc_gen_privkey FAILED, returned %d", ret);
                 return ret;
+	}
+	else
+		printk(KERN_INFO "ecc_gen_privkey PASSED, returned %d", ret);
 
         ret = ecc_make_pub_key(curve_id, curve->g.ndigits, (u64 *)d_buf, pubkey);
-        if (ret < 0)
+        if (ret < 0) {
+		printk(KERN_ERR "ecc_make_pub_key FAILED, returned %d", ret);
                 return ret;
+	}
+	else
+		printk(KERN_INFO "ecc_make_pub_key PASSED, returned %d", ret);
 
         ret = copy_to_user(iov[0].iov_base, d_buf, iov[0].iov_len);
         if (ret) {
diff --git a/crypto/cipher.c b/crypto/cipher.c
index 40cae9087..52da91e65 100644
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -51,7 +51,12 @@ int crypto_cipher_setkey(struct crypto_cipher *tfm,
 	if ((unsigned long)key & alignmask)
 		return setkey_unaligned(tfm, key, keylen);
 
-	return cia->cia_setkey(crypto_cipher_tfm(tfm), key, keylen);
+	int err = cia->cia_setkey(crypto_cipher_tfm(tfm), key, keylen);
+	if(err)
+		printk(KERN_ERR "%ps FAILED, returned %d", cia->cia_setkey, err);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", cia->cia_setkey, err);
+	return err;
 }
 EXPORT_SYMBOL_NS_GPL(crypto_cipher_setkey, CRYPTO_INTERNAL);
 
diff --git a/crypto/kpp.c b/crypto/kpp.c
index ecc63a1a9..90dd05ef8 100644
--- a/crypto/kpp.c
+++ b/crypto/kpp.c
@@ -53,8 +53,14 @@ static int crypto_kpp_init_tfm(struct crypto_tfm *tfm)
 	if (alg->exit)
 		kpp->base.exit = crypto_kpp_exit_tfm;
 
-	if (alg->init)
-		return alg->init(kpp);
+	if (alg->init) {
+		int err = alg->init(kpp);
+		if(err)
+			printk(KERN_ERR "%ps FAILED, returned %d", alg->init, err);
+		else
+			printk(KERN_INFO "%ps PASSED, returned %d", alg->init, err);
+		return err;
+	}
 
 	return 0;
 }
diff --git a/crypto/rng.c b/crypto/rng.c
index 9e327c8c0..377a9fbe9 100644
--- a/crypto/rng.c
+++ b/crypto/rng.c
@@ -69,6 +69,12 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 	}
 
 	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
+
+	if(err)
+		printk(KERN_ERR "%ps FAILED, returned %d", crypto_rng_alg(tfm)->seed, err);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", crypto_rng_alg(tfm)->seed, err);
+
 out:
 	kfree_sensitive(buf);
 	return err;
diff --git a/crypto/shash.c b/crypto/shash.c
index 301ab42bf..a70217cd9 100644
--- a/crypto/shash.c
+++ b/crypto/shash.c
@@ -36,6 +36,12 @@ int crypto_shash_setkey(struct crypto_shash *tfm, const u8 *key,
 	int err;
 
 	err = shash->setkey(tfm, key, keylen);
+
+	if(err)
+		printk(KERN_ERR "%ps FAILED, returned %d", shash->setkey, err);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", shash->setkey, err);
+
 	if (unlikely(err)) {
 		shash_set_needkey(tfm, shash);
 		return err;
@@ -49,13 +55,25 @@ EXPORT_SYMBOL_GPL(crypto_shash_setkey);
 int crypto_shash_update(struct shash_desc *desc, const u8 *data,
 			unsigned int len)
 {
-	return crypto_shash_alg(desc->tfm)->update(desc, data, len);
+	int err = crypto_shash_alg(desc->tfm)->update(desc, data, len);
+	if(err)
+		printk(KERN_ERR "%ps FAILED, returned %d", crypto_shash_alg(desc->tfm)->update, err);
+	else
+		if(strcmp(crypto_shash_alg(desc->tfm)->base.cra_name, "crc32c")) {
+			printk(KERN_INFO "%ps PASSED, returned %d", crypto_shash_alg(desc->tfm)->update, err);
+		}
+	return err;
 }
 EXPORT_SYMBOL_GPL(crypto_shash_update);
 
 int crypto_shash_final(struct shash_desc *desc, u8 *out)
 {
-	return crypto_shash_alg(desc->tfm)->final(desc, out);
+	int err = crypto_shash_alg(desc->tfm)->final(desc, out);
+	if(err)
+		printk(KERN_ERR "%ps FAILED, returned %d", crypto_shash_alg(desc->tfm)->final, err);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", crypto_shash_alg(desc->tfm)->final, err);
+	return err;
 }
 EXPORT_SYMBOL_GPL(crypto_shash_final);
 
@@ -166,8 +184,10 @@ static int crypto_shash_init_tfm(struct crypto_tfm *tfm)
 		return 0;
 
 	err = alg->init_tfm(hash);
-	if (err)
+	if (err) {
+		printk(KERN_ERR "%ps FAILED, returned %d", alg->init_tfm, err);
 		return err;
+	}
 
 	/* ->init_tfm() may have increased the descsize. */
 	if (WARN_ON_ONCE(hash->descsize > HASH_MAX_DESCSIZE)) {
@@ -175,6 +195,7 @@ static int crypto_shash_init_tfm(struct crypto_tfm *tfm)
 			alg->exit_tfm(hash);
 		return -EINVAL;
 	}
+	printk(KERN_INFO "%ps PASSED, returned %d", alg->init_tfm, err);
 
 	return 0;
 }
diff --git a/crypto/skcipher.c b/crypto/skcipher.c
index ceed7f33a..b23b80399 100644
--- a/crypto/skcipher.c
+++ b/crypto/skcipher.c
@@ -620,6 +620,11 @@ int crypto_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
 	else
 		err = cipher->setkey(tfm, key, keylen);
 
+	if(err)
+		printk(KERN_ERR "%ps FAILED, returned %d", cipher->setkey, err);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", cipher->setkey, err);
+
 out:
 	if (unlikely(err)) {
 		skcipher_set_needkey(tfm);
@@ -635,12 +640,22 @@ int crypto_skcipher_encrypt(struct skcipher_request *req)
 {
 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
 	struct skcipher_alg *alg = crypto_skcipher_alg(tfm);
+	int ret;
 
 	if (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
 		return -ENOKEY;
 	if (alg->co.base.cra_type != &crypto_skcipher_type)
 		return crypto_lskcipher_encrypt_sg(req);
-	return alg->encrypt(req);
+	ret = alg->encrypt(req);
+
+	if(!strstr(alg->base.cra_driver_name, "ecb-cipher_null")) {
+		if(ret)
+			printk(KERN_ERR "%ps FAILED, returned %d", alg->encrypt, ret);
+		else
+			printk(KERN_INFO "%ps PASSED, returned %d", alg->encrypt, ret);
+	}
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_skcipher_encrypt);
 
@@ -648,12 +663,20 @@ int crypto_skcipher_decrypt(struct skcipher_request *req)
 {
 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
 	struct skcipher_alg *alg = crypto_skcipher_alg(tfm);
+	int ret;
 
 	if (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
 		return -ENOKEY;
 	if (alg->co.base.cra_type != &crypto_skcipher_type)
 		return crypto_lskcipher_decrypt_sg(req);
-	return alg->decrypt(req);
+	ret = alg->decrypt(req);
+
+	if(ret)
+		printk(KERN_ERR "%ps FAILED, returned %d", alg->decrypt, ret);
+	else
+		printk(KERN_INFO "%ps PASSED, returned %d", alg->decrypt, ret);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_skcipher_decrypt);
 
@@ -745,8 +768,14 @@ static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
 	if (alg->exit)
 		skcipher->base.exit = crypto_skcipher_exit_tfm;
 
-	if (alg->init)
-		return alg->init(skcipher);
+        if(alg->init) {
+                int err = alg->init(skcipher);
+                if(err)
+                        printk(KERN_ERR "%ps FAILED, returned %d", alg->init, err);
+                else
+                        printk(KERN_INFO "%ps PASSED, returned %d", alg->init, err);
+                return err;
+	}
 
 	return 0;
 }
-- 
2.39.4

