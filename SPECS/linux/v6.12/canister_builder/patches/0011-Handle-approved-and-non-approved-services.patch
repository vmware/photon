From f893c6e6dbc22250c3879957588f8d01b761ee9d Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
Date: Wed, 11 Dec 2024 06:28:45 +0000
Subject: [PATCH 11/11] Handle approved and non-approved services

- Add log indicator prints in algorithm initialization path
- Add XTS error log when XTS duplicate test fails
- Remove fips_allowed flag for the following non-approved algorithms
        cbcmac(aes) outside of ccm context
        ghash-generic outside of gcm context
        rfc4309(ccm(aes))
        rfc3686(ctr(aes)))
- Add log message in pksc1pad_encrypt and pkcs1pad_decrypt functions as non-approved
  services.
- Add logic in gcm/rfc4106 encrypt functions to maintain whitelist of known
  callers of gcm-aes/rfc4106-gcm-aes and log message if any other
  callers are using gcm-aes/rfc4106-gcm-aes with External IV

/* |----------------------------------------------------------------------|
 * |                                |   Encrypt         |       Decrypt   |
 * |                                |                   |                 |
 * ---------------------------------|-------------------|-----------------|
 * |                                |                   |                 |
 * |gcm(aes) - internal IV          |     NA            |       NA        |
 * ---------------------------------|-------------------|-----------------|
 * |                                |                   |                 |
 * |gcm(aes) - external IV          |    non-approved   |    approved     |
 * ---------------------------------|-------------------|-----------------|
 * |                                |                   |                 |
 * |rfc4106(gcm(aes)) - internal IV |    approved       |    approved     |
 * ---------------------------------|-------------------|-----------------|
 * |                                |                   |                 |
 * |rfc4106(gcm(aes)) - external IV |   non-approved    |    approved     |
 * |----------------------------------------------------------------------|
 */

Signed-off-by: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
---
 arch/x86/crypto/aesni-intel_glue.c | 125 ++++++++++++++++++++++++++++-
 crypto/aes_generic.c               |  11 ++-
 crypto/cbc.c                       |   4 +
 crypto/ccm.c                       |  10 +++
 crypto/cmac.c                      |   4 +
 crypto/ctr.c                       |   7 ++
 crypto/cts.c                       |   4 +
 crypto/drbg.c                      |  10 ++-
 crypto/ecb.c                       |   8 +-
 crypto/ecc.c                       |   1 +
 crypto/ecdh.c                      |  11 +++
 crypto/ecdsa.c                     |  16 ++++
 crypto/gcm.c                       |  65 +++++++++++++++
 crypto/ghash-generic.c             |  10 ++-
 crypto/hmac.c                      |   3 +
 crypto/rsa-pkcs1pad.c              |  20 ++++-
 crypto/rsa.c                       |   5 ++
 crypto/seqiv.c                     |   4 +
 crypto/sha1_generic.c              |  10 ++-
 crypto/sha256_generic.c            |  13 ++-
 crypto/sha3_generic.c              |  12 ++-
 crypto/sha512_generic.c            |  12 ++-
 crypto/testmgr.c                   |  14 ++--
 crypto/xts.c                       |   9 ++-
 24 files changed, 365 insertions(+), 23 deletions(-)

diff --git a/arch/x86/crypto/aesni-intel_glue.c b/arch/x86/crypto/aesni-intel_glue.c
index 2aab5fe59..3edf21fb8 100644
--- a/arch/x86/crypto/aesni-intel_glue.c
+++ b/arch/x86/crypto/aesni-intel_glue.c
@@ -36,6 +36,7 @@
 #include <linux/workqueue.h>
 #include <linux/spinlock.h>
 #include <crypto/gf128mul.h>
+#include <linux/fips.h>
 
 void fcw_kernel_fpu_begin(void);
 void fcw_kernel_fpu_end(void);
@@ -54,6 +55,8 @@ extern struct scatterlist *fcw_scatterwalk_ffwd(struct scatterlist dst[2],
 extern void fcw_scatterwalk_unmap(void *vaddr);
 extern int fcw_printk(const char *fmt, ...);
 extern bool fcw_boot_cpu_has(unsigned long bit);
+int __init aesni_init(void);
+void __exit aesni_exit(void);
 
 #define AESNI_ALIGN	16
 #define AESNI_ALIGN_ATTR __attribute__ ((__aligned__(AESNI_ALIGN)))
@@ -97,6 +100,26 @@ asmlinkage void aesni_xts_enc(const struct crypto_aes_ctx *ctx, u8 *out,
 asmlinkage void aesni_xts_dec(const struct crypto_aes_ctx *ctx, u8 *out,
 			      const u8 *in, unsigned int len, u8 *iv);
 
+static char *gcm_encrypt_callers_whitelist[] = {
+	"_aead_recvmsg",
+};
+
+static char *rfc4106_gcm_encrypt_callers_whitelist[] = {
+	"seqiv_aead_encrypt",
+	"_aead_recvmsg",
+};
+
+static int is_caller_in_whitelist(char *caller_name, char **whitelist_callers, int size)
+{
+	int i = 0;
+
+	for (i = 0; i < size; i++) {
+		if (strstr(whitelist_callers[i], caller_name))
+			return 1;
+	}
+	return 0;
+}
+
 #ifdef CONFIG_X86_64
 
 static void (*aesni_ctr_enc_tfm)(struct crypto_aes_ctx *ctx, u8 *out,
@@ -506,8 +529,10 @@ static int xts_setkey_aesni(struct crypto_skcipher *tfm, const u8 *key,
 	int err;
 
 	err = xts_verify_key(tfm, key, keylen);
-	if (err)
+	if (err) {
+		fcw_printk(KERN_ERR "XTS verify duplicate key test failed\n");
 		return err;
+	}
 
 	keylen /= 2;
 
@@ -1361,6 +1386,7 @@ gcm_crypt(struct aead_request *req, int flags)
 	u32 le_ctr[4]; /* Counter in little-endian format */
 	int taglen;
 	int err;
+	char caller_name[64];
 
 	/* Initialize the counter and determine the associated data length. */
 	le_ctr[0] = 2;
@@ -1377,6 +1403,22 @@ gcm_crypt(struct aead_request *req, int flags)
 		le_ctr[3] = get_unaligned_be32(req->iv + 0);
 	}
 
+	if (fips_enabled && flags & FLAG_ENC) {
+		char **list = gcm_encrypt_callers_whitelist;
+		int size = ARRAY_SIZE(gcm_encrypt_callers_whitelist);
+		sprintf(caller_name, "%ps", __builtin_return_address(3));
+		if (flags & FLAG_RFC4106) {
+			list = rfc4106_gcm_encrypt_callers_whitelist;
+			size = ARRAY_SIZE(rfc4106_gcm_encrypt_callers_whitelist);
+		}
+		if (!is_caller_in_whitelist(caller_name, list,
+					    size)) {
+			fcw_printk(KERN_NOTICE "alg: (%s) (%s) Encryption with external IV is not"
+				   " approved in FIPS mode\n", crypto_tfm_alg_driver_name(req->base.tfm),
+				   crypto_tfm_alg_name(req->base.tfm));
+		}
+	}
+
 	/* Begin walking through the plaintext or ciphertext. */
 	if (flags & FLAG_ENC)
 		err = skcipher_walk_aead_encrypt(&walk, req, false);
@@ -1574,7 +1616,7 @@ static const struct x86_cpu_id zmm_exclusion_list[] = {
 
 static int __init register_avx_algs(void)
 {
-	int err;
+	int err, i;
 
 	if (!fcw_boot_cpu_has(X86_FEATURE_AVX))
 		return 0;
@@ -1587,6 +1629,23 @@ static int __init register_avx_algs(void)
 					 aes_gcm_simdalgs_aesni_avx);
 	if (err)
 		return err;
+
+	if (fips_enabled) {
+		for ( i = 0; i < ARRAY_SIZE(aes_gcm_algs_aesni_avx); i++) {
+			if (strstr(aes_gcm_algs_aesni_avx[i].base.cra_name, "rfc4106")) {
+				fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption and decryption "
+					   " with internal IV is registered as an approved service\n",
+					   aes_gcm_algs_aesni_avx[i].base.cra_driver_name, aes_gcm_algs_aesni_avx[i].base.cra_name);
+			}
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) decryption with external IV "
+				   "is registered as an approved service\n",
+				   aes_gcm_algs_aesni_avx[i].base.cra_driver_name, aes_gcm_algs_aesni_avx[i].base.cra_name);
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption with external IV "
+				   "is registered as a non-approved service\n",
+				   aes_gcm_algs_aesni_avx[i].base.cra_driver_name, aes_gcm_algs_aesni_avx[i].base.cra_name);
+		}
+	}
+
 #if defined(CONFIG_AS_VAES) && defined(CONFIG_AS_VPCLMULQDQ)
 	if (!fcw_boot_cpu_has(X86_FEATURE_AVX2) ||
 	    !fcw_boot_cpu_has(X86_FEATURE_VAES) ||
@@ -1616,6 +1675,22 @@ static int __init register_avx_algs(void)
 	if (err)
 		return err;
 
+	if (fips_enabled) {
+		for ( i = 0; i < ARRAY_SIZE(aes_gcm_algs_vaes_avx10_256); i++) {
+			if (strstr(aes_gcm_algs_vaes_avx10_256[i].base.cra_name, "rfc4106")) {
+				fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption and decryption "
+					   " with internal IV is registered as an approved service\n",
+					   aes_gcm_algs_vaes_avx10_256[i].base.cra_driver_name, aes_gcm_algs_vaes_avx10_256[i].base.cra_name);
+			}
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) decryption with external IV "
+				   "is registered as an approved service\n",
+				   aes_gcm_algs_vaes_avx10_256[i].base.cra_driver_name, aes_gcm_algs_vaes_avx10_256[i].base.cra_name);
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption with external IV "
+				   "is registered as a non-approved service\n",
+				   aes_gcm_algs_vaes_avx10_256[i].base.cra_driver_name, aes_gcm_algs_vaes_avx10_256[i].base.cra_name);
+		}
+	}
+
 	if (x86_match_cpu(zmm_exclusion_list)) {
 		int i;
 
@@ -1633,6 +1708,23 @@ static int __init register_avx_algs(void)
 					 aes_gcm_simdalgs_vaes_avx10_512);
 	if (err)
 		return err;
+
+	if (fips_enabled) {
+		for ( i = 0; i < ARRAY_SIZE(aes_gcm_algs_vaes_avx10_512); i++) {
+			if (strstr(aes_gcm_algs_vaes_avx10_512[i].base.cra_name, "rfc4106")) {
+				fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption and decryption "
+					   " with internal IV is registered as an approved service\n",
+					   aes_gcm_algs_vaes_avx10_512[i].base.cra_driver_name, aes_gcm_algs_vaes_avx10_512[i].base.cra_name);
+			}
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) decryption with external IV "
+				   "is registered as an approved service\n",
+				   aes_gcm_algs_vaes_avx10_512[i].base.cra_driver_name, aes_gcm_algs_vaes_avx10_512[i].base.cra_name);
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption with external IV "
+				   "is registered as a non-approved service\n",
+				   aes_gcm_algs_vaes_avx10_512[i].base.cra_driver_name, aes_gcm_algs_vaes_avx10_512[i].base.cra_name);
+		}
+	}
+
 #endif /* CONFIG_AS_VAES && CONFIG_AS_VPCLMULQDQ */
 	return 0;
 }
@@ -1690,7 +1782,7 @@ MODULE_DEVICE_TABLE(x86cpu, aesni_cpu_id);
 
 int __init aesni_init(void)
 {
-	int err;
+	int err, i;
 
 	if (!x86_match_cpu(aesni_cpu_id))
 		return -ENODEV;
@@ -1706,18 +1798,45 @@ int __init aesni_init(void)
 	if (err)
 		return err;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   aesni_cipher_alg.cra_driver_name, aesni_cipher_alg.cra_name);
+	}
+
 	err = simd_register_skciphers_compat(aesni_skciphers,
 					     ARRAY_SIZE(aesni_skciphers),
 					     aesni_simd_skciphers);
 	if (err)
 		goto unregister_cipher;
 
+	if (fips_enabled) {
+		for ( i = 0; i < ARRAY_SIZE(aesni_skciphers); i++) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   aesni_skciphers[i].base.cra_driver_name, aesni_skciphers[i].base.cra_name);
+		}
+	}
+
 	err = simd_register_aeads_compat(aes_gcm_algs_aesni,
 					 ARRAY_SIZE(aes_gcm_algs_aesni),
 					 aes_gcm_simdalgs_aesni);
 	if (err)
 		goto unregister_skciphers;
 
+	if (fips_enabled) {
+		for ( i = 0; i < ARRAY_SIZE(aes_gcm_algs_aesni); i++) {
+			if (strstr(aes_gcm_algs_aesni[i].base.cra_name, "rfc4106")) {
+				fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption and decryption "
+					   " with internal IV is registered as an approved service\n",
+					   aes_gcm_algs_aesni[i].base.cra_driver_name, aes_gcm_algs_aesni[i].base.cra_name);
+			}
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) decryption with external IV "
+				   "is registered as an approved service\n",
+				   aes_gcm_algs_aesni[i].base.cra_driver_name, aes_gcm_algs_aesni[i].base.cra_name);
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption with external IV "
+				   "is registered as a non-approved service\n",
+				   aes_gcm_algs_aesni[i].base.cra_driver_name, aes_gcm_algs_aesni[i].base.cra_name);
+		}
+	}
 
 #ifdef CONFIG_X86_64
 	if (fcw_boot_cpu_has(X86_FEATURE_AVX))
diff --git a/crypto/aes_generic.c b/crypto/aes_generic.c
index d26cc2af0..2083ba027 100644
--- a/crypto/aes_generic.c
+++ b/crypto/aes_generic.c
@@ -54,6 +54,8 @@
 #include <linux/errno.h>
 #include <asm/byteorder.h>
 #include <linux/unaligned.h>
+#include <linux/fips.h>
+#include "fips_canister_wrapper.h"
 
 static inline u8 byte(const u32 x, const unsigned n)
 {
@@ -1297,7 +1299,14 @@ static struct crypto_alg aes_alg = {
 
 int __init aes_init(void)
 {
-	return crypto_register_alg(&aes_alg);
+	int ret;
+
+	ret = crypto_register_alg(&aes_alg);
+	if (!ret && fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   aes_alg.cra_driver_name, aes_alg.cra_name);
+	}
+	return ret;
 }
 
 void __exit aes_fini(void)
diff --git a/crypto/cbc.c b/crypto/cbc.c
index 1300cf12d..20bc532e3 100644
--- a/crypto/cbc.c
+++ b/crypto/cbc.c
@@ -10,6 +10,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/log2.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 static int crypto_cbc_encrypt_segment(struct crypto_lskcipher *tfm,
@@ -158,6 +159,9 @@ static int crypto_cbc_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 out_free_inst:
 		inst->free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   inst->alg.co.base.cra_driver_name, inst->alg.co.base.cra_name);
 	}
 
 	return err;
diff --git a/crypto/ccm.c b/crypto/ccm.c
index c40a37ada..d4ae67871 100644
--- a/crypto/ccm.c
+++ b/crypto/ccm.c
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 struct ccm_instance_ctx {
@@ -522,6 +523,9 @@ static int crypto_ccm_create_common(struct crypto_template *tmpl,
 	if (err) {
 err_free_inst:
 		crypto_ccm_free(inst);
+	} else if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
@@ -769,6 +773,9 @@ static int crypto_rfc4309_create(struct crypto_template *tmpl,
 	if (err) {
 err_free_inst:
 		crypto_rfc4309_free(inst);
+	} else if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as a non-approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
@@ -904,6 +911,9 @@ static int cbcmac_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 err_free_inst:
 		shash_free_singlespawn_instance(inst);
+	} else if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) outside of ccm is registered as a non-approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
diff --git a/crypto/cmac.c b/crypto/cmac.c
index 8df4433f8..090f51fdf 100644
--- a/crypto/cmac.c
+++ b/crypto/cmac.c
@@ -15,6 +15,7 @@
 #include <crypto/internal/hash.h>
 #include <linux/err.h>
 #include <linux/kernel.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 /*
@@ -287,6 +288,9 @@ static int cmac_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 err_free_inst:
 		shash_free_singlespawn_instance(inst);
+	} else if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
diff --git a/crypto/ctr.c b/crypto/ctr.c
index 8981b8cc6..c1b3eee04 100644
--- a/crypto/ctr.c
+++ b/crypto/ctr.c
@@ -13,6 +13,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 struct crypto_rfc3686_ctx {
@@ -161,6 +162,9 @@ static int crypto_ctr_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 out_free_inst:
 		inst->free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 
 	return err;
@@ -322,6 +326,9 @@ static int crypto_rfc3686_create(struct crypto_template *tmpl,
 	if (err) {
 err_free_inst:
 		crypto_rfc3686_free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as a non-approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
diff --git a/crypto/cts.c b/crypto/cts.c
index de750ff87..b084590d8 100644
--- a/crypto/cts.c
+++ b/crypto/cts.c
@@ -50,6 +50,7 @@
 #include <crypto/scatterwalk.h>
 #include <linux/slab.h>
 #include <linux/compiler.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 struct crypto_cts_ctx {
@@ -382,6 +383,9 @@ static int crypto_cts_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 err_free_inst:
 		crypto_cts_free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
diff --git a/crypto/drbg.c b/crypto/drbg.c
index 96b645954..890f05050 100644
--- a/crypto/drbg.c
+++ b/crypto/drbg.c
@@ -101,6 +101,7 @@
 #include <crypto/internal/cipher.h>
 #include <linux/kernel.h>
 #include <linux/jiffies.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 /***************************************************************
@@ -2196,7 +2197,14 @@ int __init drbg_init(void)
 		drbg_fill_array(&drbg_algs[i], &drbg_cores[j], 1);
 	for (j = 0; ARRAY_SIZE(drbg_cores) > j; j++, i++)
 		drbg_fill_array(&drbg_algs[i], &drbg_cores[j], 0);
-	return crypto_register_rngs(drbg_algs, (ARRAY_SIZE(drbg_cores) * 2));
+	ret = crypto_register_rngs(drbg_algs, (ARRAY_SIZE(drbg_cores) * 2));
+	if (!ret && fips_enabled) {
+		for (i = 0; i < ARRAY_SIZE(drbg_cores) * 2; i++) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   drbg_algs[i].base.cra_driver_name, drbg_algs[i].base.cra_name);
+		}
+	}
+	return ret;
 }
 
 void __exit drbg_exit(void)
diff --git a/crypto/ecb.c b/crypto/ecb.c
index 5473b97d6..2bd8d211e 100644
--- a/crypto/ecb.c
+++ b/crypto/ecb.c
@@ -11,6 +11,8 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/fips.h>
+#include "fips_canister_wrapper.h"
 
 static int crypto_ecb_crypt(struct crypto_cipher *cipher, const u8 *src,
 			    u8 *dst, unsigned nbytes, bool final,
@@ -196,8 +198,12 @@ static int crypto_ecb_create(struct crypto_template *tmpl, struct rtattr **tb)
 	inst->alg.exit = cipher_alg->exit;
 
 	err = lskcipher_register_instance(tmpl, inst);
-	if (err)
+	if (err) {
 		inst->free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   inst->alg.co.base.cra_driver_name, inst->alg.co.base.cra_name);
+	}
 
 	return err;
 }
diff --git a/crypto/ecc.c b/crypto/ecc.c
index e456517a2..cdd069e89 100644
--- a/crypto/ecc.c
+++ b/crypto/ecc.c
@@ -32,6 +32,7 @@
 #include <crypto/rng.h>
 #include <crypto/internal/ecc.h>
 #include <linux/unaligned.h>
+#include <linux/fips.h>
 
 #include "ecc_curve_defs.h"
 #include "fips_canister_wrapper.h"
diff --git a/crypto/ecdh.c b/crypto/ecdh.c
index 4e53880b1..8609b029b 100644
--- a/crypto/ecdh.c
+++ b/crypto/ecdh.c
@@ -10,6 +10,7 @@
 #include <crypto/kpp.h>
 #include <crypto/ecdh.h>
 #include <linux/scatterlist.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 struct ecdh_ctx {
@@ -217,10 +218,20 @@ int __init ecdh_init(void)
 	if (ret)
 		goto nist_p256_error;
 
+	if(fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   ecdh_nist_p256.base.cra_driver_name, ecdh_nist_p256.base.cra_name);
+	}
+
 	ret = crypto_register_kpp(&ecdh_nist_p384);
 	if (ret)
 		goto nist_p384_error;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   ecdh_nist_p384.base.cra_driver_name, ecdh_nist_p384.base.cra_name);
+	}
+
 	return 0;
 
 nist_p384_error:
diff --git a/crypto/ecdsa.c b/crypto/ecdsa.c
index faa678b89..41d3309bb 100644
--- a/crypto/ecdsa.c
+++ b/crypto/ecdsa.c
@@ -8,6 +8,7 @@
 #include <crypto/akcipher.h>
 #include <crypto/ecdh.h>
 #include <linux/asn1_decoder.h>
+#include <linux/fips.h>
 #include <linux/scatterlist.h>
 
 #include "ecdsasignature.asn1.h"
@@ -354,14 +355,29 @@ int __init ecdsa_init(void)
 	if (ret)
 		goto nist_p256_error;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   ecdsa_nist_p256.base.cra_driver_name, ecdsa_nist_p256.base.cra_name);
+	}
+
 	ret = crypto_register_akcipher(&ecdsa_nist_p384);
 	if (ret)
 		goto nist_p384_error;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   ecdsa_nist_p384.base.cra_driver_name, ecdsa_nist_p384.base.cra_name);
+	}
+
 	ret = crypto_register_akcipher(&ecdsa_nist_p521);
 	if (ret)
 		goto nist_p521_error;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   ecdsa_nist_p521.base.cra_driver_name, ecdsa_nist_p521.base.cra_name);
+	}
+
 	return 0;
 
 nist_p521_error:
diff --git a/crypto/gcm.c b/crypto/gcm.c
index 44a89c022..05e81b216 100644
--- a/crypto/gcm.c
+++ b/crypto/gcm.c
@@ -17,6 +17,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 struct gcm_instance_ctx {
@@ -446,11 +447,43 @@ static void gcm_encrypt_done(void *data, int err)
 	aead_request_complete(req, err);
 }
 
+static char *gcm_encrypt_callers_whitelist[] = {
+	"crypto_rfc4106_encrypt",
+	"_aead_recvmsg",
+};
+
+static char *rfc4106_gcm_encrypt_callers_whitelist[] = {
+	"seqiv_aead_encrypt",
+	"_aead_recvmsg",
+};
+
+static int is_caller_in_whitelist(char *caller_name, char **whitelist_callers, int size)
+{
+	int i = 0;
+
+	for (i = 0; i < size; i++) {
+		if (strstr(whitelist_callers[i], caller_name))
+			return 1;
+	}
+	return 0;
+}
+
 static int crypto_gcm_encrypt(struct aead_request *req)
 {
 	struct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);
 	struct skcipher_request *skreq = &pctx->u.skreq;
 	u32 flags = aead_request_flags(req);
+	char caller_name[64];
+
+	if (fips_enabled) {
+		sprintf(caller_name, "%ps", __builtin_return_address(1));
+		if (!is_caller_in_whitelist(caller_name, gcm_encrypt_callers_whitelist,
+					    ARRAY_SIZE(gcm_encrypt_callers_whitelist))) {
+			fcw_printk(KERN_NOTICE "alg: (%s) (%s) Encryption with external IV is not"
+					" approved in FIPS mode\n", crypto_tfm_alg_driver_name(req->base.tfm),
+					crypto_tfm_alg_name(req->base.tfm));
+		}
+	}
 
 	crypto_gcm_init_common(req);
 	crypto_gcm_init_crypt(req, req->cryptlen);
@@ -647,6 +680,13 @@ static int crypto_gcm_create_common(struct crypto_template *tmpl,
 	if (err) {
 err_free_inst:
 		crypto_gcm_free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) decryption with external IV "
+				   "is registered as an approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption with external IV "
+				   "is registered as an non-approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
@@ -746,6 +786,7 @@ static struct aead_request *crypto_rfc4106_crypt(struct aead_request *req)
 	}
 
 	aead_request_set_tfm(subreq, child);
+
 	aead_request_set_callback(subreq, req->base.flags, req->base.complete,
 				  req->base.data);
 	aead_request_set_crypt(subreq, rctx->src,
@@ -759,6 +800,17 @@ static struct aead_request *crypto_rfc4106_crypt(struct aead_request *req)
 static int crypto_rfc4106_encrypt(struct aead_request *req)
 {
 	int err;
+	char caller_name[64];
+
+	if (fips_enabled) {
+		sprintf(caller_name, "%ps", __builtin_return_address(1));
+		if (!is_caller_in_whitelist(caller_name, rfc4106_gcm_encrypt_callers_whitelist,
+					    ARRAY_SIZE(rfc4106_gcm_encrypt_callers_whitelist))) {
+			fcw_printk(KERN_NOTICE "alg: (%s) (%s) Encryption with external IV is not"
+					" approved in FIPS mode\n", crypto_tfm_alg_driver_name(req->base.tfm),
+					crypto_tfm_alg_name(req->base.tfm));
+		}
+	}
 
 	err = crypto_ipsec_check_assoclen(req->assoclen);
 	if (err)
@@ -888,6 +940,16 @@ static int crypto_rfc4106_create(struct crypto_template *tmpl,
 	if (err) {
 err_free_inst:
 		crypto_rfc4106_free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption with internal IV "
+				   "is registered as an approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) decryption with internal and external IV "
+				   "is registered as an approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) encryption with external IV "
+				   "is registered as a non-approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
@@ -1103,6 +1165,9 @@ static int crypto_rfc4543_create(struct crypto_template *tmpl,
 	if (err) {
 err_free_inst:
 		crypto_rfc4543_free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as a non-approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
diff --git a/crypto/ghash-generic.c b/crypto/ghash-generic.c
index 050fa7d93..19d4b7803 100644
--- a/crypto/ghash-generic.c
+++ b/crypto/ghash-generic.c
@@ -41,6 +41,7 @@
 #include <linux/crypto.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 static int ghash_init(struct shash_desc *desc)
@@ -167,7 +168,14 @@ static struct shash_alg ghash_alg = {
 
 int __init ghash_mod_init(void)
 {
-	return crypto_register_shash(&ghash_alg);
+	int ret;
+
+	ret = crypto_register_shash(&ghash_alg);
+	if (!ret && fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) outside of gcm is registered as a non-approved service\n",
+			   ghash_alg.base.cra_driver_name, ghash_alg.base.cra_name);
+	}
+	return ret;
 }
 
 void __exit ghash_mod_exit(void)
diff --git a/crypto/hmac.c b/crypto/hmac.c
index 60540c928..430d334aa 100644
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -239,6 +239,9 @@ static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 err_free_inst:
 		shash_free_singlespawn_instance(inst);
+	} else if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
diff --git a/crypto/rsa-pkcs1pad.c b/crypto/rsa-pkcs1pad.c
index 0c27c8985..31f3050d8 100644
--- a/crypto/rsa-pkcs1pad.c
+++ b/crypto/rsa-pkcs1pad.c
@@ -14,6 +14,7 @@
 #include <linux/kernel.h>
 #include <linux/random.h>
 #include <linux/scatterlist.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 /*
@@ -254,6 +255,12 @@ static int pkcs1pad_encrypt(struct akcipher_request *req)
 	int err;
 	unsigned int i, ps_end;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE "alg: (%s) (%s) Encryption is not approved in FIPS mode\n",
+			   crypto_tfm_alg_driver_name(req->base.tfm), crypto_tfm_alg_name(req->base.tfm));
+
+	}
+
 	if (!ctx->key_size)
 		return -EINVAL;
 
@@ -368,6 +375,12 @@ static int pkcs1pad_decrypt(struct akcipher_request *req)
 	struct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);
 	int err;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE "alg: (%s) (%s) Decryption is not approved in FIPS mode\n",
+			   crypto_tfm_alg_driver_name(req->base.tfm), crypto_tfm_alg_name(req->base.tfm));
+
+	}
+
 	if (!ctx->key_size || req->src_len != ctx->key_size)
 		return -EINVAL;
 
@@ -701,6 +714,12 @@ static int pkcs1pad_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 err_free_inst:
 		pkcs1pad_free(inst);
+	} else if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) Signature generation and verification "
+			   "is registered as an approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) Key transport is registered as a non-approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
@@ -711,4 +730,3 @@ struct crypto_template rsa_pkcs1pad_tmpl = {
 	.module = THIS_MODULE,
 };
 
-MODULE_ALIAS_CRYPTO("pkcs1pad");
diff --git a/crypto/rsa.c b/crypto/rsa.c
index 93cba5859..96db023fd 100644
--- a/crypto/rsa.c
+++ b/crypto/rsa.c
@@ -406,6 +406,11 @@ int __init rsa_init(void)
 	if (err)
 		return err;
 
+	if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   rsa.base.cra_driver_name, rsa.base.cra_name);
+	}
+
 	err = crypto_register_template(&rsa_pkcs1pad_tmpl);
 	if (err) {
 		crypto_unregister_akcipher(&rsa);
diff --git a/crypto/seqiv.c b/crypto/seqiv.c
index 6d83eda77..e13b87f03 100644
--- a/crypto/seqiv.c
+++ b/crypto/seqiv.c
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 static void seqiv_aead_encrypt_complete2(struct aead_request *req, int err)
@@ -158,6 +159,9 @@ static int seqiv_aead_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 free_inst:
 		inst->free(inst);
+	} else if (fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) internal IV generator is registered as an approved service\n",
+				   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
diff --git a/crypto/sha1_generic.c b/crypto/sha1_generic.c
index aa9cfd6e1..7e4201794 100644
--- a/crypto/sha1_generic.c
+++ b/crypto/sha1_generic.c
@@ -18,6 +18,7 @@
 #include <crypto/sha1.h>
 #include <crypto/sha1_base.h>
 #include <asm/byteorder.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 const u8 sha1_zero_message_hash[SHA1_DIGEST_SIZE] = {
@@ -75,7 +76,14 @@ static struct shash_alg alg = {
 
 int __init sha1_generic_mod_init(void)
 {
-	return crypto_register_shash(&alg);
+	int ret;
+
+	ret = crypto_register_shash(&alg);
+	if (!ret && fips_enabled) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   alg.base.cra_driver_name, alg.base.cra_name);
+	}
+	return ret;
 }
 
 void __exit sha1_generic_mod_fini(void)
diff --git a/crypto/sha256_generic.c b/crypto/sha256_generic.c
index 9bc82ab39..bb8859607 100644
--- a/crypto/sha256_generic.c
+++ b/crypto/sha256_generic.c
@@ -15,6 +15,8 @@
 #include <crypto/sha256_base.h>
 #include <asm/byteorder.h>
 #include <linux/unaligned.h>
+#include <linux/fips.h>
+#include "fips_canister_wrapper.h"
 
 const u8 sha224_zero_message_hash[SHA224_DIGEST_SIZE] = {
 	0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9, 0x47,
@@ -85,7 +87,16 @@ static struct shash_alg sha256_algs[2] = { {
 
 int __init sha256_generic_mod_init(void)
 {
-	return crypto_register_shashes(sha256_algs, ARRAY_SIZE(sha256_algs));
+	int i, ret;
+
+	ret = crypto_register_shashes(sha256_algs, ARRAY_SIZE(sha256_algs));
+	if (!ret && fips_enabled) {
+		for (i = 0; i < ARRAY_SIZE(sha256_algs); i++) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   sha256_algs[i].base.cra_driver_name, sha256_algs[i].base.cra_name);
+		}
+	}
+	return ret;
 }
 
 void __exit sha256_generic_mod_fini(void)
diff --git a/crypto/sha3_generic.c b/crypto/sha3_generic.c
index 010611b57..fba5e790c 100644
--- a/crypto/sha3_generic.c
+++ b/crypto/sha3_generic.c
@@ -13,6 +13,7 @@
 #include <linux/types.h>
 #include <crypto/sha3.h>
 #include <linux/unaligned.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 /*
@@ -278,7 +279,16 @@ static struct shash_alg algs[] = { {
 
 int __init sha3_generic_mod_init(void)
 {
-	return crypto_register_shashes(algs, ARRAY_SIZE(algs));
+	int i, ret;
+
+	ret = crypto_register_shashes(algs, ARRAY_SIZE(algs));
+	if (!ret && fips_enabled) {
+		for (i = 0; i < ARRAY_SIZE(algs); i++) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   algs[i].base.cra_driver_name, algs[i].base.cra_name);
+		}
+	}
+	return ret;
 }
 
 void __exit sha3_generic_mod_fini(void)
diff --git a/crypto/sha512_generic.c b/crypto/sha512_generic.c
index c4e3c6c2d..83e5bb8b6 100644
--- a/crypto/sha512_generic.c
+++ b/crypto/sha512_generic.c
@@ -16,6 +16,7 @@
 #include <linux/percpu.h>
 #include <asm/byteorder.h>
 #include <linux/unaligned.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 const u8 sha384_zero_message_hash[SHA384_DIGEST_SIZE] = {
@@ -203,7 +204,16 @@ static struct shash_alg sha512_algs[2] = { {
 
 int __init sha512_generic_mod_init(void)
 {
-	return crypto_register_shashes(sha512_algs, ARRAY_SIZE(sha512_algs));
+	int i, ret;
+
+	ret = crypto_register_shashes(sha512_algs, ARRAY_SIZE(sha512_algs));
+	if (!ret && fips_enabled) {
+		for (i = 0; i < ARRAY_SIZE(sha512_algs); i++) {
+			fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+				   sha512_algs[i].base.cra_driver_name, sha512_algs[i].base.cra_name);
+		}
+	}
+	return ret;
 }
 
 void __exit sha512_generic_mod_fini(void)
diff --git a/crypto/testmgr.c b/crypto/testmgr.c
index 10c160647..1a3ec52c2 100644
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@ -2425,9 +2425,11 @@ static int alg_test_aead(const struct alg_test_desc *desc, const char *driver,
 		goto out;
 	}
 
-	err = test_aead(ENCRYPT, suite, req, tsgls);
-	if (err)
-		goto out;
+	if (fips_enabled && !strstr(desc->alg, "gcm(aes)")) {
+		err = test_aead(ENCRYPT, suite, req, tsgls);
+		if (err)
+			goto out;
+	}
 
 	err = test_aead(DECRYPT, suite, req, tsgls);
 	if (err)
@@ -4110,7 +4112,6 @@ static const struct alg_test_desc alg_test_descs[] = {
 	}, {
 		.alg = "authenc(hmac(sha1),rfc3686(ctr(aes)))",
 		.test = alg_test_null,
-		.fips_allowed = 1,
 	}, {
 		.alg = "authenc(hmac(sha224),cbc(des))",
 		.test = alg_test_aead,
@@ -4149,7 +4150,6 @@ static const struct alg_test_desc alg_test_descs[] = {
 	}, {
 		.alg = "authenc(hmac(sha256),rfc3686(ctr(aes)))",
 		.test = alg_test_null,
-		.fips_allowed = 1,
 	}, {
 		.alg = "authenc(hmac(sha384),cbc(des))",
 		.test = alg_test_aead,
@@ -4169,7 +4169,6 @@ static const struct alg_test_desc alg_test_descs[] = {
 	}, {
 		.alg = "authenc(hmac(sha384),rfc3686(ctr(aes)))",
 		.test = alg_test_null,
-		.fips_allowed = 1,
 	}, {
 		.alg = "authenc(hmac(sha512),cbc(aes))",
 		.fips_allowed = 1,
@@ -4196,7 +4195,6 @@ static const struct alg_test_desc alg_test_descs[] = {
 	}, {
 		.alg = "authenc(hmac(sha512),rfc3686(ctr(aes)))",
 		.test = alg_test_null,
-		.fips_allowed = 1,
 	}, {
 		.alg = "blake2b-160",
 		.test = alg_test_hash,
@@ -5240,7 +5238,6 @@ static const struct alg_test_desc alg_test_descs[] = {
 	}, {
 		.alg = "rfc3686(ctr(aes))",
 		.test = alg_test_skcipher,
-		.fips_allowed = 1,
 		.suite = {
 			.cipher = __VECS(aes_ctr_rfc3686_tv_template)
 		}
@@ -5266,7 +5263,6 @@ static const struct alg_test_desc alg_test_descs[] = {
 		.alg = "rfc4309(ccm(aes))",
 		.generic_driver = "rfc4309(ccm_base(ctr(aes-generic),cbcmac(aes-generic)))",
 		.test = alg_test_aead,
-		.fips_allowed = 1,
 		.suite = {
 			.aead = {
 				____VECS(aes_ccm_rfc4309_tv_template),
diff --git a/crypto/xts.c b/crypto/xts.c
index 0e619e399..c3bccc80a 100644
--- a/crypto/xts.c
+++ b/crypto/xts.c
@@ -19,6 +19,7 @@
 #include <crypto/xts.h>
 #include <crypto/b128ops.h>
 #include <crypto/gf128mul.h>
+#include <linux/fips.h>
 #include "fips_canister_wrapper.h"
 
 struct xts_tfm_ctx {
@@ -47,9 +48,10 @@ static int xts_setkey(struct crypto_skcipher *parent, const u8 *key,
 	int err;
 
 	err = xts_verify_key(parent, key, keylen);
-	if (err)
+	if (err) {
+		fcw_printk(KERN_ERR "XTS verify duplicate key test failed\n");
 		return err;
-
+	}
 	keylen /= 2;
 
 	/* we need two cipher instances: one to compute the initial 'tweak'
@@ -446,6 +448,9 @@ static int xts_create(struct crypto_template *tmpl, struct rtattr **tb)
 	if (err) {
 err_free_inst:
 		xts_free_instance(inst);
+	} else if (fips_enabled) {
+		fcw_printk(KERN_NOTICE pr_fmt() "alg: %s (%s) is registered as an approved service\n",
+			   inst->alg.base.cra_driver_name, inst->alg.base.cra_name);
 	}
 	return err;
 }
-- 
2.39.4

