From 2e319f74f185adbaf048ff09b6872929f8082dbe Mon Sep 17 00:00:00 2001
From: srinidhira0 <srinidhir@vmware.com>
Date: Wed, 13 Nov 2024 11:29:35 +0000
Subject: [PATCH] fs: A new VTARFS file system to mount VTAR archive

- GNU TAR Archieve consists of header with information of the
files and directories. This GNU TAR format can be extended to VTAR
format by ensuring that each file content data starts from a
PAGE ALIGNED address. This start address of the file can be stored
in a field in the header itself which will help to navigate to the
file content.

- Such an archive image (VTAR) when stored in RAMFS can be easily
mounted instead of extraction using VTARFS.
- VTARFS only creates and maintains metadata, inodes and dentries
of files & directries. For a file, the entry for that particular
file will point to the start address offset of the VTAR archive
image whenever the file is read or executed.
- Unlike VTAR Extractor which creates files and directory using
syscalls, In VTARFS, inodes and dentries are created and maintained.
Also, file operations like read_iter, mmap and others are defined
and implemented.

- Mounting operation is very quick and avoids additional memory
allocation for file content data.

Signed-off-by: srinidhira0 <srinidhir@vmware.com>
Signed-off-by: Ankit Jain <ankitja@vmware.com>
Signed-off-by: Bo Gan <ganb@vmware.com>
---
 fs/Kconfig                      |   1 +
 fs/Makefile                     |   1 +
 fs/vtarfs/Kconfig               |  21 +
 fs/vtarfs/Makefile              |   9 +
 fs/vtarfs/README.md             |   3 +
 fs/vtarfs/vtarfs.h              | 171 +++++++
 fs/vtarfs/vtarfs_file_dir_ops.c | 472 +++++++++++++++++++
 fs/vtarfs/vtarfs_inode.c        | 773 ++++++++++++++++++++++++++++++++
 8 files changed, 1451 insertions(+)
 create mode 100644 fs/vtarfs/Kconfig
 create mode 100644 fs/vtarfs/Makefile
 create mode 100644 fs/vtarfs/README.md
 create mode 100644 fs/vtarfs/vtarfs.h
 create mode 100644 fs/vtarfs/vtarfs_file_dir_ops.c
 create mode 100644 fs/vtarfs/vtarfs_inode.c

diff --git a/fs/Kconfig b/fs/Kconfig
index 570f8f00c..4dadee4bf 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -342,6 +342,7 @@ source "fs/ufs/Kconfig"
 source "fs/erofs/Kconfig"
 source "fs/vboxsf/Kconfig"
 source "fs/vtar/Kconfig"
+source "fs/vtarfs/Kconfig"
 
 endif # MISC_FILESYSTEMS
 
diff --git a/fs/Makefile b/fs/Makefile
index a0f4c8544..032d95a78 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -130,4 +130,5 @@ obj-$(CONFIG_EROFS_FS)		+= erofs/
 obj-$(CONFIG_VBOXSF_FS)		+= vboxsf/
 obj-$(CONFIG_ZONEFS_FS)		+= zonefs/
 obj-$(CONFIG_VTAR)		+= vtar/
+obj-$(CONFIG_VTARFS)		+= vtarfs/
 obj-$(CONFIG_BPF_LSM)		+= bpf_fs_kfuncs.o
diff --git a/fs/vtarfs/Kconfig b/fs/vtarfs/Kconfig
new file mode 100644
index 000000000..872a3a8df
--- /dev/null
+++ b/fs/vtarfs/Kconfig
@@ -0,0 +1,21 @@
+config VTARFS
+	tristate "Virtual TARFS file system support"
+	depends on TMPFS
+	help
+	  The GNU TAR archive format can be modified into Virtual TAR archive
+	  format by ensuring that each file starts from a PAGE ALIGNED address.
+	  This start address of each file is stored as an offset in the VTAR
+	  Header itself which helps to navigate to the start of file content.
+	  VTARFS will mount such an archive and extracting such archive will
+	  no longer be necessary. The files will appear virtually in the mounted
+	  directory path. The actual file inode mapping will point to the file
+	  offset of the VTAR archive image.
+
+	  This file system will mount the VTAR archive as READ ONLY.
+
+	  Usually container base images are stored as VTAR archive.
+
+	  Say Y or M if you want to read files from VTAR archive image.
+
+	  To compile this file system support as a module, choose M here: the
+	  module will be called vtarfs.  If unsure, say N.
diff --git a/fs/vtarfs/Makefile b/fs/vtarfs/Makefile
new file mode 100644
index 000000000..988edc7d7
--- /dev/null
+++ b/fs/vtarfs/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the vtarfs routines.
+#
+
+obj-$(CONFIG_VTARFS) += vtarfs.o
+
+CFLAGS_vtarfs_file_dir_ops.o := -I$(src)
+CFLAGS_vtarfs_inode.o := -I$(src)
+vtarfs-objs := vtarfs_file_dir_ops.o vtarfs_inode.o
diff --git a/fs/vtarfs/README.md b/fs/vtarfs/README.md
new file mode 100644
index 000000000..fe38b05c5
--- /dev/null
+++ b/fs/vtarfs/README.md
@@ -0,0 +1,3 @@
+# vmware_tarfs
+
+This projects provides a way to mount the vmware format tar ball to a directory
\ No newline at end of file
diff --git a/fs/vtarfs/vtarfs.h b/fs/vtarfs/vtarfs.h
new file mode 100644
index 000000000..1bcfce0ee
--- /dev/null
+++ b/fs/vtarfs/vtarfs.h
@@ -0,0 +1,171 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Filesystem to directly mount vtar archive.
+ *
+ * Copyright 2020 VMware, Inc. All Rights Reserved.
+ *
+ * Licensed under the GNU Lesser General Public License version 2 (the "License");
+ * you may not use this file except in compliance with the License. The terms
+ * of the License are located in the LICENSE file of this distribution.
+ *
+ */
+
+#ifndef vtarfs
+#define vtarfs
+
+#include<linux/fs.h>
+#include<linux/radix-tree.h>
+
+#define MAX_PAGES_PER_FILE (MAX_LFS_FILESIZE/PAGE_SIZE)
+#define MAX_FILE_NAME_SIZE 100
+#define DEBUG_PRINT
+#ifdef DEBUG_PRINT
+#define tarfs_debug(fmt, args...) \
+pr_debug("[%s:]" fmt, __func__, ##args)
+#else
+#define tarfs_debug(fmt, args...)
+#endif
+
+/* Values used in typeflag field.  */
+#define REGTYPE  '0'            /* regular file */
+#define AREGTYPE '\0'           /* regular file */
+#define LNKTYPE  '1'            /* link */
+#define SYMTYPE  '2'            /* reserved */
+#define CHRTYPE  '3'            /* character special */
+#define BLKTYPE  '4'            /* block special */
+#define DIRTYPE  '5'            /* directory */
+#define FIFOTYPE '6'            /* FIFO special */
+#define TAR_TYPE_SHAREDFILE   '7'   /* VMWare custom file type for marking shared files */
+#define TAR_TYPE_GNU_LONGLINK 'K'   /* GNU LongLink extension (long link name) */
+#define TAR_TYPE_GNU_LONGNAME 'L'   /* GNU LongLink extension (long file name) */
+
+#define vtarfs_MAGIC "visor  " /* 8 chars and NULL */
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+
+struct vtarfs_img_map_t {
+	struct file		*fp;
+	struct address_space	*tarfs_img_map;
+	struct inode		*inode;
+};
+
+struct vtarfs_mount_opts {
+	umode_t			mode;
+};
+
+struct vtarfs_header_type {			/* byte offset */
+	char name[MAX_FILE_NAME_SIZE];		/*   0 */
+	char mode[8];				/* 100 */
+	char uid[8];				/* 108 */
+	char gid[8];				/* 116 */
+	char size[12];				/* 124 */
+	char mtime[12];				/* 136 */
+	char chksum[8];				/* 148 */
+	char typeflag;				/* 156 */
+	char linkname[MAX_FILE_NAME_SIZE];	/* 157 */
+	char magic[6];				/* 257 */
+	char version[2];			/* 263 */
+	char uname[32];				/* 265 */
+	char gname[32];				/* 297 */
+	char devmajor[8];			/* 329 */
+	char devminor[8];			/* 337 */
+	char prefix[151];			/* 345 */
+	unsigned int offset;			/* 496 Offset of the file in the archive */
+	unsigned int textOffset;		/* 500 Offset of the text section in the file */
+	unsigned int textSize;			/* 504 Size of text section */
+	unsigned int numFixupPgs;		/* 508 Number of pages affected by relocation */
+						/* 512 */
+};
+
+#define VTARFS_HDR_SIZE (sizeof(struct vtarfs_header_type))
+static_assert(VTARFS_HDR_SIZE == 512);
+
+struct vtarfs_entry {
+	struct vtarfs_header_type	header;
+	char				*dir_name;
+	char				*base_name;
+	char				*link_name;
+	unsigned int			offset;
+	unsigned int			data_offset;
+	unsigned int			num_pages;
+	struct page			**pages;
+	size_t				data_size;
+	unsigned long			inode;
+	struct inode			*ptr_inode;
+	umode_t				mode;
+	uid_t				uid;
+	gid_t				gid;
+	struct timespec64		atime;
+	struct timespec64		mtime;
+	struct timespec64		ctime;
+	unsigned int			fileoffset;  // Offset of the file in the archive
+	unsigned int			textOffset;  // Offset of the text section in the file
+	unsigned int			textSize;    // Size of text section
+	unsigned int			numFixupPgs; // Number of pages affected by relocation
+	struct vtarfs_entry		*next;
+	struct radix_tree_root		root_tree;
+	unsigned long			radix_root_key;
+};
+
+struct vtarfs_fs_info {
+	struct vtarfs_entry		*fs_entry;
+	struct vtarfs_img_map_t		vtarfs_img_map;
+	struct vtarfs_mount_opts	mount_opts;
+	unsigned long			root_ino;
+};
+
+static inline struct vtarfs_fs_info *VTARFS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+extern int vtarfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl);
+extern int vtarfs_file_release(struct inode *inode, struct file *file);
+extern int vtarfs_getattr(struct mnt_idmap *idmap, const struct path *path,
+			  struct kstat *stat, u32 request_mask, unsigned int flags);
+extern int vtarfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode);
+extern int vtarfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev);
+extern int vtarfs_physmem_mmap(struct file *file, struct vm_area_struct *vma);
+extern int vtarfs_read_dir(struct file *file, struct dir_context *ctx);
+extern mode_t vtarfs_entry_mode(struct vtarfs_entry *entry);
+extern ssize_t vtarfs_file_read_iter(struct kiocb *iocb, struct iov_iter *to);
+extern struct  dentry  *vtarfs_lookup(struct inode *inode,
+				      struct dentry *dentry, unsigned int flags);
+extern vm_fault_t vtarfs_fault_handler(struct vm_fault *vmf);
+extern struct vtarfs_entry *vtarfs_find(struct vtarfs_entry *entry,
+					const char *dir_name, const char *base_name);
+
+static const struct file_operations vtarfs_file_operations = {
+	.llseek   = generic_file_llseek,
+	.read_iter     = vtarfs_file_read_iter,
+	.mmap     = vtarfs_physmem_mmap,
+	.open     = generic_file_open,
+	.release  = vtarfs_file_release,
+};
+
+static const struct inode_operations vtarfs_file_inode_operations = {
+	.getattr = vtarfs_getattr,
+};
+
+static const struct inode_operations vtarfs_dir_inode_operations = {
+	.lookup = vtarfs_lookup,
+	.getattr = vtarfs_getattr,
+};
+
+static const struct inode_operations vtarfs_symlink_inode_operations = {
+	.get_link = simple_get_link,
+	.getattr = vtarfs_getattr,
+};
+
+static const struct file_operations vtarfs_dir_operations = {
+	.open = dcache_dir_open,
+	.release = dcache_dir_close,
+	.llseek	= dcache_dir_lseek,
+	.read = generic_read_dir,
+	.iterate_shared = vtarfs_read_dir,
+	.fsync = noop_fsync,
+};
+
+static const struct vm_operations_struct vtarfs_ops = {
+	.fault	=	vtarfs_fault_handler,
+};
+
+#endif
diff --git a/fs/vtarfs/vtarfs_file_dir_ops.c b/fs/vtarfs/vtarfs_file_dir_ops.c
new file mode 100644
index 000000000..191b5b84d
--- /dev/null
+++ b/fs/vtarfs/vtarfs_file_dir_ops.c
@@ -0,0 +1,472 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Filesystem to directly mount vtar archive.
+ *
+ * Copyright 2020 VMware, Inc. All Rights Reserved.
+ *
+ * Licensed under the GNU Lesser General Public License version 2 (the "License");
+ * you may not use this file except in compliance with the License. The terms
+ * of the License are located in the LICENSE file of this distribution.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/backing-dev.h>
+#include <linux/pagevec.h>
+#include <linux/mman.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uio.h>
+#include <linux/pfn_t.h>
+#include <linux/mm.h>
+#include <linux/mm_types.h>
+#include <linux/uaccess.h>
+#include <linux/radix-tree.h>
+
+#include "vtarfs.h"
+
+#define WRITE_MASK (0222)
+
+mode_t tar_type_to_posix(int typeflag)
+{
+	switch (typeflag) {
+	case REGTYPE:
+	case AREGTYPE:
+	case TAR_TYPE_SHAREDFILE:
+		return S_IFREG;
+	case DIRTYPE:
+		return S_IFDIR;
+	case SYMTYPE:
+		return S_IFLNK;
+	case CHRTYPE:
+		return S_IFCHR;
+	case BLKTYPE:
+		return S_IFBLK;
+	case FIFOTYPE:
+		return S_IFIFO;
+
+	default:
+		return 0;
+	}
+}
+
+/**
+ * @brief Returns the POSIX file mode of \a entry.
+ * @param entry the entry to get the file mode from
+ * @return the file mode
+ */
+mode_t vtarfs_entry_mode(struct vtarfs_entry *entry)
+{
+	mode_t mode = entry->mode & ~WRITE_MASK;
+
+	mode |= tar_type_to_posix(entry->header.typeflag);
+	return mode;
+}
+EXPORT_SYMBOL(vtarfs_entry_mode);
+
+/**
+ * @brief Returns the vtarfs entry by searching based on inode number.
+ * @param  entry: Pointer to the ROOT entry of vtarfs
+	   inode: inode number which is mapped to the entry to be found.
+ * @return the vtarfs entry containing the inode number.
+ */
+static struct
+vtarfs_entry *vtarfs_find_by_inode(struct vtarfs_entry *entry,
+				   unsigned long inode)
+{
+	struct vtarfs_entry *entry_node = NULL;
+	struct radix_tree_iter iter;
+	void **slot = NULL;
+
+	tarfs_debug("In vtarfs_find_by_node, inode = %ld", inode);
+
+	radix_tree_for_each_slot(slot, &entry->root_tree, &iter, 0) {
+		entry_node = radix_tree_deref_slot(slot);
+		if (unlikely(!entry_node))
+			continue;
+
+		if (radix_tree_exception(entry_node)) {
+			if (radix_tree_deref_retry(entry_node))
+				slot = radix_tree_iter_retry(&iter);
+			continue;
+		}
+
+		if (inode == entry_node->inode) {
+			tarfs_debug("\n FOUND %ld\n", entry_node->inode);
+			return entry_node;
+		}
+	}
+	return NULL;
+}
+
+/**
+ * @brief Returns the vtarfs entry by searching based on name of the file.
+ * @param  entry: Pointer to the ROOT entry of vtarfs
+	   dir_name: Directory name/path in which the file resides.
+	   base_name: Name of the file.
+ * @return the vtarfs entry containing the name.
+ */
+struct
+vtarfs_entry *vtarfs_find(struct vtarfs_entry *entry,
+			const char *dir_name, const char *base_name)
+{
+	struct vtarfs_entry *entry_node = NULL;
+	struct radix_tree_iter iter;
+	void **slot = NULL;
+
+	radix_tree_for_each_slot(slot, &entry->root_tree, &iter, 0) {
+
+		entry_node = radix_tree_deref_slot(slot);
+		if (unlikely(!entry_node))
+			continue;
+
+		if (radix_tree_exception(entry_node)) {
+			if (radix_tree_deref_retry(entry_node))
+				slot = radix_tree_iter_retry(&iter);
+
+			continue;
+		}
+
+		if (!strcmp(entry_node->base_name, base_name) &&
+		    !strcmp(entry_node->dir_name, dir_name)) {
+			return entry_node;
+		}
+
+	}
+	return NULL;
+}
+
+/*
+ * @brief Returns the Full name of a file by combining path and file name.
+ * @param  entry: Pointer to the entry of vtarfs file
+ * @return the full name.
+ */
+static char *vtarfs_full_name(struct vtarfs_entry *entry)
+{
+	size_t dir_len = strlen(entry->dir_name);
+	size_t base_len = strlen(entry->base_name);
+	size_t len = dir_len + base_len + 2;
+	char *name = kzalloc(len, GFP_KERNEL);
+
+	if (!name) {
+		pr_err("\n Error in allocating memory for name %ld\n",
+				PTR_ERR(name));
+		return NULL;
+	}
+
+	/* Ignore the first / for a top level directory */
+	if (dir_len < 1)
+		strncpy(name, entry->base_name, base_len);
+	else if (dir_len == 1)
+		strncpy(name, entry->dir_name, dir_len);
+	else
+		snprintf(name, len, "%s/%s", entry->dir_name, entry->base_name);
+
+	tarfs_debug("found name = %s", name);
+
+	return name;
+}
+
+/*
+ * @brief Returns the Full name of a file based on inode number.
+ * @param  root_entry: Pointer to the ROOT entry of vtarfs file
+ *	   inode: inode pointer of the vtarfs file.
+ * @return the full name.
+ */
+static char *build_lookup_path(struct inode *inode, struct vtarfs_entry *root_entry)
+{
+	struct vtarfs_entry *entry = NULL;
+	struct vtarfs_fs_info *info = VTARFS_SB(root_entry->ptr_inode->i_sb);
+
+	tarfs_debug("i_ino = %ld", inode->i_ino);
+	if (inode->i_ino == info->root_ino)
+		return kzalloc(1, GFP_KERNEL);
+
+	entry = vtarfs_find_by_inode(root_entry, inode->i_ino);
+	if (!entry) {
+		pr_err("\n Failed to find inode by entry, root->entry = %s\n",
+				root_entry->base_name);
+		return NULL;
+	}
+
+	tarfs_debug("full_name = %s%s ", entry->dir_name, entry->base_name);
+	return vtarfs_full_name(entry);
+}
+
+/*
+ * @brief Ignore all pos beyond file size
+ * @pararm inode: Pointer to inode of the directory
+ *         ctx_pos: requested pos to check
+ * @return non-zero if requested pos is less than the size of inode
+ *         else zero
+ */
+static int beyond_eof(struct inode *inode, loff_t ctx_pos)
+{
+	loff_t pos = ctx_pos << inode->i_sb->s_blocksize_bits;
+
+	return pos >= i_size_read(inode);
+}
+
+/*
+ * @brief Emits the contents of a directory.
+ * @param  file: file pointer of a directory
+ *	   ctx: context of fs on how dir entries will be filled.
+ * @return 0 on SUCCESS negetive errno on failure.
+ */
+int vtarfs_read_dir(struct file *file, struct dir_context *ctx)
+{
+	struct inode *inode = file_inode(file);
+	struct vtarfs_fs_info *info = VTARFS_SB(inode->i_sb);
+	struct vtarfs_entry *entry = info->fs_entry;
+	char *dir_path;
+	int namelen = 0;
+
+	if (beyond_eof(inode, ctx->pos))
+		return 0;
+	/* Loop through the entry to find matching entry node with inode */
+	if (!dir_emit_dots(file, ctx)) {
+		pr_err("%s: %lld", __func__, ctx->pos);
+		return 0;
+	}
+	tarfs_debug("[%lld] [%d] [%lld]", ctx->pos,
+			inode->i_sb->s_blocksize_bits, inode->i_size);
+	dir_path = build_lookup_path(inode, entry);
+	if (!dir_path) {
+		pr_err("%s: Failed to get dir path %ld", __func__, PTR_ERR(dir_path));
+		return -ENOENT;
+	}
+	tarfs_debug("dir_path=%s", dir_path);
+
+	while (entry) {
+		tarfs_debug("dir_path=%s entry->dir_name = %s base_name=%s",
+				dir_path, entry->dir_name, entry->base_name);
+		if (!strcmp(dir_path, entry->dir_name)) {
+			/* Print all sub dirs by iterating through entry */
+			namelen = strlen(entry->base_name);
+			if (!dir_emit(ctx, entry->base_name, namelen,
+					entry->inode, (entry->mode >> 12))) {
+				break;
+			}
+			ctx->pos++;
+		}
+		entry = entry->next;
+	}
+	tarfs_debug("return dir_path=%s", dir_path);
+	kfree(dir_path);
+	return 0;
+}
+EXPORT_SYMBOL(vtarfs_read_dir);
+
+/*
+ * @brief lookup function to iterate through the contents of a directory.
+ * @param  dir: inode pointer of a directory
+ *	   dentry: dentry information of the entry of a file or sub dir.
+ *	   flags: Currently unused.
+ * @return dentry of the file or sub dir.
+ */
+struct	dentry
+*vtarfs_lookup(struct inode *dir, struct dentry *dentry,
+					unsigned int flags)
+{
+	struct vtarfs_entry *found_entry = NULL;
+	char *dir_path = NULL;
+	struct inode *build_inode = NULL;
+	struct vtarfs_fs_info *info;
+	struct vtarfs_entry *entry;
+
+	tarfs_debug("entry");
+
+	if (!dir->i_sb) {
+		pr_err("%s: Error Missing superblock", __func__);
+		return NULL;
+	}
+
+	info = VTARFS_SB(dir->i_sb);
+	entry = info->fs_entry;
+	dir_path = build_lookup_path(dir, entry);
+
+	found_entry = vtarfs_find(entry, dir_path, dentry->d_name.name);
+
+	if (found_entry) {
+		build_inode = found_entry->ptr_inode;
+		tarfs_debug("found entry->name = %s%s & entry->inode = %ld",
+			found_entry->dir_name, found_entry->base_name,
+			found_entry->inode);
+	} else {
+		tarfs_debug("Dir entry not found %s", dir_path);
+	}
+	kfree(dir_path);
+
+	tarfs_debug("ends dir_path=%s", dir_path);
+	return d_splice_alias(build_inode, dentry);
+}
+EXPORT_SYMBOL(vtarfs_lookup);
+
+/*
+ * @brief Get attributes of a file or dir.
+ * @param  path: real path of the file or directory.
+ *	   stat: pointer to stat structure to be filled.
+ *	   request_mask: Currently unused.
+ *	   flags: Currently unused.
+ * @return dentry of the file or sub dir.
+ */
+int vtarfs_getattr(struct mnt_idmap *idmap, const struct path *path,
+		   struct kstat *stat, u32 request_mask, unsigned int flags)
+{
+
+	struct inode *inode = d_inode(path->dentry);
+
+	generic_fillattr(&nop_mnt_idmap, request_mask, inode, stat);
+	if (stat->blocks == 0)
+		stat->blocks = inode->i_mapping->nrpages << (PAGE_SHIFT - 9);
+
+	return 0;
+}
+EXPORT_SYMBOL(vtarfs_getattr);
+
+/*
+ * @brief Iteratively read a file using IO Vectors..
+ * @param  iocb: iov object.
+ *	   to: info about the stage of iteration.
+ * @return number of bytes read.
+ */
+ssize_t vtarfs_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
+{
+	struct file *file = iocb->ki_filp;
+	struct inode *inode  = file_inode(file);
+	struct vtarfs_fs_info *info = VTARFS_SB(inode->i_sb);
+	struct vtarfs_entry *root_entry = info->fs_entry;
+	struct vtarfs_entry *entry;
+	ssize_t count;
+	loff_t pos = iocb->ki_pos;
+	ssize_t res = 0, copy = 0;
+	off_t pg_off;
+	int size = 0, i = 0, start = 0, end = 0;
+
+	entry = vtarfs_find_by_inode(root_entry, inode->i_ino);
+	if (!entry) {
+		pr_err("%s: No entry found for the file ", __func__);
+		return -ENOENT;
+	}
+	count = min_t(size_t, iov_iter_count(to), entry->data_size - pos);
+	if (pos < 0)
+		return -EINVAL;
+	if (pos >= entry->data_size || !count) {
+		tarfs_debug("File read complete pos=%llu size=%ld\n",
+				pos, entry->data_size);
+		return 0;
+	}
+	if (count > (entry->data_size - pos))
+		count = entry->data_size - pos;
+
+	size = count;
+	start = pos >> PAGE_SHIFT;
+	end = ((pos + count) >> PAGE_SHIFT);
+
+	tarfs_debug("count = %ld, page[%d] = %p\n", count, start,
+						entry->pages[start]);
+
+	for (i = start; i <= end && size > 0; i++) {
+		pg_off = pos % PAGE_SIZE;
+		copy = min_t(size_t, size, PAGE_SIZE - pg_off);
+		tarfs_debug("pg_off = %ld, copy = %ld, page[%d]=%p",
+				pg_off, copy, i, entry->pages[i]);
+		res = copy_page_to_iter(entry->pages[i], pg_off, copy, to);
+		pos += res;
+		size -= res;
+	}
+	if (count == size)
+		pr_err("%s: Failed to read any bytes %d\n", __func__, size);
+
+	iocb->ki_pos += (count - size);
+	tarfs_debug("Return count=%ld res=%d", count, size);
+	return (count - size);
+}
+EXPORT_SYMBOL_GPL(vtarfs_file_read_iter);
+
+/*
+ * @brief Handle page fault for executables.
+ * @param  vmf: fault info
+ * @return FAULT state.
+ */
+vm_fault_t vtarfs_fault_handler(struct vm_fault *vmf)
+{
+	struct inode *inode = file_inode(vmf->vma->vm_file);
+	struct vtarfs_fs_info *info = VTARFS_SB(inode->i_sb);
+	struct vtarfs_entry *entry, *root_entry = info->fs_entry;
+
+	entry = vtarfs_find_by_inode(root_entry, inode->i_ino);
+	if (!entry) {
+		pr_err("%s: No entry found for the file ", __func__);
+		return -ENOENT;
+	}
+
+	tarfs_debug("[%s][%s][%ld][%lu][%u][%lu]",
+		entry->dir_name, entry->base_name, inode->i_ino,
+		inode->i_mapping->nrpages, entry->fileoffset, vmf->vma->vm_pgoff);
+
+	if (vmf->pgoff > inode->i_mapping->nrpages) {
+		pr_err("%s: Exceed number of pages %ld > %ld", __func__,
+			vmf->pgoff, inode->i_mapping->nrpages);
+		return -EFAULT;
+	}
+
+	vmf->page = pagecache_get_page(info->vtarfs_img_map.tarfs_img_map,
+			(entry->fileoffset >> PAGE_SHIFT) + vmf->pgoff, 0, 0);
+
+	return VM_FAULT_LOCKED;
+}
+EXPORT_SYMBOL(vtarfs_fault_handler);
+
+/*
+ * @brief mmap handler of vtarfs.
+ * @param  file: file pointer of the file which needs to be mmapped
+ *	   vma: vma_area info
+ * @return 0 on SUCCESS, negetive errno on FAILURE.
+ */
+int vtarfs_physmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct inode *inode = file_inode(file);
+	int ret = 0;
+
+	tarfs_debug("[%ld] [%ld] [%lu]", inode->i_ino,
+		inode->i_mapping->nrpages, vma->vm_pgoff);
+
+	if (vma->vm_pgoff > inode->i_mapping->nrpages) {
+		tarfs_debug("num_pages=%ld > pgoff=%lu",
+				inode->i_mapping->nrpages, vma->vm_pgoff);
+		return 0;
+	}
+
+	file->f_mapping->a_ops = &ram_aops;
+	ret = generic_file_readonly_mmap(file, vma);
+	if (ret)
+		pr_err("%s: Failed to do generic mmap %d\n", __func__, ret);
+
+	vma->vm_ops = &vtarfs_ops;
+	tarfs_debug("[%p]", vma->vm_file);
+	return 0;
+}
+EXPORT_SYMBOL(vtarfs_physmem_mmap);
+
+/*
+ * @brief close call handler for a file.
+ * @param  inode: inode pointer of the file
+ *	   file: file pointer of the file
+ * @return 0 on SUCCESS, negetive errno on FAILURE.
+ */
+int vtarfs_file_release(struct inode *inode, struct file *file)
+{
+
+	/* TODO: do kfree of cache and other data here */
+
+	return 0;
+
+}
+EXPORT_SYMBOL(vtarfs_file_release);
diff --git a/fs/vtarfs/vtarfs_inode.c b/fs/vtarfs/vtarfs_inode.c
new file mode 100644
index 000000000..206d12ed7
--- /dev/null
+++ b/fs/vtarfs/vtarfs_inode.c
@@ -0,0 +1,773 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Filesystem to directly mount vtar archive.
+ *
+ * Copyright 2020 VMware, Inc. All Rights Reserved.
+ *
+ * Licensed under the GNU Lesser General Public License version 2 (the "License");
+ * you may not use this file except in compliance with the License. The terms
+ * of the License are located in the LICENSE file of this distribution.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/pagemap.h>
+#include <linux/pfn_t.h>
+#include <linux/ramfs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/parser.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/super.h>
+#include <linux/slab.h>
+#include <linux/vfs.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/cred.h>
+
+#include "vtarfs.h"
+
+/* ALIGNS of a 512 byte boundary */
+#define ALIGN_SECTOR(x) (((x) % 512 > 0) ? 512 - ((x) % 512) : 0)
+
+
+/* TODO: implement show_options */
+static struct super_operations vtarfs_super_ops = {
+	.statfs         = simple_statfs,
+	//.show_options   = vtarfs_show_options,
+};
+
+/*
+ * vtarfs_get_inode : Allocate inode for ROOT Node
+ * sb : Superblock of the file system
+ * dir : inode of directory of ROOT
+ * mode : Permissions
+ * dev : nodev (NON BLOCK based device)
+ */
+struct inode *vtarfs_get_inode(struct super_block *sb,
+		const struct inode *dir, umode_t mode, dev_t dev)
+{
+
+	struct inode *inode = new_inode(sb);
+	struct vtarfs_fs_info *info = VTARFS_SB(sb);
+	struct timespec64 ts;
+
+	if (inode) {
+		INIT_HLIST_NODE(&inode->i_hash);
+		pr_debug("%s inode created !!", __func__);
+		inode->i_ino = get_next_ino();
+		info->root_ino = inode->i_ino;
+		inode->i_mode = mode;
+		inode->i_uid = current_fsuid();
+		inode->i_gid = current_fsgid();
+		ts = current_time(inode);
+		inode_set_atime_to_ts(inode, ts);
+		inode_set_mtime_to_ts(inode, ts);
+		inode_set_ctime_to_ts(inode, ts);
+		inode->i_mapping->a_ops = &ram_aops;
+		mapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);
+		mapping_set_unevictable(inode->i_mapping);
+		inode->i_sb = sb;
+		inode->i_size = sb->s_blocksize;
+		inode->i_blocks = (inode->i_size + (1 << 9) - 1) >> 9;
+
+		inode->i_op = &vtarfs_dir_inode_operations;
+		inode->i_fop = &vtarfs_dir_operations;
+		inode_init_owner(&nop_mnt_idmap, inode, NULL, S_IFDIR | 0555);
+
+		/*directory inodes start off with i_nlink=2(for "." entry)*/
+		inc_nlink(inode);
+		inc_nlink(inode);
+	}
+	tarfs_debug("returning inode !!\n");
+	return inode;
+
+}
+
+static char *build_dir_path(const char *link_path, char **link_name)
+{
+	char *dir_path;
+	char *name;
+	int len;
+
+	name = strrchr(link_path, '/');
+	name = (name) ? (name + 1) : (char *)(link_path);
+	*link_name = name;
+	len = strlen(link_path) - strlen(name);
+	len = (len > 0) ? (len) : (1);
+	dir_path = kzalloc(len, GFP_KERNEL);
+	if (!dir_path) {
+		pr_err("%s: Error in allocating memory for dir_path %ld",
+			__func__, PTR_ERR(dir_path));
+		return NULL;
+	}
+	memcpy(dir_path, link_path, len - 1);
+	tarfs_debug("dir_path=[%s]", dir_path);
+	return dir_path;
+}
+
+/*
+ * vtarfs_create_inode : Allocate inode for file, dir and symlinks
+ * sb : Superblock of the file system
+ * entry : vtarfs entry of ROOT
+ * mode : Permissions
+ */
+struct inode *vtarfs_create_inode(struct super_block *sb,
+				  struct vtarfs_entry *entry, umode_t mode)
+{
+
+	struct inode *inode = NULL;
+	struct inode *dentry_inode = d_inode(sb->s_root);
+	struct vtarfs_entry *link_entry = NULL;
+	char *link_name = NULL;
+	char *link_dir_path = NULL;
+
+	inode = new_inode(sb);
+	if (!inode) {
+		pr_err("%s: Failed to allocate new inode\n", __func__);
+		return NULL;
+	}
+	INIT_HLIST_NODE(&inode->i_hash);
+	tarfs_debug("entry");
+
+	inode->i_ino = get_next_ino();
+	entry->inode = inode->i_ino;
+	tarfs_debug("inode create = %ld", entry->inode);
+	inode->i_mode = vtarfs_entry_mode(entry);
+	i_uid_write(inode, entry->uid);
+	i_gid_write(inode, entry->gid);
+	inode->i_size = entry->data_size;
+	inode_set_atime_to_ts(inode, entry->atime);
+	inode_set_mtime_to_ts(inode, entry->mtime);
+	inode_set_ctime_to_ts(inode, entry->ctime);
+	inode->i_sb = sb;
+	inode->i_mapping->a_ops = &ram_aops;
+	mapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);
+	mapping_set_unevictable(inode->i_mapping);
+	inode->i_mapping->nrpages = entry->num_pages;
+	/* measure inode.i_blocks as the generic filesystem */
+	inode->i_blocks = (inode->i_size + (1 << 9) - 1) >> 9;
+	__insert_inode_hash(inode, dentry_inode->i_ino);
+	entry->ptr_inode = inode;
+	switch (entry->header.typeflag) {
+	case DIRTYPE:
+		inode->i_op = &vtarfs_dir_inode_operations;
+		inode->i_fop = &vtarfs_dir_operations;
+		if (inode->i_size == 0)
+			inode->i_size = sb->s_blocksize;
+		inode->i_blocks = (inode->i_size + (1 << 9) - 1) >> 9;
+		inc_nlink(inode);
+		break;
+	case LNKTYPE:
+		link_dir_path = build_dir_path(entry->link_name, &link_name);
+		if (link_dir_path) {
+			link_entry = vtarfs_find(VTARFS_SB(sb)->fs_entry, link_dir_path, link_name);
+			kfree(link_dir_path);
+		}
+		tarfs_debug("HARDLINK: [%s] [%s] [%s]",
+				entry->link_name, link_dir_path, link_name);
+		if (link_entry) {
+			tarfs_debug("HARDLINK: [%s]->[%ld]",
+					link_entry->base_name, link_entry->inode);
+			entry->inode = link_entry->inode;
+			entry->ptr_inode = link_entry->ptr_inode;
+		} else {
+			pr_err("%s: HARDLINK: Fail to find the linked file entry!! [%s] [%s] [%s]",
+					__func__, entry->link_name, link_dir_path, link_name);
+		}
+		break;
+	case SYMTYPE:
+		inode->i_op = &vtarfs_symlink_inode_operations;
+		inode->i_link = entry->link_name;
+		inode->i_size = strlen(inode->i_link);
+		inode_nohighmem(inode);
+		break;
+	default:
+		inode->i_op = &vtarfs_file_inode_operations;
+		inode->i_fop = &vtarfs_file_operations;
+		break;
+	}
+	tarfs_debug("Returing");
+	return inode;
+}
+
+static char *build_name(struct vtarfs_header_type *header, char *longname, char type)
+{
+	char *name = longname;
+	char *src = header->name;
+	char *prefix_end = memchr(header->prefix, 0, sizeof(header->prefix));
+	size_t prefix_len;
+	size_t name_len;
+	char *name_end = NULL;
+
+	if (!prefix_end) {
+		pr_err("%s : Header name is not proper, prefix_end is NULL!!", __func__);
+		return NULL;
+	}
+
+	prefix_len = prefix_end - header->prefix;
+	if (type == TAR_TYPE_GNU_LONGNAME) {
+		name_len = strlen(longname);
+		src = longname;
+		tarfs_debug("[%ld] [%ld] [%c] [%s] [%s]",
+			prefix_len, name_len, type, header->prefix, longname);
+	} else {
+		name_end = memchr(header->name, 0, sizeof(header->name));
+		if (!name_end) {
+			pr_err("%s: Header name is not proper [%s][%ld][%ld], name_end is NULL!!",
+				__func__, header->name, sizeof(header->name), strlen(header->name));
+			/*
+			 * Handle the case where header->name is exact 100 bytes long and
+			 * thus there is no '\0' char and mode bytes gets appended to header->name
+			 */
+			if (strlen(header->name) > sizeof(header->name) &&
+			    !memcmp(header->name + sizeof(header->name),
+				    header->mode, sizeof(header->mode))) {
+				pr_info("%s: Header name is exact 100 bytes long!! Handling it properly!!",
+					__func__);
+				name_end = header->name + sizeof(header->name);
+			} else {
+				return NULL;
+			}
+		}
+		name_len = name_end - header->name;
+		tarfs_debug("[%ld] [%ld] [%c] [%s] [%s]",
+			prefix_len, name_len, header->typeflag, header->prefix, header->name);
+	}
+	if (prefix_len != 0 || type != TAR_TYPE_GNU_LONGNAME) {
+		name = kzalloc(prefix_len + name_len + 1, GFP_KERNEL);
+		if (!name) {
+			pr_err("%s: Unable to allocate memory for full name\n", __func__);
+			return NULL;
+		}
+		memcpy(name, header->prefix, prefix_len);
+		memcpy(name + prefix_len, src, name_len);
+		if (type == TAR_TYPE_GNU_LONGNAME)
+			kfree(longname);
+		name[prefix_len + name_len] = 0x0;
+	}
+
+
+	// The path name ends with a slash if the entry is a directory
+	if (name[prefix_len + name_len - 1] == '/')
+		name[prefix_len + name_len - 1] = 0x0;
+
+	return name;
+
+}
+
+/**
+ * @brief Reads a tar header at the \a offset.
+ * @param info the fs_iinfo to read from
+ * @param offset the 512-byte aligned offset
+ * @param header the 512 bytes buffer to fill
+ * @return 0 on success, else 1
+ */
+static int vtarfs_read_header(struct vtarfs_fs_info *info, off_t offset,
+					struct vtarfs_header_type *header)
+{
+	struct page *page = NULL;
+	void *k_mapped_page = NULL;
+
+	page = read_mapping_page(info->vtarfs_img_map.tarfs_img_map,
+					offset >> PAGE_SHIFT, NULL);
+	if (IS_ERR(page)) {
+		pr_err("%s: page map failure %ld", __func__, PTR_ERR(page));
+		return 1;
+	}
+
+	k_mapped_page = kmap(page);
+	if (!k_mapped_page) {
+		pr_err("%s: kmap failure %ld", __func__, PTR_ERR(k_mapped_page));
+		goto error;
+	}
+	if (memcpy(header, k_mapped_page + (offset % PAGE_SIZE),
+			sizeof(struct vtarfs_header_type)) == NULL) {
+		pr_err("%s: read failure", __func__);
+		kunmap(k_mapped_page);
+		goto error;
+	}
+	kunmap(k_mapped_page);
+	put_page(page);
+	return 0;
+
+error:
+	put_page(page);
+	return 1;
+}
+
+/**
+ * @brief Reads a tar header at the \a offset.
+ * @param sb the superblock to read from
+ * @param offset the 512-byte aligned offset
+ * @return the entry on success, else \c NULL
+ */
+struct
+vtarfs_entry *vtarfs_read_entry(struct super_block *sb,
+			off_t offset)
+{
+	struct vtarfs_fs_info *info = VTARFS_SB(sb);
+	struct vtarfs_header_type header;
+	struct vtarfs_entry *entry = NULL;
+	char *full_name = NULL, *basename = NULL, *longname = NULL;
+	size_t namelen = 0;
+	size_t curlen = 0;
+	char typeflag = 0;
+	struct timespec64 mtime;
+	int i = 0;
+
+	tarfs_debug("offset = %ld and img_map = %p", offset,
+			info->vtarfs_img_map.tarfs_img_map);
+
+	if (vtarfs_read_header(info, offset, &header) != 0) {
+		pr_err("%s: Header data reading fails!!", __func__);
+		return NULL;
+	}
+	tarfs_debug("Header Data:\n"
+			"header.name = [%s]\n"
+			"header.mode = [%s]\n"
+			"header.uid = [%s]\n"
+			"header.gid = [%s]\n"
+			"header.size = [%s]\n"
+			"header.mtime = [%s]\n"
+			"header.chksum = [%s]\n"
+			"header.typeflag = [%c]\n"
+			"header.linkname = [%s]\n"
+			"header.magic = [%s]\n"
+			"header.version = [%s]\n"
+			"header.uname = [%s]\n"
+			"header.gname = [%s]\n"
+			"header.devmajor = [%s]\n"
+			"header.devminor = [%s]\n"
+			"header.prefix = [%s]\n"
+			"header.offset = [%u]\n"
+			"header.textOffset = [%u]\n"
+			"header.textSize = [%u]\n"
+			"header.numFixupPgs = [%u]\n",
+		header.name, header.mode, header.uid, header.gid, header.size,
+		header.mtime, header.chksum, header.typeflag, header.linkname,
+		header.magic, header.version, header.uname, header.gname,
+		header.devmajor, header.devminor, header.prefix, header.offset,
+		header.textOffset, header.textSize, header.numFixupPgs);
+	if (header.typeflag == TAR_TYPE_GNU_LONGLINK || header.typeflag == TAR_TYPE_GNU_LONGNAME) {
+		/**
+		 * 512-byte header.... [@LongLink/LongName]
+		 *                       typeflag=K/L hdr.size=strlen(LongName/LongLink)
+		 * 512-byte header.... [Read LongName/LongLink]
+		 * ...                 [Read again 512-bytes header if Name more than 512-bytes ]
+		 * 512-byte header.... [Actual header data, replace hdr.name with @LongName if [L]
+		 *                       else replace hdr.linkname with @LongLink if [K]]
+		 **/
+		if (kstrtouint(header.size, 8, (unsigned int *)&namelen) !=
+									0) {
+			pr_err("%s: failed to read size", __func__);
+			return NULL;
+		}
+		typeflag = header.typeflag;
+		longname = kzalloc(namelen + 1, GFP_KERNEL);
+		if (IS_ERR_OR_NULL(longname)) {
+			pr_err("%s:Error in allocating mem for longname %ld\n",
+				__func__, PTR_ERR(longname));
+			return NULL;
+		}
+		while (curlen < namelen) {
+			offset = offset + VTARFS_HDR_SIZE +
+					ALIGN_SECTOR(VTARFS_HDR_SIZE);
+			if (vtarfs_read_header(info, offset, &header) != 0) {
+				pr_err("%s: Header data reading fails!!", __func__);
+				goto err_lvl1;
+			}
+			memcpy(longname + curlen, &header, MIN(namelen - curlen, VTARFS_HDR_SIZE));
+			curlen += VTARFS_HDR_SIZE;
+			tarfs_debug("longname=[%s] len=[%lu] type=[%c]",
+				longname, namelen, typeflag);
+		}
+		offset = offset + VTARFS_HDR_SIZE +
+				ALIGN_SECTOR(VTARFS_HDR_SIZE);
+		if (vtarfs_read_header(info, offset, &header) != 0) {
+			pr_err("%s: Header data reading fails!!", __func__);
+			goto err_lvl1;
+		}
+	}
+
+	// Check for the header magic value
+	if (memcmp(header.magic, vtarfs_MAGIC,
+			sizeof(header.magic)) != 0) {
+		pr_err("%s: magic=%s", __func__, header.magic);
+		goto err_lvl1;
+	}
+	entry = kzalloc(sizeof(struct vtarfs_entry), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(entry)) {
+		pr_err("%s: Error in allocating mem for entry %ld\n",
+			__func__, PTR_ERR(entry));
+		goto err_lvl1;
+	}
+	// Parse the data length from the header
+	if (kstrtouint(header.size, 8, (unsigned int *)&entry->data_size) != 0) {
+		pr_err("%s: failed to read size", __func__);
+		goto err_lvl2;
+	}
+	if (kstrtouint(header.mode, 8, (unsigned int *)&entry->mode) != 0) {
+		pr_err("%s: failed to read mode, mode=%s", __func__, header.mode);
+		// Setting default mode as r+w+x for all user
+		entry->mode = 0777;
+	}
+	if (kstrtouint(header.uid, 8, (unsigned int *)&entry->uid) != 0) {
+		pr_err("%s: failed to read uid, uid=%s", __func__, header.uid);
+		// Setting default uid as nobody
+		entry->uid = 0xfffe;
+	}
+	if (kstrtouint(header.gid, 8, (unsigned int *)&entry->gid) != 0) {
+		pr_err("%s: failed to read gid, gid=%s", __func__, header.gid);
+		// Setting default gid as nobody
+		entry->uid = 0xfffd;
+	}
+	if (kstrtoul(header.mtime, 8, (unsigned long *)&mtime.tv_sec) != 0) {
+		mtime.tv_sec = 0;
+		mtime.tv_nsec = 0;
+	}
+	entry->mtime = mtime;
+	entry->atime = mtime;
+	entry->ctime = mtime;
+	entry->fileoffset = header.offset;
+	entry->textOffset = header.textOffset;
+	entry->textSize = header.textSize;
+	entry->numFixupPgs = header.numFixupPgs;
+
+	entry->num_pages = entry->data_size >> PAGE_SHIFT;
+	if (entry->data_size % PAGE_SIZE)
+		entry->num_pages++;
+
+	entry->pages = kzalloc((sizeof(struct page *) * (entry->num_pages)),
+							GFP_KERNEL);
+	if (IS_ERR_OR_NULL(entry->pages)) {
+		pr_err("%s:Error in allocating mem for pages %ld\n",
+			__func__, PTR_ERR(entry->pages));
+		goto err_lvl2;
+	}
+	pr_debug("%s: After getting page maps, num = %d, fileoffset = %d ",
+			__func__, entry->num_pages, entry->fileoffset);
+	for (i = 0; i < entry->num_pages; i++) {
+		entry->pages[i] = read_mapping_page(
+					info->vtarfs_img_map.tarfs_img_map,
+				(entry->fileoffset >> PAGE_SHIFT) + i, NULL);
+		if (IS_ERR(entry->pages[i])) {
+			pr_err("%s: page map failure %ld",
+				__func__, PTR_ERR(entry->pages[i]));
+			goto err_lvl3;
+		}
+	}
+
+	full_name = build_name(&header, longname, typeflag);
+	if (!full_name) {
+		pr_err("%s: name allocation error", __func__);
+		goto err_lvl3;
+	}
+	basename = strrchr(full_name, '/');
+	if (basename) {
+		*basename = 0x0;
+		basename++;
+	} else {
+		basename = full_name;
+		full_name = basename + strlen(basename);
+	}
+	entry->dir_name = full_name;
+	entry->base_name = basename;
+	entry->header = header;
+	entry->link_name = (typeflag == TAR_TYPE_GNU_LONGLINK) ? longname : entry->header.linkname;
+	tarfs_debug("full_name = [%s] [%s] linkname=[%s]",
+			entry->dir_name, entry->base_name, entry->link_name);
+	entry->offset = offset;
+	entry->data_offset = offset + VTARFS_HDR_SIZE + ALIGN_SECTOR(VTARFS_HDR_SIZE);
+	tarfs_debug("%s: Returning entry", __func__);
+	return entry;
+
+err_lvl3:
+	for (; i; i--)
+		put_page(entry->pages[i - 1]);
+	kfree(entry->pages);
+err_lvl2:
+	kfree(entry);
+err_lvl1:
+	kfree(longname);
+	return NULL;
+}
+
+static int
+vtarfs_parse_mount_ops(char *data, struct vtarfs_mount_opts *opts)
+{
+	/*TODO: Hardcode it to Read Only mode */
+	opts->mode = S_IRUGO | S_IXUGO;
+	return 0;
+}
+
+/*
+ * vtarfs_open_first_entry : Allocate inode for first entry
+ * sb : Superblock of the file system
+ */
+static struct vtarfs_entry *vtarfs_open_first_entry(struct super_block *sb)
+{
+	struct vtarfs_entry *first = vtarfs_read_entry(sb, 0);
+	struct inode *alloc_inode = NULL;
+
+	if (first) {
+		alloc_inode = vtarfs_create_inode(sb, first, first->mode);
+		if (alloc_inode == NULL) {
+			pr_err("%s: alloc_inode failed !!", __func__);
+			first->inode = 2;
+		}
+	}
+	return first;
+}
+
+/**
+ * @brief Reads all file headers from the \a sb
+ * @param sb the underlying super block
+ * @return the first entry, pointing at all other entries
+ */
+struct vtarfs_entry *vtarfs_open(struct super_block *sb, struct vtarfs_entry *first)
+{
+	struct vtarfs_entry *parent = first;
+	struct vtarfs_entry *next;
+	struct inode *alloc_inode = NULL;
+	int err = 0;
+
+	do {
+		next = vtarfs_read_entry(sb, parent->data_offset);
+		parent->next = next;
+		parent = next;
+		if (IS_ERR_OR_NULL(parent))
+			break;
+
+		alloc_inode = vtarfs_create_inode(sb, parent, parent->mode);
+		if (alloc_inode == NULL) {
+			pr_err("%s: alloc_inode failed !!", __func__);
+			parent->inode = 2;
+			break;
+		}
+		radix_tree_preload(GFP_NOIO);
+		err = radix_tree_insert(&first->root_tree,
+			(unsigned long)parent->ptr_inode->i_ino, parent);
+		if (err)
+			pr_err("%s:Radix tree insert err=%d, inode %ld\n",
+				__func__, err, parent->ptr_inode->i_ino);
+
+		radix_tree_preload_end();
+		first->radix_root_key = parent->inode;
+		if (parent->header.typeflag == LNKTYPE)
+			iput(alloc_inode);
+
+	} while (parent);
+
+	return first;
+}
+
+static DEFINE_MUTEX(img_map);
+static struct vtarfs_img_map_t vtarfs_img_map;
+
+/*
+ * vtarfs_fill_super : Fill the super block structure
+ * sb : Superblock of the file system
+ * data : Options passed by user through mount command
+ * silent : unused.
+ */
+static int
+vtarfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct vtarfs_fs_info *info = NULL;
+	struct vtarfs_entry *entry = NULL;
+	struct inode *inode = NULL;
+	int err = -EINVAL;
+
+	tarfs_debug("data = %p", data);
+
+	info = kzalloc(sizeof(struct vtarfs_fs_info), GFP_KERNEL);
+	if (IS_ERR(info)) {
+		pr_err("%s: Error in allocating memory for info %ld",
+			__func__, PTR_ERR(info));
+		err = -ENOMEM;
+		return PTR_ERR(info);
+	}
+	err = vtarfs_parse_mount_ops(data, &info->mount_opts);
+	if (err) {
+		pr_err("%s: Error in reading mount options for vtarfs", __func__);
+		goto err_fill_super;
+	}
+	mutex_lock(&img_map);
+	info->vtarfs_img_map.tarfs_img_map = vtarfs_img_map.tarfs_img_map;
+	info->vtarfs_img_map.inode = vtarfs_img_map.inode;
+	info->vtarfs_img_map.fp = vtarfs_img_map.fp;
+	mutex_unlock(&img_map);
+
+	sb->s_maxbytes	=	MAX_LFS_FILESIZE;
+	sb->s_blocksize	=	PAGE_SIZE;
+	sb->s_blocksize_bits =	PAGE_SHIFT;
+	sb->s_op	=	&vtarfs_super_ops;
+	sb->s_d_op	=	&simple_dentry_operations;
+	sb->s_time_gran	=	1;
+	sb->s_flags	|=	SB_RDONLY | SB_NOATIME; /*Read only file system*/
+	sb->s_magic	=	(unsigned long)vtarfs_MAGIC;
+
+	sb->s_fs_info = info;
+	inode = vtarfs_get_inode(sb, NULL, S_IFDIR |
+				info->mount_opts.mode, 0);
+	sb->s_root = d_make_root(inode);
+	if (!sb->s_root) {
+		pr_err("%s: Error in creating root point for vtarfs", __func__);
+		err = -ENOMEM;
+		goto err_fill_super;
+	}
+	tarfs_debug("populate_first_entry");
+	__insert_inode_hash(inode, inode->i_ino);
+	entry = vtarfs_open_first_entry(sb);
+	if (!entry) {
+		pr_err("%s: Failed to read first entry", __func__);
+		goto err_fill_super;
+	}
+	radix_tree_preload(GFP_NOIO);
+	INIT_RADIX_TREE(&entry->root_tree, GFP_NOIO);
+	err = radix_tree_insert(&entry->root_tree, (unsigned long)inode->i_ino,
+					entry);
+	if (err)
+		pr_err("%s: Radix tree insert err - inode %ld, err = %d",
+				__func__, inode->i_ino, err);
+
+	radix_tree_preload_end();
+	entry->radix_root_key = inode->i_ino;
+	info->fs_entry = entry;
+	tarfs_debug("first allocated root inode num = %ld and sb = %p",
+				inode->i_ino, sb);
+
+	entry = vtarfs_open(sb, entry);
+	if (!entry) {
+		pr_err("%s: failed to read tar index", __func__);
+		goto err_fill_super;
+	}
+	return 0;
+
+err_fill_super:
+	kfree(info);
+	return err;
+}
+
+/*
+ * vtarfs_mount : Mount call for the vtarfs filesystem
+ * fs_type : file system type, name etc.
+ * flags :for special options
+ * dev_name : binary image format of the file system.
+ * data : options passed by user through mount command
+ */
+static struct
+dentry *vtarfs_mount(struct file_system_type *fs_type, int flags,
+				const char *dev_name, void *data)
+{
+	struct file *fp = NULL;
+
+	tarfs_debug("dev_name = %s", dev_name);
+
+	fp = filp_open(dev_name, O_RDONLY, 0);
+	if (IS_ERR(fp)) {
+		pr_err("Failed to open the file %s for mount %ld\n",
+			dev_name, PTR_ERR(fp));
+		return NULL;
+	}
+	mutex_lock(&img_map);
+	vtarfs_img_map.tarfs_img_map = (void *)fp->f_mapping;
+	vtarfs_img_map.inode = vtarfs_img_map.tarfs_img_map->host;
+	vtarfs_img_map.fp = fp;
+	mutex_unlock(&img_map);
+
+	return mount_nodev(fs_type, flags, data, &vtarfs_fill_super);
+}
+
+/*
+ * vtarfs_kill_super : Destroy the super block of vtarfs
+ * sb : super block structure
+ */
+static void vtarfs_kill_super(struct super_block *sb)
+{
+	struct vtarfs_fs_info *info = VTARFS_SB(sb);
+	struct vtarfs_entry *entry = info->fs_entry;
+	int i;
+
+	tarfs_debug("Kill super");
+	while (entry) {
+		struct vtarfs_entry *next = entry->next;
+
+		entry->ptr_inode->i_mapping->nrpages = 0;
+		tarfs_debug("basename=%s dirn=%s",
+				entry->base_name, entry->dir_name);
+
+		if (entry->dir_name < entry->base_name)
+			kfree(entry->dir_name);
+		else
+			kfree(entry->base_name);
+
+		if (strlen(entry->link_name) > MAX_FILE_NAME_SIZE)
+			kfree(entry->link_name);
+
+		for (i = 0; i < entry->num_pages; i++)
+			put_page(entry->pages[i]);
+
+		if (entry->header.typeflag != LNKTYPE)
+			iput(entry->ptr_inode);
+		kfree(entry->pages);
+		kfree(entry);
+		entry = next;
+	}
+	if (info) {
+		filp_close(info->vtarfs_img_map.fp, NULL);
+		kfree(info);
+	}
+	kill_litter_super(sb);
+}
+
+static struct file_system_type vtarfs_type = {
+	.owner = THIS_MODULE,
+	.name = "vtarfs",
+	.mount = vtarfs_mount,
+	.kill_sb = vtarfs_kill_super,
+	.fs_flags = FS_USERNS_MOUNT | FS_BINARY_MOUNTDATA,
+};
+
+static int __init vtarfs_init(void)
+{
+	int err = 0;
+
+	pr_info("%s: filesystem module load start", __func__);
+
+	err = register_filesystem(&vtarfs_type);
+	if (unlikely(err)) {
+		pr_err("Failed to register vtarfs type %d. Exiting\n", err);
+		goto err;
+	}
+	tarfs_debug("filesystem module registered");
+
+	return 0;
+err:
+	return err;
+}
+
+static void __exit vtarfs_exit(void)
+{
+	int err = 0;
+
+	pr_info("%s: filesystem module unload", __func__);
+
+	err = unregister_filesystem(&vtarfs_type);
+
+	if (unlikely(err))
+		pr_err("\n Failed to unregister vtarfs filesystem %d\n", err);
+
+
+}
+
+module_init(vtarfs_init);
+module_exit(vtarfs_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("VMware Photon OS : Srinidhi Rao <srinidhir@vmware.com>");
+MODULE_AUTHOR("VMware Photon OS : Ankit Jain <ankitja@vmware.com>");
-- 
2.39.4

