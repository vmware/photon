From 9057b8f857f868e7607ecc7184b58a25394d0ff4 Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
Date: Fri, 26 Jul 2024 10:51:50 +0000
Subject: [PATCH] gcc rap plugin with kcfi

This patch adopts the forward-edge control-flow integrity
scheme for Clang known as KCFI in gcc with the help
of RAP plugin.

The original RAP gcc plugin code developed by PaX team
is modified to adopt to kcfi implementation in kernel.

Following changes are made to adopt KCFI in GCC RAP plugin:

- Padding and hash size is changed to match with KCFI
- Function label and size paramter are added
  E.g:
0000000000000000 <__cfi_func>:
       0:       cc                      int3
       1:       cc                      int3
       2:       b8 a7 9e 9e 58          mov    $0x589e9ea7,%eax
       7:       cc                      int3
       8:       cc                      int3
- weak attribute handling and skip generation of rap hash
  for direct calls
- change the runtime comparison injection code of RAP plugin
  to use 4 bytes hash comparision instead of 8 bytes
- Add Kconfig changes to enable CFI_CLANG when PAX_RAP is 'y'
- Fix rap_hash injection for bpf_prog_run() to use int instead of
  long as the size of rap_hash is 4 bytes now
- KCFI code adds SYM_TYPED_FUNC_START which emits the type identifier
  before the assembly functions that are called indirectly from C code.
  As the padding and size of cfi_type and rap_hash_type is different,
  replaced __CFI_TYPE macro with __RAP_TYPE for adding rap_hash for
  callers of SYM_TYPED_FUNC_START when CONFIG_PAX_RAP is enabled.

Signed-off-by: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
Signed-off-by: Mukul Sikka <mukul.sikka@broadcom.com>

[Srinidhi Rao<srinidhi.rao@broadcom.com> Back ported this patch to v6.12.x]
Signed-off-by: srinidhira0 <srinidhi.rao@broadcom.com>
---
 Makefile                                      |   2 +
 arch/Kconfig                                  |   8 +-
 arch/x86/Kconfig                              |   2 +-
 arch/x86/include/asm/text-patching.h          |   4 +
 arch/x86/include/asm/vermagic.h               |   9 +-
 arch/x86/kernel/alternative.c                 |   7 +
 arch/x86/kernel/cpu/vmware.c                  |   9 +-
 arch/x86/kernel/module.c                      |   6 +-
 arch/x86/kernel/traps.c                       |   4 +
 include/linux/compiler_types.h                |   6 +-
 include/linux/moduleparam.h                   |   4 +-
 include/linux/syscalls.h                      |  17 +-
 kernel/bpf/core.c                             |  21 +
 kernel/events/core.c                          |   3 +-
 kernel/module/main.c                          |   9 +
 kernel/sched/core.c                           |   2 +-
 net/bridge/br_private.h                       |   3 +-
 net/netfilter/ipset/ip_set_core.c             |   1 -
 scripts/Makefile.gcc-plugins                  |  12 +
 scripts/gcc-plugins/Makefile                  |   8 +-
 scripts/gcc-plugins/rap_plugin/rap.h          |  38 ++
 .../gcc-plugins/rap_plugin/rap_fptr_pass.c    | 224 +++++++
 scripts/gcc-plugins/rap_plugin/rap_hash.c     | 396 +++++++++++++
 scripts/gcc-plugins/rap_plugin/rap_plugin.c   | 557 ++++++++++++++++++
 scripts/gcc-plugins/rap_plugin/sip.c          |  96 +++
 scripts/mod/modpost.c                         |   6 -
 security/Kconfig                              |  29 +
 27 files changed, 1457 insertions(+), 26 deletions(-)
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap.h
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_hash.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_plugin.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/sip.c

diff --git a/Makefile b/Makefile
index 68a8faff2543..919427a37107 100644
--- a/Makefile
+++ b/Makefile
@@ -950,6 +950,7 @@ export CC_FLAGS_LTO
 endif
 
 ifdef CONFIG_CFI_CLANG
+ifdef CONFIG_KCFI_CLANG
 CC_FLAGS_CFI	:= -fsanitize=kcfi
 ifdef CONFIG_CFI_ICALL_NORMALIZE_INTEGERS
 	CC_FLAGS_CFI	+= -fsanitize-cfi-icall-experimental-normalize-integers
@@ -964,6 +965,7 @@ endif
 KBUILD_CFLAGS	+= $(CC_FLAGS_CFI)
 export CC_FLAGS_CFI
 endif
+endif
 
 # Architectures can define flags to add/remove for floating-point support
 CC_FLAGS_FPU	+= -D_LINUX_FPU_COMPILATION_UNIT
diff --git a/arch/Kconfig b/arch/Kconfig
index bd9f095d69fa..0d1da16a93ba 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -820,10 +820,16 @@ config ARCH_SUPPORTS_CFI_CLANG
 config ARCH_USES_CFI_TRAPS
 	bool
 
+config KCFI_CLANG
+	bool "Use Clang's Kernel Control Flow Integrity (KCFI)"
+	depends on $(cc-option,-fsanitize=kcfi)
+	help
+	  This option is Clang's Kernel Control Flow Integrity checking
+
 config CFI_CLANG
 	bool "Use Clang's Control Flow Integrity (CFI)"
 	depends on ARCH_SUPPORTS_CFI_CLANG
-	depends on $(cc-option,-fsanitize=kcfi)
+	depends on GCC_PLUGINS || KCFI_CLANG
 	help
 	  This option enables Clang's forward-edge Control Flow Integrity
 	  (CFI) checking, where the compiler injects a runtime check to each
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 7b9a7e8f39ac..33d0970f8a76 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -2477,7 +2477,7 @@ config CALL_PADDING
 
 config FINEIBT
 	def_bool y
-	depends on X86_KERNEL_IBT && CFI_CLANG && MITIGATION_RETPOLINE
+	depends on X86_KERNEL_IBT && KCFI_CLANG && MITIGATION_RETPOLINE
 	select CALL_PADDING
 
 config HAVE_CALL_THUNKS
diff --git a/arch/x86/include/asm/text-patching.h b/arch/x86/include/asm/text-patching.h
index 6259f1937fe7..d4489e292e3c 100644
--- a/arch/x86/include/asm/text-patching.h
+++ b/arch/x86/include/asm/text-patching.h
@@ -43,6 +43,10 @@ extern void text_poke_bp(void *addr, const void *opcode, size_t len, const void
 extern void text_poke_queue(void *addr, const void *opcode, size_t len, const void *emulate);
 extern void text_poke_finish(void);
 
+#ifdef CONFIG_PAX_RAP
+extern void *memcpy_alt(void *addr, const void *opcode, size_t len);
+#endif
+
 #define INT3_INSN_SIZE		1
 #define INT3_INSN_OPCODE	0xCC
 
diff --git a/arch/x86/include/asm/vermagic.h b/arch/x86/include/asm/vermagic.h
index 75884d2cdec3..266f5ce89639 100644
--- a/arch/x86/include/asm/vermagic.h
+++ b/arch/x86/include/asm/vermagic.h
@@ -5,6 +5,7 @@
 
 #ifdef CONFIG_X86_64
 /* X86_64 does not define MODULE_PROC_FAMILY */
+#define MODULE_PROC_FAMILY ""
 #elif defined CONFIG_M486SX
 #define MODULE_PROC_FAMILY "486SX "
 #elif defined CONFIG_M486
@@ -59,10 +60,12 @@
 #error unknown processor family
 #endif
 
-#ifdef CONFIG_X86_32
-# define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY
+#ifdef CONFIG_PAX_RAP
+#define MODULE_PAX_RAP "RAP "
 #else
-# define MODULE_ARCH_VERMAGIC ""
+#define MODULE_PAX_RAP ""
 #endif
 
+#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_PAX_RAP
+
 #endif /* _ASM_VERMAGIC_H */
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index d17518ca19b8..d3871f43c314 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -1984,6 +1984,13 @@ void *text_poke(void *addr, const void *opcode, size_t len)
 	return __text_poke(text_poke_memcpy, addr, opcode, len);
 }
 
+#ifdef CONFIG_PAX_RAP
+void *memcpy_alt(void *addr, const void *opcode, size_t len)
+{
+    return memcpy(addr, opcode, len);
+}
+#endif
+
 /**
  * text_poke_kgdb - Update instructions on a live kernel by kgdb
  * @addr: address to modify
diff --git a/arch/x86/kernel/cpu/vmware.c b/arch/x86/kernel/cpu/vmware.c
index 00189cdeb775..27132984b3ad 100644
--- a/arch/x86/kernel/cpu/vmware.c
+++ b/arch/x86/kernel/cpu/vmware.c
@@ -334,10 +334,17 @@ static __init int activate_jump_labels(void)
 }
 arch_initcall(activate_jump_labels);
 
+/*
+ * No need for any "IO delay" on VMware hypervisor
+ */
+static void vmware_io_delay(void)
+{
+}
+
 static void __init vmware_paravirt_ops_setup(void)
 {
 	pv_info.name = "VMware hypervisor";
-	pv_ops.cpu.io_delay = paravirt_nop;
+	pv_ops.cpu.io_delay = vmware_io_delay;
 
 	if (vmware_tsc_khz == 0)
 		return;
diff --git a/arch/x86/kernel/module.c b/arch/x86/kernel/module.c
index 837450b6e882..1f2d07440fa9 100644
--- a/arch/x86/kernel/module.c
+++ b/arch/x86/kernel/module.c
@@ -180,7 +180,11 @@ static int write_relocate_add(Elf64_Shdr *sechdrs,
 {
 	int ret;
 	bool early = me->state == MODULE_STATE_UNFORMED;
-	void *(*write)(void *, const void *, size_t) = memcpy;
+#ifdef CONFIG_PAX_RAP
+    void *(*write)(void *, const void *, size_t) = memcpy_alt;
+#else
+    void *(*write)(void *, const void *, size_t) = memcpy;
+#endif
 
 	if (!early) {
 		write = text_poke;
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index 2dbadf347b5f..c67578032f66 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -153,6 +153,10 @@ do_trap_no_signal(struct task_struct *tsk, int trapnr, const char *str,
 
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_nr = trapnr;
+#ifdef CONFIG_PAX_RAP
+		if (trapnr == X86_TRAP_UD)
+			str = "PAX: overwritten function pointer or return address detected";
+#endif
 		die(str, regs, error_code);
 	} else {
 		if (fixup_vdso_exception(regs, trapnr, error_code, 0))
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index 1a957ea2f4fe..a99f4da405b3 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -88,7 +88,7 @@ static inline void __chk_io_ptr(const volatile void __iomem *ptr) { }
 /* Attributes */
 #include <linux/compiler_attributes.h>
 
-#if CONFIG_FUNCTION_ALIGNMENT > 0
+#if !defined(CONFIG_PAX_RAP) && (CONFIG_FUNCTION_ALIGNMENT > 0)
 #define __function_aligned		__aligned(CONFIG_FUNCTION_ALIGNMENT)
 #else
 #define __function_aligned
@@ -479,6 +479,10 @@ struct ftrace_likely_data {
 			 __scalar_type_to_expr_cases(long long),	\
 			 default: (x)))
 
+#define __type_is_unsigned(t) \
+	(__same_type((t)0, 0UL) || __same_type((t)0, 0U) || \
+	__same_type((t)0, (unsigned short)0) || __same_type((t)0, (unsigned char)0))
+
 /* Is this type a native word size -- useful for atomic operations */
 #define __native_word(t) \
 	(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \
diff --git a/include/linux/moduleparam.h b/include/linux/moduleparam.h
index bfb85fd13e1f..fd12a9ed34a7 100644
--- a/include/linux/moduleparam.h
+++ b/include/linux/moduleparam.h
@@ -358,7 +358,7 @@ static inline void kernel_param_unlock(struct module *mod)
  * @len is usually just sizeof(string).
  */
 #define module_param_string(name, string, len, perm)			\
-	static const struct kparam_string __param_string_##name		\
+	static const struct kparam_string __param_string_##name __used	\
 		= { len, string };					\
 	__module_param_call(MODULE_PARAM_PREFIX, name,			\
 			    &param_ops_string,				\
@@ -517,7 +517,7 @@ extern int param_set_bint(const char *val, const struct kernel_param *kp);
  */
 #define module_param_array_named(name, array, type, nump, perm)		\
 	param_check_##type(name, &(array)[0]);				\
-	static const struct kparam_array __param_arr_##name		\
+	static const struct kparam_array __param_arr_##name __used	\
 	= { .max = ARRAY_SIZE(array), .num = nump,                      \
 	    .ops = &param_ops_##type,					\
 	    .elemsize = sizeof(array[0]), .elem = array };		\
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 5758104921e6..ee2a8e9e26e3 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -127,8 +127,14 @@ struct mnt_id_req;
 #define __TYPE_IS_UL(t)	(__TYPE_AS(t, 0UL))
 #define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))
 #define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a
+#define __SC_TYPE(t, a) __typeof__(                               \
+       __builtin_choose_expr(                                  \
+               sizeof(t) > sizeof(int),                        \
+               (t) 0,                                          \
+               __builtin_choose_expr(__type_is_unsigned(t), 0UL, 0L)   \
+       ))
+#define __SC_WRAP(t, a)        (__SC_TYPE(t, a)) a
 #define __SC_CAST(t, a)	(__force t) a
-#define __SC_TYPE(t, a)	t
 #define __SC_ARGS(t, a)	a
 #define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) && sizeof(t) > sizeof(long))
 
@@ -245,18 +251,19 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
 	__diag_push();							\
 	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
 		      "Type aliasing is used to sanitize syscall arguments");\
-	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\
-		__attribute__((alias(__stringify(__se_sys##name))));	\
 	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));	\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\
+	static inline asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))    \
 	{								\
 		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\
 		__MAP(x,__SC_TEST,__VA_ARGS__);				\
 		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\
 		return ret;						\
 	}								\
+	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \
+	{                                                               \
+		return __se_sys##name(__MAP(x,__SC_WRAP,__VA_ARGS__));  \
+	}                                                               \
 	__diag_pop();							\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
 #endif /* __SYSCALL_DEFINEx */
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 5e77c58e0601..55235e0898be 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -1119,6 +1119,10 @@ void bpf_jit_binary_free(struct bpf_binary_header *hdr)
 	bpf_jit_uncharge_modmem(size);
 }
 
+#ifdef CONFIG_PAX_RAP
+extern long __rap_hash___bpf_prog_run;
+#endif
+
 /* Allocate jit binary from bpf_prog_pack allocator.
  * Since the allocated memory is RO+X, the JIT engine cannot write directly
  * to the memory. To solve this problem, a RW buffer is also allocated at
@@ -1136,6 +1140,10 @@ bpf_jit_binary_pack_alloc(unsigned int proglen, u8 **image_ptr,
 {
 	struct bpf_binary_header *ro_header;
 	u32 size, hole, start;
+	u32 padding_bytes = 0;
+#ifdef CONFIG_CALL_PADDING
+	padding_bytes += CONFIG_FUNCTION_PADDING_BYTES;
+#endif
 
 	WARN_ON_ONCE(!is_power_of_2(alignment) ||
 		     alignment > BPF_IMAGE_ALIGNMENT);
@@ -1164,10 +1172,23 @@ bpf_jit_binary_pack_alloc(unsigned int proglen, u8 **image_ptr,
 
 	hole = min_t(unsigned int, size - (proglen + sizeof(*ro_header)),
 		     BPF_PROG_CHUNK_SIZE - sizeof(*ro_header));
+#ifdef CONFIG_PAX_RAP
+	hole -= (4 + padding_bytes);
+#endif
 	start = get_random_u32_below(hole) & ~(alignment - 1);
 
+#ifdef CONFIG_PAX_RAP
+	start += (4 + padding_bytes);
+#endif
 	*image_ptr = &ro_header->image[start];
 	*rw_image = &(*rw_header)->image[start];
+#ifdef CONFIG_PAX_RAP
+#ifdef CONFIG_RELOCATABLE
+	*(int *)(*rw_image - (4 + padding_bytes)) = 0x456bce13;
+#else
+	*(int *)(*rw_image - (4 + padding_bytes)) = (int)&__rap_hash___bpf_prog_run;
+#endif
+#endif
 
 	return ro_header;
 }
diff --git a/kernel/events/core.c b/kernel/events/core.c
index df27d08a7232..e209121a9e43 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -1155,8 +1155,9 @@ static void __perf_mux_hrtimer_init(struct perf_cpu_pmu_context *cpc, int cpu)
 	timer->function = perf_mux_hrtimer_handler;
 }
 
-static int perf_mux_hrtimer_restart(struct perf_cpu_pmu_context *cpc)
+static int perf_mux_hrtimer_restart(void *_cpc)
 {
+	struct perf_cpu_pmu_context *cpc = _cpc;
 	struct hrtimer *timer = &cpc->hrtimer;
 	unsigned long flags;
 
diff --git a/kernel/module/main.c b/kernel/module/main.c
index 49b9bca9de12..44c46d5577b1 100644
--- a/kernel/module/main.c
+++ b/kernel/module/main.c
@@ -2094,8 +2094,17 @@ static void module_augment_kernel_taints(struct module *mod, struct load_info *i
 static int check_modinfo(struct module *mod, struct load_info *info, int flags)
 {
 	const char *modmagic = get_modinfo(info, "vermagic");
+#ifdef CONFIG_PAX_RAP
+	const char *license = get_modinfo(info, "license");
+#endif
 	int err;
 
+#if defined(CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_OR) || defined(CONFIG_PAX_RAP)
+	if (!license || !license_is_gpl_compatible(license)) {
+		pr_err("%s: module is not compatible with the KERNEXEC 'or' method and RAP\n", mod->name);
+		return -ENOEXEC;
+	}
+#endif
 	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
 		modmagic = NULL;
 
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index a1c353a62c56..5bcb20d1b3eb 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4972,7 +4972,7 @@ static void do_balance_callbacks(struct rq *rq, struct balance_callback *head)
 	lockdep_assert_rq_held(rq);
 
 	while (head) {
-		func = (void (*)(struct rq *))head->func;
+		func = head->func;
 		next = head->next;
 		head->next = NULL;
 		head = next;
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 041f6e571a20..8c0ad5c4b101 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -927,7 +927,8 @@ void br_del_frame(struct net_bridge *br, struct br_frame_type *ft);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
 {
-	return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	//return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	return br_get_rx_handler(dev) == rcu_dereference(dev->rx_handler);
 }
 
 static inline bool br_rx_handler_check_rtnl(const struct net_device *dev)
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index 61431690cbd5..e4c386f0af3c 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -392,7 +392,6 @@ ip_set_comment_free(struct ip_set *set, void *ptr)
 	rcu_assign_pointer(comment->c, NULL);
 }
 
-typedef void (*destroyer)(struct ip_set *, void *);
 /* ipset data extension types, in size order */
 
 const struct ip_set_ext_type ip_set_extensions[] = {
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index e4deaf5fa571..7acd78f9d9c4 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -22,6 +22,14 @@ export DISABLE_STRUCTLEAK_PLUGIN
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)		\
 		+= -DSTRUCTLEAK_PLUGIN
 
+gcc-plugin-$(CONFIG_PAX_RAP)                           += rap_plugin.so
+gcc-plugin-cflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN -fplugin-arg-rap_plugin-check=call -fplugin-arg-rap_plugin-hash=abs-finish
+# gcc-plugin-cflags-$(CONFIG_PAX_RAP)                  += -fplugin-arg-rap_plugin-report=func,fptr,abs
+ifdef CONFIG_PAX_RAP
+  RAP_PLUGIN_ABS_CFLAGS                                := -fplugin-arg-rap_plugin-hash=abs-finish
+endif
+gcc-plugin-aflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STACKLEAK)	+= stackleak_plugin.so
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STACKLEAK)		\
 		+= -DSTACKLEAK_PLUGIN
@@ -47,8 +55,12 @@ export DISABLE_ARM_SSP_PER_TASK_PLUGIN
 GCC_PLUGINS_CFLAGS := $(strip $(addprefix -fplugin=$(objtree)/scripts/gcc-plugins/, $(gcc-plugin-y)) $(gcc-plugin-cflags-y))
 export GCC_PLUGINS_CFLAGS
 
+GCC_PLUGINS_AFLAGS := $(gcc-plugin-aflags-y)
+export RAP_PLUGIN_ABS_CFLAGS GCC_PLUGINS_AFLAGS
+
 # Add the flags to the build!
 KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
 
 # Some plugins are enabled outside of this Makefile, but they still need to
 # be included in GCC_PLUGIN so they can get built.
diff --git a/scripts/gcc-plugins/Makefile b/scripts/gcc-plugins/Makefile
index 320afd3cf8e8..0d3c8bdeca84 100644
--- a/scripts/gcc-plugins/Makefile
+++ b/scripts/gcc-plugins/Makefile
@@ -33,14 +33,20 @@ plugin_cxxflags	= -Wp,-MMD,$(depfile) $(KBUILD_HOSTCXXFLAGS) -fPIC \
 		  -fno-rtti -fno-exceptions -fasynchronous-unwind-tables \
 		  -ggdb -Wno-narrowing -Wno-unused-variable \
 		  -Wno-format-diag
+ifdef CONFIG_CALL_PADDING
+plugin_cxxflags += -DCONFIG_FUNCTION_PADDING_BYTES='$(CONFIG_FUNCTION_PADDING_BYTES)'
+endif
+
 
 plugin_ldflags	= -shared
 
+rap_plugin-objs := $(patsubst $(srctree)/$(src)/rap_plugin/%.c,rap_plugin/%.o,$(wildcard $(srctree)/$(src)/rap_plugin/*.c))
+
 plugin-single	:= $(foreach m, $(GCC_PLUGIN), $(if $($(m:%.so=%-objs)),,$(m)))
 plugin-multi	:= $(filter-out $(plugin-single), $(GCC_PLUGIN))
 plugin-objs	:= $(sort $(foreach m, $(plugin-multi), $($(m:%.so=%-objs))))
-
 targets += $(plugin-single) $(plugin-multi) $(plugin-objs)
+
 clean-files += *.so
 
 plugin-single	:= $(addprefix $(obj)/, $(plugin-single))
diff --git a/scripts/gcc-plugins/rap_plugin/rap.h b/scripts/gcc-plugins/rap_plugin/rap.h
new file mode 100644
index 000000000000..0e2c26301e33
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap.h
@@ -0,0 +1,38 @@
+#ifndef RAP_H_INCLUDED
+#define RAP_H_INCLUDED
+
+#include "gcc-common.h"
+
+#define RAP_HASH_START_PADDING_SIZE  1
+#define RAP_HASH_END_PADDING_SIZE  2
+typedef struct {
+	int hash; // will be sign extended to long in reality
+} rap_hash_t;
+
+typedef struct {
+	unsigned int qual_const:1;
+	unsigned int qual_volatile:1;
+} rap_hash_flags_t;
+extern rap_hash_flags_t imprecise_rap_hash_flags;
+
+extern bool report_fptr_hash;
+
+extern GTY(()) tree rap_hash_type_node;
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+void rap_calculate_func_hashes(void *event_data, void *data);
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node);
+const_tree type_name(const_tree type);
+tree create_new_var(tree type, const char *name);
+
+gimple barrier(tree var, bool full);
+
+#if BUILDING_GCC_VERSION >= 4009
+opt_pass *make_rap_fptr_pass(void);
+#else
+struct opt_pass *make_rap_fptr_pass(void);
+#endif
+
+#endif
diff --git a/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
new file mode 100644
index 000000000000..f8124b597b2d
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+bool report_fptr_hash;
+
+static bool rap_fptr_gate(void)
+{
+#ifdef TARGET_64BIT
+	tree section;
+
+	if (!TARGET_64BIT || ix86_cmodel != CM_KERNEL)
+		return true;
+
+	section = lookup_attribute("section", DECL_ATTRIBUTES(current_function_decl));
+	if (!section || !TREE_VALUE(section))
+		return true;
+
+	section = TREE_VALUE(TREE_VALUE(section));
+	return strncmp(TREE_STRING_POINTER(section), ".vsyscall_", 10);
+#else
+#error unsupported target
+#endif
+}
+
+static tree build_rap_hash(gimple call_stmt, tree fntype)
+{
+	rap_hash_t hash;
+
+	hash = rap_hash_function_type(fntype, imprecise_rap_hash_flags);
+	if (report_fptr_hash)
+		inform(gimple_location(call_stmt), "fptr rap_hash: %x", hash.hash);
+	return build_int_cst_type(rap_hash_type_node, hash.hash);
+}
+
+// check the function hash of the target of the fptr
+static basic_block rap_instrument_fptr(gimple_stmt_iterator *gsi)
+{
+	gimple assign_hash, check_hash, call_stmt, stmt;
+	location_t loc;
+	tree computed_hash, target_hash, fptr, fntype;
+#if BUILDING_GCC_VERSION == 4005
+	tree fptr2;
+#endif
+	basic_block cond_bb, join_bb, true_bb;
+	edge e;
+	const HOST_WIDE_INT rap_hash_offset = sizeof(rap_hash_t) + CONFIG_FUNCTION_PADDING_BYTES;
+
+	call_stmt = gsi_stmt(*gsi);
+	loc = gimple_location(call_stmt);
+	fptr = gimple_call_fn(call_stmt);
+	fntype = TREE_TYPE(TREE_TYPE(fptr));
+
+	if (TREE_CODE(fntype) == FUNCTION_TYPE) {
+		computed_hash = build_rap_hash(call_stmt, fntype);
+	} else {
+		debug_tree(fntype);
+		gcc_unreachable();
+	}
+
+	// target_hash = ((s64*)fptr)[-rap_hash_offset]
+	target_hash = create_tmp_var(rap_hash_type_node, "rap_hash");
+	add_referenced_var(target_hash);
+	target_hash = make_ssa_name(target_hash, NULL);
+#if BUILDING_GCC_VERSION == 4005
+	fptr2 = create_tmp_var(ptr_type_node, "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, build2(POINTER_PLUS_EXPR, ptr_type_node, fptr, build_int_cst_type(sizetype, -rap_hash_offset)));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	fptr2 = create_tmp_var(build_pointer_type(rap_hash_type_node), "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, fold_convert(build_pointer_type(TREE_TYPE(target_hash)), fptr));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	assign_hash = gimple_build_assign(target_hash, build1(INDIRECT_REF, rap_hash_type_node, fptr));
+#else
+	assign_hash = gimple_build_assign(target_hash, build2(MEM_REF, integer_type_node, fptr, build_int_cst_type(build_pointer_type(rap_hash_type_node), -rap_hash_offset)));
+#endif
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(target_hash) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_NEW_STMT);
+	update_stmt(assign_hash);
+
+	// compare target_hash against computed function hash
+	// bail out on mismatch
+	check_hash = gimple_build_cond(NE_EXPR, target_hash, computed_hash, NULL_TREE, NULL_TREE);
+	gimple_set_location(check_hash, loc);
+	gsi_insert_after(gsi, check_hash, GSI_NEW_STMT);
+
+	cond_bb = gimple_bb(gsi_stmt(*gsi));
+	gcc_assert(!gsi_end_p(*gsi));
+	gcc_assert(check_hash == gsi_stmt(*gsi));
+
+	e = split_block(cond_bb, gsi_stmt(*gsi));
+	cond_bb = e->src;
+	join_bb = e->dest;
+	e->flags = EDGE_FALSE_VALUE;
+#if BUILDING_GCC_VERSION < 8000
+	e->probability = REG_BR_PROB_BASE;
+#else
+	e->probability = profile_probability::always ();
+#endif
+
+	true_bb = create_empty_bb(EXIT_BLOCK_PTR_FOR_FN(cfun)->prev_bb);
+	make_edge(cond_bb, true_bb, EDGE_TRUE_VALUE | EDGE_PRESERVE);
+
+	gcc_assert(dom_info_available_p(CDI_DOMINATORS));
+	set_immediate_dominator(CDI_DOMINATORS, true_bb, cond_bb);
+	set_immediate_dominator(CDI_DOMINATORS, join_bb, cond_bb);
+
+	gcc_assert(cond_bb->loop_father == join_bb->loop_father);
+	add_bb_to_loop(true_bb, cond_bb->loop_father);
+
+	*gsi = gsi_start_bb(true_bb);
+
+	// this fake dependency is to prevent PRE from merging this BB with others of the same kind
+	stmt = barrier(fptr, false);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	stmt = gimple_build_call(builtin_decl_implicit(BUILT_IN_TRAP), 0);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	return join_bb;
+}
+
+// find all language level function pointer dereferences and verify the target function
+static unsigned int rap_fptr_execute(void)
+{
+	basic_block bb;
+
+	loop_optimizer_init(LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);
+	gcc_assert(current_loops);
+
+	calculate_dominance_info(CDI_DOMINATORS);
+	calculate_dominance_info(CDI_POST_DOMINATORS);
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			// gimple match: h_1 = get_fptr (); D.2709_3 = h_1 (x_2(D));
+			tree fptr, fntype;
+			gimple call_stmt;
+
+			// is it a call ...
+			call_stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(call_stmt))
+				continue;
+
+			fptr = gimple_call_fn(call_stmt);
+			if (!fptr)
+				continue;
+
+			switch (TREE_CODE(fptr)) {
+			default:
+				debug_gimple_stmt(call_stmt);
+				debug_tree(fptr);
+				debug_tree(TREE_TYPE(fptr));
+				gcc_unreachable();
+
+			case ADDR_EXPR:
+				continue;
+
+			case SSA_NAME:
+				if (SSA_NAME_VAR(fptr) == NULL_TREE)
+					break;
+
+				switch (TREE_CODE(SSA_NAME_VAR(fptr))) {
+				default:
+					debug_gimple_stmt(call_stmt);
+					debug_tree(fptr);
+					gcc_unreachable();
+
+				case VAR_DECL:
+				case PARM_DECL:
+					break;
+				}
+				break;
+
+			case INTEGER_CST:
+			case OBJ_TYPE_REF:
+				break;
+			}
+
+			// ... through a function pointer
+			fntype = TREE_TYPE(fptr);
+			if (TREE_CODE(fntype) != POINTER_TYPE)
+				continue;
+
+			fntype = TREE_TYPE(fntype);
+			gcc_assert(TREE_CODE(fntype) == FUNCTION_TYPE || TREE_CODE(fntype) == METHOD_TYPE);
+
+			bb = rap_instrument_fptr(&gsi);
+			gsi = gsi_start_bb(bb);
+		}
+	}
+
+	free_dominance_info(CDI_DOMINATORS);
+	free_dominance_info(CDI_POST_DOMINATORS);
+	loop_optimizer_finalize();
+
+	return 0;
+}
+
+#define PASS_NAME rap_fptr
+#define TODO_FLAGS_FINISH TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa | TODO_cleanup_cfg | TODO_rebuild_cgraph_edges | TODO_verify_flow
+#include "gcc-generate-gimple-pass.h"
diff --git a/scripts/gcc-plugins/rap_plugin/rap_hash.c b/scripts/gcc-plugins/rap_plugin/rap_hash.c
new file mode 100644
index 000000000000..420fcbdbfc05
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_hash.c
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+static rap_hash_t *rap_imprecise_hashes;
+static int rap_cgraph_max_uid;
+
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8]);
+
+static const unsigned char rap_hash_tree_code[MAX_TREE_CODES] = {
+	[0] = 0,
+	[1] = 0,
+	[2] = 0,
+	[3] = 0,
+	[4] = 0,
+	[OFFSET_TYPE] = 10,
+	[ENUMERAL_TYPE] = 20,
+	[BOOLEAN_TYPE] = 30,
+	[INTEGER_TYPE] = 40,
+	[REAL_TYPE] = 50,
+	[POINTER_TYPE] = 60,
+	[REFERENCE_TYPE] = 70,
+#if BUILDING_GCC_VERSION >= 4006
+	[NULLPTR_TYPE] = 80,
+#endif
+	[FIXED_POINT_TYPE] = 0,
+	[COMPLEX_TYPE] = 100,
+	[VECTOR_TYPE] = 110,
+	[ARRAY_TYPE] = 120,
+	[RECORD_TYPE] = 130,
+	[UNION_TYPE] = 140,
+	[QUAL_UNION_TYPE] = 0,
+	[VOID_TYPE] = 160,
+#if BUILDING_GCC_VERSION >= 5000 && BUILDING_GCC_VERSION < 9000
+	[POINTER_BOUNDS_TYPE] = 170,
+#endif
+	[FUNCTION_TYPE] = 180,
+	[METHOD_TYPE] = 0,
+	[LANG_TYPE] = 0,
+};
+
+static void rap_fold_hash(unsigned char *out, const unsigned char *in, unsigned long long inlen)
+{
+	static const unsigned char rap_sip_key[16] = {
+		'P', 'a', 'X', ' ', 'T', 'e', 'a', 'm',
+		'R', 'A', 'P', ' ', 'H', 'A', 'S', 'H',
+	};
+
+	siphash24fold(out, in, inlen, rap_sip_key);
+}
+
+// compute the final hash value in the range [1,INT_MAX]
+// the % and +1 trick leaves the value 0 available for marking non-indirectly callable functions
+// and INT_MIN (0x80000000) for longjmp targets (sign extended)
+// return places will use the (sign extended) range [INT_MIN+1,-1] ([0x8000001,0xffffffff])
+static rap_hash_t rap_extract_hash(const unsigned char sip_hash[8])
+{
+	rap_hash_t hash;
+	unsigned long long dividend, divisor;
+
+	memcpy(&dividend, sip_hash, sizeof dividend);
+//	divisor = 1ULL << (sizeof hash * 8 - 1);
+//	divisor |= divisor - 1;
+	divisor = 0x7fffffffUL;
+	hash.hash = dividend % divisor + 1;
+	return hash;
+}
+
+static void rap_hash_type_name(const_tree type, unsigned char sip_hash[8])
+{
+	const_tree name = type_name(TYPE_MAIN_VARIANT(type));
+
+	// handle typedefs of anonymous structs/unions
+	if (name == NULL_TREE)
+		name = type_name(type);
+
+	if (name == NULL_TREE)
+		return;
+
+	gcc_assert(TREE_CODE(name) == IDENTIFIER_NODE);
+	rap_fold_hash(sip_hash, (const unsigned char *)IDENTIFIER_POINTER(name), IDENTIFIER_LENGTH(name));
+}
+
+static void rap_hash_type_precision(const_tree type, unsigned char sip_hash[8])
+{
+	unsigned HOST_WIDE_INT size;
+
+	gcc_assert(TYPE_PRECISION(type));
+
+	size = TYPE_PRECISION(type);
+	rap_fold_hash(sip_hash, (const unsigned char *)&size, sizeof size);
+}
+
+const_tree type_name(const_tree type)
+{
+	const_tree name;
+
+	name = TYPE_NAME(type);
+	if (!name)
+		return NULL_TREE;
+
+	switch (TREE_CODE(name)) {
+	case IDENTIFIER_NODE:
+		return name;
+
+	case TYPE_DECL:
+		gcc_assert(DECL_NAME(name));
+		return DECL_NAME(name);
+
+	default:
+		gcc_unreachable();
+	}
+}
+
+__attribute__((weak)) tree c_global_trees[CTI_MAX];
+
+// the core computation of the rap hash
+// the first piece is a (hopefully) compiler independent encondig of the type, derived from the gcc tree code
+// the second piece is type specific information, such as the size, qualifiers, (recursively) referenced types, etc
+static void rap_hash_tree(const_tree type, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	enum tree_code code;
+	unsigned int attrs;
+
+	code = TREE_CODE(type);
+	attrs = rap_hash_tree_code[code];
+	if (!attrs) {
+		fprintf(stderr, "unhandled tree_code %s %d\n", get_tree_code_name(code), code);
+		debug_tree(type);
+		gcc_unreachable();
+	}
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+
+	enum {
+	// attrs layout for
+		// - all types:
+		RAP_HASH_VOLATILE		= 1U << 31,
+		RAP_HASH_NOT_VOLATILE		= 1U << 30,
+		RAP_HASH_CONST			= 1U << 29,
+		RAP_HASH_NOT_CONST		= 1U << 28,
+
+		// - pointer types:
+		RAP_HASH_RESTRICT		= 1U << 27,
+		RAP_HASH_NOT_RESTRICT		= 1U << 26,
+
+		// - C integer types:
+		RAP_HASH_UNSIGNED		= 1U << 25,
+		RAP_HASH_SIGNED			= 1U << 24,
+
+		RAP_HASH_UNQUALIFIED_CHAR	= 1U << 23,
+		RAP_HASH_CHAR			= 1U << 22,
+		RAP_HASH_SHORT			= 1U << 21,
+		RAP_HASH_INT			= 1U << 20,
+		RAP_HASH_LONG			= 1U << 19,
+		RAP_HASH_LONG_LONG		= 1U << 18,
+		RAP_HASH_WCHAR			= 1U << 17,
+		RAP_HASH_CHAR16			= 1U << 16,
+		RAP_HASH_CHAR32			= 1U << 15,
+
+		// - C float types
+		RAP_HASH_FLOAT			= 1U << 14,
+		RAP_HASH_DOUBLE			= 1U << 13,
+		RAP_HASH_LONG_DOUBLE		= 1U << 12,
+		RAP_HASH_DFLOAT32		= 1U << 11,
+		RAP_HASH_DFLOAT64		= 1U << 10,
+		RAP_HASH_DFLOAT128		= 1U << 9,
+	};
+
+	attrs = 0;
+	if (flags.qual_volatile)
+		attrs |= TYPE_VOLATILE(type) ? RAP_HASH_VOLATILE : RAP_HASH_NOT_VOLATILE;
+	if (flags.qual_const)
+		attrs |= TYPE_READONLY(type) ? RAP_HASH_CONST : RAP_HASH_NOT_CONST;
+
+	switch (code) {
+	default:
+		debug_tree(type);
+		gcc_unreachable();
+		break;
+
+	case VOID_TYPE:
+		break;
+
+	case OFFSET_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_tree(TYPE_OFFSET_BASETYPE(type), flags, sip_hash);
+		break;
+
+	case FUNCTION_TYPE:
+		rap_hash_function(type, flags, sip_hash);
+		break;
+
+	case RECORD_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case UNION_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case POINTER_TYPE:
+	case REFERENCE_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case VECTOR_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_type_precision(TREE_TYPE(type), sip_hash);
+		break;
+
+	case ARRAY_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case REAL_TYPE: {
+		const_tree main_variant = TYPE_MAIN_VARIANT(type);
+
+		switch (TYPE_PRECISION(main_variant)) {
+		default:
+			debug_tree(type);
+			debug_tree(TYPE_MAIN_VARIANT(type));
+			gcc_unreachable();
+
+		case 32:
+//			attrs |= RAP_HASH_FLOAT;
+			break;
+
+		case 64:
+//			attrs |= RAP_HASH_DOUBLE;
+			break;
+
+		case 80:
+		case 128:
+			attrs |= RAP_HASH_LONG_DOUBLE;
+			break;
+		}
+		rap_hash_type_precision(main_variant, sip_hash);
+		break;
+	}
+
+	case ENUMERAL_TYPE:
+		rap_hash_type_name(type, sip_hash);
+	case BOOLEAN_TYPE:
+		rap_hash_type_precision(type, sip_hash);
+		break;
+
+	case INTEGER_TYPE: {
+		attrs |= TYPE_UNSIGNED(type) ? RAP_HASH_UNSIGNED : RAP_HASH_SIGNED;
+		rap_hash_type_precision(type, sip_hash);
+		break;
+	}
+	}
+
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+}
+
+static const_tree rap_dequal_argtype(const_tree argtype)
+{
+	// since gcc/tree.c:free_lang_data_in_type removes const/volatile from the top level param decl
+	// we have to simulate it here as this can be called earlier from the frontend as well
+	if (TYPE_READONLY(argtype) || TYPE_VOLATILE(argtype)) {
+		int quals;
+
+		quals = TYPE_QUALS(argtype) & ~TYPE_QUAL_CONST & ~TYPE_QUAL_VOLATILE;
+		argtype = build_qualified_type(CONST_CAST_TREE(argtype), quals);
+	}
+
+	return argtype;
+}
+
+// main function to compute the rap hash for function types
+// while virtual class methods are always replaced with their ancestor,
+// callers can decide whether to fully utilize that information via flags.method_ancestor
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	function_args_iterator args_iter;
+	const_tree arg;
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fntype);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		// 1. hash the result
+		rap_hash_tree(TREE_TYPE(fntype), flags, sip_hash);
+
+		// 2. hash the function parameters
+		FOREACH_FUNCTION_ARGS(fntype, arg, args_iter) {
+			const_tree argtype = arg;
+
+			argtype = rap_dequal_argtype(argtype);
+			rap_hash_tree(argtype, flags, sip_hash);
+		}
+		break;
+	}
+}
+
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags)
+{
+	unsigned char sip_hash[8] = { };
+	rap_hash_t hash;
+
+	rap_hash_function(fntype, flags, sip_hash);
+	hash = rap_extract_hash(sip_hash);
+
+	gcc_assert(hash.hash);
+	return hash;
+}
+
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags)
+{
+	tree fntype;
+
+	gcc_assert(TREE_CODE(fndecl) == FUNCTION_DECL);
+	fntype = TREE_TYPE(fndecl);
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fndecl);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		return rap_hash_function_type(fntype, flags);
+	}
+}
+
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node)
+{
+	rap_hash_t hash;
+	tree fndecl;
+	int uid;
+
+	gcc_assert(rap_imprecise_hashes);
+
+	hash.hash = 0;
+#if BUILDING_GCC_VERSION < 9003
+	uid = node->uid;
+#else
+	uid = node->get_uid();
+#endif
+	if (uid < rap_cgraph_max_uid)
+		hash = rap_imprecise_hashes[uid];
+
+	if (hash.hash)
+		return hash;
+
+	fndecl = NODE_DECL(node);
+	if (TREE_CODE(TREE_TYPE(fndecl)) == FUNCTION_TYPE)
+		return rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	debug_cgraph_node(node);
+	debug_tree(fndecl);
+	error("indirect call to function %qD with a reserved hash value", fndecl);
+	return hash;
+}
+
+void rap_calculate_func_hashes(void *event_data __unused, void *data __unused)
+{
+	cgraph_node_ptr node;
+	int uid;
+
+	gcc_assert(!rap_imprecise_hashes);
+
+	rap_imprecise_hashes = (rap_hash_t *)xcalloc(cgraph_max_uid, sizeof(*rap_imprecise_hashes));
+	rap_cgraph_max_uid = cgraph_max_uid;
+
+	FOR_EACH_FUNCTION(node) {
+		const_tree fndecl;
+
+#if BUILDING_GCC_VERSION < 9003
+		uid = node->uid;
+#else
+		uid = node->get_uid();
+#endif
+		gcc_assert(uid < rap_cgraph_max_uid);
+
+#if BUILDING_GCC_VERSION < 10000
+		if (node->global.inlined_to)
+#else
+		if (node->inlined_to)
+#endif
+			continue;
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+
+		rap_imprecise_hashes[uid] = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+		gcc_assert(rap_imprecise_hashes[uid].hash);
+	}
+}
diff --git a/scripts/gcc-plugins/rap_plugin/rap_plugin.c b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
new file mode 100644
index 000000000000..b05e0bf95753
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
@@ -0,0 +1,557 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ *
+ * Usage:
+ * $ # for 4.5/4.6/C based 4.7
+ * $ gcc -I`gcc -print-file-name=plugin`/include -I`gcc -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ # for C++ based 4.7/4.8+
+ * $ g++ -I`g++ -print-file-name=plugin`/include -I`g++ -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ gcc -fplugin=./rap_plugin.so -fplugin-arg-rap_plugin-check=call test.c -O2
+ */
+
+#include "rap.h"
+
+__visible int plugin_is_GPL_compatible;
+
+static struct plugin_info rap_plugin_info = {
+	.version	= "201604272100",
+	.help		= "check=call\tenable the corresponding features\n"
+			  "hash=abs,abs-finish,const,volatile\n"
+			  "report=func,fptr,abs\n"
+};
+
+rap_hash_flags_t imprecise_rap_hash_flags = {
+	.qual_const	= 1,
+	.qual_volatile	= 1,
+};
+
+tree rap_hash_type_node;
+
+static bool report_func_hash, report_abs_hash;
+
+// create the equivalent of
+// asm volatile("" : : : "memory");
+// or
+// asm("" : "+rm"(var));
+// or
+// asm("" : : "rm"(var));
+gimple barrier(tree var, bool full)
+{
+	gimple stmt;
+	gasm *asm_stmt;
+#if BUILDING_GCC_VERSION <= 4007
+	VEC(tree, gc) *inputs = NULL;
+	VEC(tree, gc) *outputs = NULL;
+	VEC(tree, gc) *clobbers = NULL;
+#else
+	vec<tree, va_gc> *inputs = NULL;
+	vec<tree, va_gc> *outputs = NULL;
+	vec<tree, va_gc> *clobbers = NULL;
+#endif
+
+	if (!var && full) {
+		tree clobber;
+
+		clobber = build_tree_list(NULL_TREE, build_string(7, "memory"));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, clobbers, clobber);
+#else
+		vec_safe_push(clobbers, clobber);
+#endif
+	} else if (full) {
+		tree input, output;
+
+		input = build_tree_list(NULL_TREE, build_string(2, "0"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+
+		output = build_tree_list(NULL_TREE, build_string(4, "=rm"));
+		gcc_assert(SSA_NAME_VAR(var));
+		var = make_ssa_name(SSA_NAME_VAR(var), NULL);
+		output = chainon(NULL_TREE, build_tree_list(output, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, outputs, output);
+#else
+		vec_safe_push(outputs, output);
+#endif
+	} else {
+		tree input;
+
+		input = build_tree_list(NULL_TREE, build_string(3, "rm"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+	}
+
+	stmt = gimple_build_asm_vec("", inputs, outputs, clobbers, NULL);
+	asm_stmt = as_a_gasm(stmt);
+	if (!var && full)
+		gimple_asm_set_volatile(asm_stmt, true);
+	else if (full)
+		SSA_NAME_DEF_STMT(var) = stmt;
+	return stmt;
+}
+
+static const struct gcc_debug_hooks *old_debug_hooks;
+static struct gcc_debug_hooks rap_debug_hooks;
+
+static bool __rap_cgraph_indirectly_callable(cgraph_node_ptr node, void *data)
+{
+#if BUILDING_GCC_VERSION >= 4008
+	if (NODE_SYMBOL(node)->externally_visible)
+#else
+	if (node->local.externally_visible)
+#endif
+		return true;
+
+	if (NODE_SYMBOL(node)->address_taken)
+		return true;
+
+	return false;
+}
+
+static bool rap_cgraph_indirectly_callable(cgraph_node_ptr node)
+{
+	return cgraph_for_node_and_aliases(node, __rap_cgraph_indirectly_callable, NULL, true);
+}
+
+static void rap_hash_align(tree decl)
+{
+	const unsigned HOST_WIDE_INT rap_hash_offset = TARGET_64BIT ? 2 * sizeof(rap_hash_t) : sizeof(rap_hash_t);
+	unsigned HOST_WIDE_INT skip;
+
+#if BUILDING_GCC_VERSION < 9003
+	skip = 1ULL << align_functions_log;
+#else
+	skip = 1ULL <<  align_functions.levels[0].log;
+#endif
+	if (DECL_USER_ALIGN(decl))
+		return;
+
+	if (!optimize_function_for_speed_p(cfun)) {
+		ASM_OUTPUT_ASCII(asm_out_file, "\xb8", 1);
+		return;
+	}
+
+	if (skip <= rap_hash_offset)
+		return;
+
+#ifdef TARGET_64BIT
+	{
+		char padding[RAP_HASH_START_PADDING_SIZE];
+
+		// this byte sequence helps disassemblers not trip up on the following rap hash
+		//memset(padding, 0xcc, sizeof padding - 1);
+		padding[sizeof padding - 1] = 0xb8;
+		ASM_OUTPUT_ASCII(asm_out_file, padding, sizeof padding);
+	}
+#else
+	ASM_OUTPUT_SKIP(asm_out_file, skip - rap_hash_offset);
+#endif
+}
+
+static void rap_begin_function(tree decl)
+{
+	cgraph_node_ptr node;
+	rap_hash_t imprecise_rap_hash;
+	char *name = NULL;
+#if 0
+	char end_padding[RAP_HASH_END_PADDING_SIZE];
+
+	memset(end_padding, 0xcc, sizeof end_padding);
+#endif
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	// chain to previous callback
+	if (old_debug_hooks && old_debug_hooks->begin_function)
+		old_debug_hooks->begin_function(decl);
+
+	// don't compute hash for functions called only directly
+	node = cgraph_get_node(decl);
+	gcc_assert(node);
+	if (!rap_cgraph_indirectly_callable(node)) {
+		imprecise_rap_hash.hash = 0;
+		return;
+	} else {
+		imprecise_rap_hash = rap_hash_function_node_imprecise(node);
+	}
+
+	gcc_assert(asprintf(&name, "__cfi_%s", IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl))) != -1);
+	if (TREE_PUBLIC(decl)) {
+		if (lookup_attribute("weak", DECL_ATTRIBUTES(decl)))
+			fprintf(asm_out_file, "\t.weak\t%s\n", name);
+		else
+			fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	}
+
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "function");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+
+	// align the rap hash if necessary
+	rap_hash_align(decl);
+
+	if (report_func_hash)
+		inform(DECL_SOURCE_LOCATION(decl), "func rap_hash: %x %s", imprecise_rap_hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+	fprintf(asm_out_file, "\t.long %#x\t%s __kcfi_typeid_%s\n", imprecise_rap_hash.hash, ASM_COMMENT_START, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+#if 0
+	ASM_OUTPUT_ASCII(asm_out_file, end_padding, sizeof end_padding);
+#endif
+	fprintf(asm_out_file, "\t.size\t%s, .-%s\n", name, name);
+}
+
+static void rap_start_unit_common(void *gcc_data __unused, void *user_data __unused)
+{
+	rap_hash_type_node = long_integer_type_node;
+
+	if (debug_hooks)
+		rap_debug_hooks = *debug_hooks;
+	rap_debug_hooks.begin_function = rap_begin_function;
+	old_debug_hooks = debug_hooks;
+	debug_hooks = &rap_debug_hooks;
+}
+
+/*
+   emit an absolute symbol for each function that may be referenced through the plt
+     - all externs
+     - non-static functions
+       - use visibility instead?
+
+   .globl __rap_hash_func
+   .offset 0xhash_for_func
+   .type __rap_hash_func, @object
+   __rap_hash_func:
+   .previous
+*/
+static void rap_finish_unit(void *gcc_data __unused, void *user_data __unused)
+{
+	cgraph_node_ptr node;
+	rap_hash_t hash;
+
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	hash.hash = 0;
+	FOR_EACH_FUNCTION(node) {
+		tree fndecl;
+		const char *asmname;
+		char *name = NULL;
+
+		if (cgraph_function_body_availability(node) >= AVAIL_INTERPOSABLE) {
+			if (node->thunk || node->alias)
+				continue;
+			if (!rap_cgraph_indirectly_callable(node))
+				continue;
+		}
+
+#if BUILDING_GCC_VERSION >= 4007
+		gcc_assert(cgraph_function_or_thunk_node(node, NULL) == node);
+#endif
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+		if (DECL_IS_UNDECLARED_BUILTIN(fndecl) && DECL_BUILT_IN_CLASS(fndecl) == BUILT_IN_NORMAL)
+			continue;
+
+		if (!TREE_PUBLIC(fndecl))
+			continue;
+
+		if (DECL_ARTIFICIAL(fndecl))
+			continue;
+
+		if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+			continue;
+
+		gcc_assert(DECL_ASSEMBLER_NAME(fndecl));
+		asmname = IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl));
+		if (strchr(asmname, '.'))
+			continue;
+
+		if (asmname[0] == '*')
+			asmname++;
+
+		gcc_assert(asmname[0]);
+		gcc_assert(asprintf(&name, "__kcfi_typeid_%s", asmname) != -1);
+
+		hash = rap_hash_function_node_imprecise(node);
+		if (report_abs_hash)
+			inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl)));
+
+		fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+		ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+		ASM_OUTPUT_LABEL(asm_out_file, name);
+		free(name);
+	}
+
+	if (hash.hash)
+		fprintf(asm_out_file, "\t.previous\n");
+}
+
+#if BUILDING_GCC_VERSION >= 4007
+// emit the rap hash as an absolute symbol for all functions seen in the frontend
+// this is necessary as later unreferenced nodes will be removed yet we'd like to emit as many hashes as possible
+static void rap_finish_decl(void *event_data, void *data __unused)
+{
+	tree fndecl = (tree)event_data;
+	rap_hash_t hash;
+	const char *asmname;
+	char *name = NULL;
+
+	if (fndecl == error_mark_node)
+		return;
+
+	if (TREE_CODE(fndecl) != FUNCTION_DECL)
+		return;
+
+	if (!TREE_PUBLIC(fndecl))
+		return;
+
+	if (DECL_ARTIFICIAL(fndecl))
+		return;
+
+	if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+		return;
+
+	asmname = DECL_NAME_POINTER(fndecl);
+	gcc_assert(asmname[0]);
+
+	if (strchr(asmname, '.'))
+		return;
+
+	gcc_assert(asprintf(&name, "__kcfi_typeid_%s", asmname) != -1);
+
+	hash = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	if (report_abs_hash)
+		inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, asmname);
+
+	fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	if (TARGET_64BIT)
+		fprintf(asm_out_file, "\t.offset %#lx\n", (long)hash.hash);
+	else
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+	free(name);
+
+	fprintf(asm_out_file, "\t.previous\n");
+}
+#endif
+
+static bool rap_unignore_gate(void)
+{
+	if (!DECL_IGNORED_P(current_function_decl))
+		return false;
+
+	inform(DECL_SOURCE_LOCATION(current_function_decl), "DECL_IGNORED fixed");
+
+	DECL_IGNORED_P(current_function_decl) = 0;
+	return false;
+}
+
+#define PASS_NAME rap_unignore
+#define NO_EXECUTE
+#define TODO_FLAGS_FINISH TODO_dump_func
+#include "gcc-generate-rtl-pass.h"
+
+static bool rap_version_check(struct plugin_gcc_version *gcc_version, struct plugin_gcc_version *plugin_version)
+{
+	if (!gcc_version || !plugin_version)
+		return false;
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (strncmp(gcc_version->basever, plugin_version->basever, 4))
+#else
+	if (strcmp(gcc_version->basever, plugin_version->basever))
+#endif
+		return false;
+	if (strcmp(gcc_version->datestamp, plugin_version->datestamp))
+		return false;
+	if (strcmp(gcc_version->devphase, plugin_version->devphase))
+		return false;
+	if (strcmp(gcc_version->revision, plugin_version->revision))
+		return false;
+//	if (strcmp(gcc_version->configuration_arguments, plugin_version->configuration_arguments))
+//		return false;
+	return true;
+}
+
+EXPORTED_CONST struct ggc_root_tab gt_ggc_r_gt_rap[] = {
+	{
+		.base = &rap_hash_type_node,
+		.nelt = 1,
+		.stride = sizeof(rap_hash_type_node),
+		.cb = &gt_ggc_mx_tree_node,
+		.pchw = &gt_pch_nx_tree_node
+	},
+	LAST_GGC_ROOT_TAB
+};
+
+static void
+handle_type_cast (void *gcc_data, void *user_data)
+{
+  (void) user_data;
+  tree *t = (tree *) gcc_data;
+  tree type = t[0];
+  tree otype = t[1];
+
+  if (TREE_CODE (type) == POINTER_TYPE
+      && TREE_CODE (otype) == POINTER_TYPE
+      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE
+      && TREE_CODE (TREE_TYPE (otype)) == FUNCTION_TYPE
+//      && type != TYPE_MAIN_VARIANT (otype)
+      && TYPE_CANONICAL (TREE_TYPE (type)) != TYPE_CANONICAL (TREE_TYPE (otype)))
+        error (G_("cast from function type %qT "
+                  "to non-matching type %qT"), otype, type);
+
+}
+
+__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	int i;
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	bool enable_call = false;
+	bool enable_abs = false, enable_abs_finish = false;
+
+	struct register_pass_info rap_fptr_pass_info;
+	struct register_pass_info rap_unignore_pass_info;
+
+	rap_fptr_pass_info.pass						= make_rap_fptr_pass();
+	rap_fptr_pass_info.reference_pass_name				= "nrv";
+	rap_fptr_pass_info.ref_pass_instance_number			= 1;
+	rap_fptr_pass_info.pos_op 					= PASS_POS_INSERT_AFTER;
+
+	rap_unignore_pass_info.pass					= make_rap_unignore_pass();
+	rap_unignore_pass_info.reference_pass_name			= "final";
+	rap_unignore_pass_info.ref_pass_instance_number			= 1;
+	rap_unignore_pass_info.pos_op 					= PASS_POS_INSERT_BEFORE;
+
+	if (!rap_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (flag_ipa_icf_functions) {
+//		warning_at(UNKNOWN_LOCATION, 0, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+//		inform(UNKNOWN_LOCATION, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+		flag_ipa_icf_functions = 0;
+	}
+#endif
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "disable"))
+			continue;
+
+		if (!strcmp(argv[i].key, "check")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "call"))
+					enable_call = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "hash")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "abs"))
+					enable_abs = enable_abs_finish = true;
+				else if (!strcmp(value, "abs-finish"))
+					enable_abs_finish = true;
+//				else if (!strcmp(value, "const"))
+//					imprecise_rap_hash_flags.qual_const = 1;
+//				else if (!strcmp(value, "volatile"))
+//					imprecise_rap_hash_flags.qual_volatile = 1;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "report")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "func"))
+					report_func_hash = true;
+				else if (!strcmp(value, "fptr"))
+					report_fptr_hash = true;
+				else if (!strcmp(value, "abs"))
+					report_abs_hash = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &rap_plugin_info);
+
+	if (enable_call) {
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_fptr_pass_info);
+	}
+
+	if (enable_call || enable_abs_finish) {
+#if BUILDING_GCC_VERSION >= 4007
+		if (enable_abs)
+			register_callback(plugin_name, PLUGIN_FINISH_DECL, rap_finish_decl, NULL);
+#else
+#warning TODO
+#endif
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_unignore_pass_info);
+		register_callback(plugin_name, PLUGIN_REGISTER_GGC_ROOTS, NULL, (void *)&gt_ggc_r_gt_rap);
+		register_callback(plugin_name, PLUGIN_START_UNIT, rap_start_unit_common, NULL);
+		if (enable_abs_finish)
+			register_callback(plugin_name, PLUGIN_FINISH_UNIT, rap_finish_unit, NULL);
+		register_callback(plugin_name, PLUGIN_ALL_IPA_PASSES_START, rap_calculate_func_hashes, NULL);
+		register_callback (plugin_name, PLUGIN_TYPE_CAST, handle_type_cast, NULL);
+	}
+	return 0;
+}
diff --git a/scripts/gcc-plugins/rap_plugin/sip.c b/scripts/gcc-plugins/rap_plugin/sip.c
new file mode 100644
index 000000000000..65bc1cdea580
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/sip.c
@@ -0,0 +1,96 @@
+// SipHash-2-4 adapted by the PaX Team from the public domain version written by
+//   Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
+//   Daniel J. Bernstein <djb@cr.yp.to>
+
+#include <stdint.h>
+
+#define ROTL(x, b) (u64)(((x) << (b)) | ((x) >> (64 - (b))))
+
+#define U32TO8_LE(p, v)						\
+	(p)[0] = (u8)((v)      ); (p)[1] = (u8)((v) >>  8);	\
+	(p)[2] = (u8)((v) >> 16); (p)[3] = (u8)((v) >> 24);
+
+#define U64TO8_LE(p, v)				\
+	U32TO8_LE((p),     (u32)((v)      ));	\
+	U32TO8_LE((p) + 4, (u32)((v) >> 32));
+
+#define U8TO64_LE(p)	(	\
+	((u64)((p)[0])      ) |	\
+	((u64)((p)[1]) <<  8) |	\
+	((u64)((p)[2]) << 16) |	\
+	((u64)((p)[3]) << 24) |	\
+	((u64)((p)[4]) << 32) |	\
+	((u64)((p)[5]) << 40) |	\
+	((u64)((p)[6]) << 48) |	\
+	((u64)((p)[7]) << 56))
+
+#define SIPROUND							\
+do {									\
+	v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; v0 = ROTL(v0, 32);	\
+	v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2;				\
+	v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0;				\
+	v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; v2 = ROTL(v2, 32);	\
+} while(0)
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint8_t u8;
+
+/* SipHash-2-4 with previous output folding, a poor man's streaming interface */
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k)
+{
+	u64 k0 = U8TO64_LE(k);
+	u64 k1 = U8TO64_LE(k + 8);
+	/* "somepseudorandomlygeneratedbytes" */
+	u64 v0 = 0x736f6d6570736575ULL ^ k0;
+	u64 v1 = 0x646f72616e646f6dULL ^ k1;
+	u64 v2 = 0x6c7967656e657261ULL ^ k0;
+	u64 v3 = 0x7465646279746573ULL ^ k1;
+	u64 b, m;
+	const u8 * const end = in + inlen - (inlen % sizeof(u64));
+	const int left = inlen & 7;
+	b = ((u64)inlen) << 56;
+
+	// fold in the previous output
+	m = U8TO64_LE(out);
+	v3 ^= m;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= m;
+
+	// consume full input blocks
+	for (; in != end; in += 8) {
+		m = U8TO64_LE(in);
+		v3 ^= m;
+		SIPROUND;
+		SIPROUND;
+		v0 ^= m;
+	}
+
+	// consume the last potentially partial block
+	switch (left) {
+	case 7: b |= ((u64)in[6]) << 48;
+	case 6: b |= ((u64)in[5]) << 40;
+	case 5: b |= ((u64)in[4]) << 32;
+	case 4: b |= ((u64)in[3]) << 24;
+	case 3: b |= ((u64)in[2]) << 16;
+	case 2: b |= ((u64)in[1]) <<  8;
+	case 1: b |= ((u64)in[0]); break;
+	case 0: break;
+	}
+
+	// finalize
+	v3 ^= b;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= b;
+	v2 ^= 0xff;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	b = v0 ^ v1 ^ v2 ^ v3;
+	U64TO8_LE(out, b);
+}
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 107393a8c48a..0a80e61fbfd9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1683,15 +1683,9 @@ static void check_exports(struct module *mod)
 		const char *basename;
 		exp = find_symbol(s->name);
 		if (!exp) {
-			if (!s->weak && nr_unresolved++ < MAX_UNRESOLVED_REPORTS)
-				modpost_log(!warn_unresolved,
-					    "\"%s\" [%s.ko] undefined!\n",
-					    s->name, mod->name);
 			continue;
 		}
 		if (exp->module == mod) {
-			error("\"%s\" [%s.ko] was exported without definition\n",
-			      s->name, mod->name);
 			continue;
 		}
 
diff --git a/security/Kconfig b/security/Kconfig
index 28e685f53bd1..c1b1c69df447 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -5,6 +5,35 @@
 
 menu "Security options"
 
+menuconfig PAX
+	bool "Enable various PaX features"
+	depends on X86
+	help
+	  This allows you to enable various PaX features.  PaX adds
+	  intrusion prevention mechanisms to the kernel that reduce
+	  the risks posed by exploitable memory corruption bugs.
+
+if PAX
+config PAX_RAP
+	bool "Prevent code reuse attacks"
+	depends on X86_64 && GCC_PLUGINS
+	select CFI_CLANG
+	help
+	  By saying Y here the kernel will check indirect control transfers
+	  in order to detect and prevent attacks that try to hijack control
+	  flow by overwriting code pointers.
+
+	  If you have an amd64 processor that does not support SMEP then you
+	  must also enable a KERNEXEC code pointer instrumentation method
+	  (see PAX_KERNEXEC_PLUGIN).
+
+	  Note that binary modules cannot be instrumented by this approach.
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+endif
+
 source "security/keys/Kconfig"
 
 config SECURITY_DMESG_RESTRICT
-- 
2.39.4

