From 14e2b800b7e293ac07b5c61fa5beeccb119f78db Mon Sep 17 00:00:00 2001
From: Albert Guo <aguo@vmware.com>
Date: Thu, 5 Nov 2020 08:43:03 -0800
Subject: [PATCH] [9p] Ensure seekdir take effect when entries in readdir buf
 hasn't been ran out.

When running Samba server in a 9p mount point, we discovered a wide directory
can't be listed correctly from Windows client due to a bug in Linux 9p driver.
The problem is Windows client can seek to an offset while directory entries
in the readdir buffer hasn't been run out. In this case, the directory seek
isn't honored. The 9p driver still return entries from cache according to old
current position.

I wrote a test program which mimic the above behavior, and the issue can be
reproduced.

The fix is to force 9p driver to call TREADDIR whenever
seekdir(v9fs_dir_llseek)
is called. Please note that, if a caller just readdir sequentially, the seekdir
won't be called.

Testing Done:

I wrote a test program which reproduce the issue. Now it passed.

***Note: The fix is crossported from ph1, and this is test program only worked on ph1***

/root/readdir_test /vsfs/5d21d211-1105-4cc0-a7b8-19e6e0db841e/vdfsops0aa17ade/a875b95e-11a9-6cdf-de06-020041f286ec/volumes/default > /
tmp/readdir.out
Test passed: expectedNextName:newfile782.txt, actual next name:newfile782.txt

After my change, I can see TREADDIR starts from seeked offset: (Previously TREADDIR continues from previous readdir rather than reset offset)

\[12495.548915\] 9pnet: -- v9fs_dir_llseek (22895): name default seek to off: 230704361578168321 (0x333a06500000001)
\[12495.548921\] 9pnet: -- v9fs_dir_readdir_dotl (22895): name default
\[12495.548922\] 9pnet: (00022895) >>> TREADDIR fid 3 offset 230704361578168321 count 16276

Tested with Windows SMB client, it can list 1000 files correctly. (Note: This is verified in ph3)
---
 fs/9p/vfs_dir.c | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/fs/9p/vfs_dir.c b/fs/9p/vfs_dir.c
index 612c0d3..ad7fb4d 100644
--- a/fs/9p/vfs_dir.c
+++ b/fs/9p/vfs_dir.c
@@ -78,6 +78,36 @@ static inline int dt_type(struct p9_wstat *mistat)
 	return rettype;
 }
 
+
+/**
+ * v9fs_dir_llseek - seek to a specific offset for further readdir
+ * @file:	file structure to seek on
+ * @offset:	file offset to seek to
+ * @whence:	type of seek
+ *
+ * This is implementation for directory seek in a 9p file system
+ */
+
+static loff_t v9fs_dir_llseek(struct file *file, loff_t offset, int whence)
+{
+	struct p9_fid *fid = file->private_data;
+	struct p9_rdir *rdir = fid->rdir;
+
+	/*
+	 * Reset head so that v9fs_dir_readdir_xxx will call p9_client_readdir to
+	 * refetch dir entries.
+	 * Some applications may reset the offset before previous readdir finishes.
+	 */
+	if (rdir) {
+		rdir->head = rdir->tail;
+	}
+
+	p9_debug(P9_DEBUG_VFS, "name %pD seek to off: %lld (0x%llx)\n",
+			file, offset, offset);
+	return generic_file_llseek(file, offset, whence);
+}
+
+
 /**
  * v9fs_alloc_rdir_buf - Allocate buffer used for read and readdir
  * @filp: opened file structure
@@ -236,7 +266,7 @@ int v9fs_dir_release(struct inode *inode, struct file *filp)
 
 const struct file_operations v9fs_dir_operations = {
 	.read = generic_read_dir,
-	.llseek = generic_file_llseek,
+	.llseek = v9fs_dir_llseek,
 	.iterate_shared = v9fs_dir_readdir,
 	.open = v9fs_file_open,
 	.release = v9fs_dir_release,
@@ -244,7 +274,7 @@ int v9fs_dir_release(struct inode *inode, struct file *filp)
 
 const struct file_operations v9fs_dir_operations_dotl = {
 	.read = generic_read_dir,
-	.llseek = generic_file_llseek,
+	.llseek = v9fs_dir_llseek,
 	.iterate_shared = v9fs_dir_readdir_dotl,
 	.open = v9fs_file_open,
 	.release = v9fs_dir_release,
-- 
1.8.5.6

