From 3a0be710499be4a13c825cf80c70dcf7b795f366 Mon Sep 17 00:00:00 2001
From: Ankit Jain <ankitja@vmware.com>
Date: Wed, 10 Nov 2021 14:07:43 +0000
Subject: [PATCH] fs: TARFS file system to mount TAR archive

- GNU/POSIX TAR Archive consists of header with information of the
files and directories. The start address of the file stored in a
field in the header itself which help to navigate to the file content.

- Tar archive can be attach to loop device and passed as input
that can be easily mounted instead of extraction using tarfs.
Tarfs does block device mount.
- TARFS only creates and maintains metadata, inodes and dentries
of files & directries. For a file, the entry for that particular
file will point to the start address offset of the TAR archive
whenever the file is read or executed.

- Mounting operation is very quick and avoids additional memory
allocation for file content data.

Signed-off-by: Srinidhi Rao <srinidhir@vmware.com>
Signed-off-by: Alexey Makhalov <amakhalov@vmware.com>
Signed-off-by: Ankit Jain <ankitja@vmware.com>
Signed-off-by: Ashwin Dayanand Kamat <kashwindayan@vmware.com>
---
 fs/Kconfig                    |   1 +
 fs/Makefile                   |   1 +
 fs/tarfs/Kconfig              |  18 +
 fs/tarfs/Makefile             |  16 +
 fs/tarfs/README.md            |  64 +++
 fs/tarfs/tarfs.h              | 180 +++++++++
 fs/tarfs/tarfs_file_dir_ops.c | 483 +++++++++++++++++++++++
 fs/tarfs/tarfs_inode.c        | 706 ++++++++++++++++++++++++++++++++++
 8 files changed, 1469 insertions(+)
 create mode 100644 fs/tarfs/Kconfig
 create mode 100644 fs/tarfs/Makefile
 create mode 100644 fs/tarfs/README.md
 create mode 100644 fs/tarfs/tarfs.h
 create mode 100644 fs/tarfs/tarfs_file_dir_ops.c
 create mode 100644 fs/tarfs/tarfs_inode.c

diff --git a/fs/Kconfig b/fs/Kconfig
index 66b33458e8d5..5943826320e7 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -256,6 +256,7 @@ source "fs/sysv/Kconfig"
 source "fs/ufs/Kconfig"
 source "fs/exofs/Kconfig"
 source "fs/vtarfs/Kconfig"
+source "fs/tarfs/Kconfig"
 
 endif # MISC_FILESYSTEMS
 
diff --git a/fs/Makefile b/fs/Makefile
index 839321e7c3c8..69b9c79a58b8 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -129,3 +129,4 @@ obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
 obj-$(CONFIG_EFIVAR_FS)		+= efivarfs/
 obj-$(CONFIG_VTARFS)		+= vtarfs/
+obj-$(CONFIG_TARFS)		+= tarfs/
diff --git a/fs/tarfs/Kconfig b/fs/tarfs/Kconfig
new file mode 100644
index 000000000000..0a17f17cf2c8
--- /dev/null
+++ b/fs/tarfs/Kconfig
@@ -0,0 +1,18 @@
+config TARFS
+	tristate "TARFS file system support"
+	depends on TMPFS
+	help
+	  TARFS is a read-only filesystem use to mount the GNU/POSIX format
+	  tar archive as block device so that extracting such archive will
+	  no longer be necessary. The files will appear in the mounted directory
+	  path. The start address of each file is stored as an offset in the
+	  TAR Header itself which helps to navigate to the start of file content.
+
+	  This file system will mount the TAR archive as READ ONLY.
+
+	  Usually container base images are stored as TAR archive.
+
+	  Say Y or M if you want to mount files from TAR archive.
+
+	  To compile this file system support as a module, choose M here: the
+	  module will be called tarfs. If unsure, say N.
diff --git a/fs/tarfs/Makefile b/fs/tarfs/Makefile
new file mode 100644
index 000000000000..9341ea2f36fb
--- /dev/null
+++ b/fs/tarfs/Makefile
@@ -0,0 +1,16 @@
+##
+ # Makefile for the tarfs routines.
+ #
+ # Copyright 2021 VMware, Inc. All Rights Reserved.
+ # SPDX-License-Identifier: GPL v2.0
+ #
+ # Licensed under the GNU Lesser General Public License version 2 (the "License");
+ # you may not use this file except in compliance with the License. The terms
+ # of the License are located in the LICENSE file of this distribution.
+##
+
+obj-$(CONFIG_TARFS) += tarfs.o
+
+CFLAGS_tarfs_file_dir_ops.o := -I$(src)
+CFLAGS_tarfs_inode.o := -I$(src)
+tarfs-objs := tarfs_file_dir_ops.o tarfs_inode.o
diff --git a/fs/tarfs/README.md b/fs/tarfs/README.md
new file mode 100644
index 000000000000..2ad226a2f61d
--- /dev/null
+++ b/fs/tarfs/README.md
@@ -0,0 +1,64 @@
+# tarfs
+
+tarfs is implemented as Linux kernel module filesystem driver.
+
+## Features
+
+* Supports GNU and POSIX format tar files
+* Regular files, directories and symlinks
+* UID, GID, access/modification/creation time
+* Read-only access to files and directories
+
+## Compiling
+
+You'll require the linux development files.  For ArchLinux, you need the
+`linux-headers` packet.
+
+After that, just run `make` to build the `tarfs.ko`, which is a loadable
+kernel module.
+
+**Note**: The module was tested with Linux `4.19.xxx`, on a `x64 ArchLinux`
+          computer.
+
+## Usage
+
+```sh
+# If not already done, build the module
+make
+
+# Now you can load the module:
+sudo insmod tarfs.ko
+
+# You need a mount directory
+mkdir mnt
+
+# Mount some tar archive.  A test one is included:
+sudo mount test.tar -o loop -t tarfs mnt
+
+# Discover the archives content
+ls mnt -R
+cat mnt/hello.c
+
+# Unmount
+sudo umount mnt
+
+# And unload the kernel module
+sudo rmmod tarfs.ko
+```
+
+## File overview
+
+* **tarfs_inode.c** Code to read the underlying block device and creates metadata
+* **tarfs_file_dir_ops.c** Code for file and directory operations
+* **tarfs.h** Header definition for tar files, taken from
+  https://www.gnu.org/software/tar/manual/html_node/Standard.html
+
+## Implementation
+
+This project focuses on the interaction part with Linux.  That's why the
+implementation of the Tar reading code is kept really simple: On mount, all
+file entries are read from the tar file, and stored as a radix tree.
+
+File system operations are quite faster as they are implemented
+as radix tree (A trie data structure)
+
diff --git a/fs/tarfs/tarfs.h b/fs/tarfs/tarfs.h
new file mode 100644
index 000000000000..bdae08ad68f3
--- /dev/null
+++ b/fs/tarfs/tarfs.h
@@ -0,0 +1,180 @@
+/*
+ * Filesystem to directly mount tar archive.
+ *
+ * Copyright 2021 VMware, Inc. All Rights Reserved.
+ * SPDX-License-Identifier: GPL v2.0
+ *
+ * Licensed under the GNU Lesser General Public License version 2 (the "License");
+ * you may not use this file except in compliance with the License. The terms
+ * of the License are located in the LICENSE file of this distribution.
+ *
+ */
+
+#ifndef tarfs
+#define tarfs
+
+#include<linux/fs.h>
+#include<linux/radix-tree.h>
+
+#define MAX_FILE_NAME_SIZE 100
+#define TARFS_BLOCK_SIZE_BITS (9)
+#define TARFS_BLOCK_SIZE (1 << TARFS_BLOCK_SIZE_BITS)
+#define DEBUG_PRINT
+#ifdef DEBUG_PRINT
+#define tarfs_debug(fmt, args...)  do {				\
+	pr_debug("[tarfs][%s:]" fmt, __FUNCTION__, ##args);	\
+}while(0);
+#else
+#define tarfs_debug(fmt, args...)
+#endif
+#define tarfs_info(fmt, args...)  do {				\
+	pr_info("[tarfs][%s:]" fmt, __FUNCTION__, ##args);	\
+}while(0);
+#define tarfs_err(fmt, args...)  do {				\
+	pr_err("[tarfs][%s:]" fmt, __FUNCTION__, ##args);	\
+}while(0);
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+
+/* Following is based on
+ * https://www.gnu.org/software/tar/manual/html_node/Standard.html
+ * which in turn references `src/tar.h` from the GNU tar project.
+ */
+#define REGTYPE  '0'            /* regular file */
+#define AREGTYPE '\0'           /* regular file */
+#define LNKTYPE  '1'            /* link */
+#define SYMTYPE  '2'            /* reserved */
+#define CHRTYPE  '3'            /* character special */
+#define BLKTYPE  '4'            /* block special */
+#define DIRTYPE  '5'            /* directory */
+#define FIFOTYPE '6'            /* FIFO special */
+#define CONTTYPE '7'            /* reserved */
+/* Identifies the *next* file on the tape as having a long linkname.  */
+#define GNUTYPE_LONGLINK 'K'
+
+/* Identifies the *next* file on the tape as having a long name.  */
+#define GNUTYPE_LONGNAME 'L'
+
+/* OLDGNU_MAGIC uses both magic and version fields, which are contiguous.
+   Found in an archive, it indicates an old GNU header format, which will be
+   hopefully become obsolescent.  With OLDGNU_MAGIC, uname and gname are
+   valid, though the header is not truly POSIX conforming.  */
+#define OLDGNU_MAGIC "ustar  "	/* 7 chars and a null */
+#define TMAGIC   "ustar"        /* ustar and a null */
+
+struct star_header
+{                              /* byte offset */
+	char name[100];               /*   0 */
+	char mode[8];                 /* 100 */
+	char uid[8];                  /* 108 */
+	char gid[8];                  /* 116 */
+	char size[12];                /* 124 */
+	char mtime[12];               /* 136 */
+	char chksum[8];               /* 148 */
+	char typeflag;                /* 156 */
+	char linkname[100];           /* 157 */
+	char magic[6];                /* 257 */
+	char version[2];              /* 263 */
+	char uname[32];               /* 265 */
+	char gname[32];               /* 297 */
+	char devmajor[8];             /* 329 */
+	char devminor[8];             /* 337 */
+	char prefix[131];             /* 345 */
+	char atime[12];               /* 476 */
+	char ctime[12];               /* 488 */
+	/* 500 */
+};
+#define TARFS_HDR_SIZE (sizeof(struct star_header))
+
+struct tarfs_entry {
+	struct star_header		header;
+	char				*dir_name;
+	char				*base_name;
+	char				*link_name;
+	unsigned int			offset;
+	unsigned int			data_offset;
+	size_t				data_size;
+	unsigned long			inode;
+	struct inode			*ptr_inode;
+	umode_t				mode;
+	uid_t				uid;
+	gid_t				gid;
+	struct timespec64 		atime;
+	struct timespec64 		mtime;
+	struct timespec64 		ctime;
+	struct tarfs_entry 		*next;
+	struct radix_tree_root 		root_tree;
+	unsigned long 			radix_root_key;
+};
+
+struct tarfs_mount_opts {
+	umode_t				mode;
+};
+
+struct tarfs_sbi {
+	struct tarfs_entry 		*first;
+	u64	 			blocks;
+	u64 				files;
+};
+
+static inline struct tarfs_sbi *TARFS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+static inline struct tarfs_entry* tarfs_get_first_entry(struct super_block *sb)
+{
+	return TARFS_SB(sb)->first;
+}
+
+extern int tarfs_file_release(struct inode *inode, struct file *file);
+extern int tarfs_getattr(const struct path *path, struct kstat *stat, u32 request_mask, unsigned int flags);
+extern int tarfs_read_dir(struct file *file, struct dir_context *ctx);
+extern mode_t tarfs_entry_mode(struct tarfs_entry *entry);
+extern ssize_t tarfs_file_read_iter(struct kiocb *iocb, struct iov_iter *to);
+extern struct dentry *tarfs_lookup(struct inode *inode, struct dentry *dentry, unsigned int flags);
+extern int tarfs_statfs(struct dentry * d, struct kstatfs *ks);
+extern struct tarfs_entry *tarfs_find(struct tarfs_entry *entry, const char *dir_name, const char *base_name);
+extern sector_t tarfs_bmap(struct address_space *mapping, sector_t block);
+extern int tarfs_readpage(struct file *file, struct page *page);
+
+static const struct file_operations tarfs_file_operations = {
+	.llseek		= generic_file_llseek,
+	.read_iter	= tarfs_file_read_iter,
+	.mmap		= generic_file_mmap,
+	.fsync		= generic_file_fsync,
+	.open		= generic_file_open,
+	.release	= tarfs_file_release,
+};
+
+static const struct inode_operations tarfs_file_inode_operations = {
+	.getattr	= tarfs_getattr,
+};
+
+static const struct inode_operations tarfs_dir_inode_operations = {
+	.lookup		= tarfs_lookup,
+	.getattr	= tarfs_getattr,
+};
+
+static const struct inode_operations tarfs_symlink_inode_operations = {
+	.get_link	= simple_get_link,
+	.getattr	= tarfs_getattr,
+};
+
+static const struct file_operations tarfs_dir_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= generic_read_dir,
+	.iterate_shared = tarfs_read_dir,
+	.fsync		= generic_file_fsync,
+};
+
+
+static const struct super_operations tarfs_super_ops = {
+	.statfs         = tarfs_statfs,
+};
+
+static const struct address_space_operations tarfs_ram_addr_ops = {
+	.readpage	= tarfs_readpage,
+	.bmap		= tarfs_bmap,
+};
+
+#endif
diff --git a/fs/tarfs/tarfs_file_dir_ops.c b/fs/tarfs/tarfs_file_dir_ops.c
new file mode 100644
index 000000000000..cccf46ea5a4f
--- /dev/null
+++ b/fs/tarfs/tarfs_file_dir_ops.c
@@ -0,0 +1,483 @@
+/*
+ * Filesystem to directly mount tar archive.
+ *
+ * Copyright 2021 VMware, Inc. All Rights Reserved.
+ * SPDX-License-Identifier: GPL v2.0
+ *
+ * Licensed under the GNU Lesser General Public License version 2 (the "License");
+ * you may not use this file except in compliance with the License. The terms
+ * of the License are located in the LICENSE file of this distribution.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/uio.h>
+#include <linux/buffer_head.h>
+#include <linux/statfs.h>
+
+#include "tarfs.h"
+
+#define WRITE_MASK (0222)
+
+mode_t tar_type_to_posix(int typeflag)
+{
+	switch(typeflag) {
+		case REGTYPE:
+		case AREGTYPE:
+		case CONTTYPE:
+			return S_IFREG;
+		case DIRTYPE:
+			return S_IFDIR;
+		case SYMTYPE:
+			return S_IFLNK;
+		case CHRTYPE:
+			return S_IFCHR;
+		case BLKTYPE:
+			return S_IFBLK;
+		case FIFOTYPE:
+			return S_IFIFO;
+
+		default:
+			return 0;
+	}
+}
+
+/**
+ * @brief Returns the POSIX file mode of \a entry.
+ * @param entry the entry to get the file mode from
+ * @return the file mode
+ */
+mode_t tarfs_entry_mode(struct tarfs_entry *entry)
+{
+	mode_t mode = entry->mode & ~WRITE_MASK;
+	mode |= tar_type_to_posix(entry->header.typeflag);
+	return mode;
+}
+EXPORT_SYMBOL(tarfs_entry_mode);
+
+/**
+ * @brief Returns the tarfs entry by searching based on inode number.
+ * @param  entry: Pointer to the ROOT entry of tarfs
+inode: inode number which is mapped to the entry to be found.
+ * @return the tarfs entry containing the inode number.
+ */
+static struct tarfs_entry *tarfs_find_by_inode(struct tarfs_entry *entry, unsigned long inode)
+{
+
+	struct tarfs_entry *entry_node = NULL;
+	struct radix_tree_iter iter;
+	void **slot = NULL;
+
+	tarfs_debug("In tarfs_find_by_node, inode = %ld", inode);
+
+	radix_tree_for_each_slot(slot, &entry->root_tree, &iter, 0) {
+
+		entry_node = radix_tree_deref_slot(slot);
+		if ( unlikely(!entry_node) )
+			continue;
+
+		if (radix_tree_exception(entry_node)) {
+			if (radix_tree_deref_retry(entry_node))
+				slot = radix_tree_iter_retry(&iter);
+			continue;
+		}
+
+		if  ( inode == entry_node->inode) {
+			tarfs_debug("\n FOUND %ld\n", entry_node->inode);
+			return entry_node;
+		}
+
+	}
+	return NULL;
+}
+
+/**
+ * @brief Returns the tarfs entry by searching based on name of the file.
+ * @param  entry: Pointer to the ROOT entry of tarfs
+dir_name: Directory name/path in which the file resides.
+base_name: Name of the file.
+ * @return the tarfs entry containing the name.
+ */
+struct tarfs_entry *tarfs_find(struct tarfs_entry *entry, const char *dir_name, const char *base_name)
+{
+	struct tarfs_entry *entry_node = NULL;
+	struct radix_tree_iter iter;
+	void **slot = NULL;
+
+	radix_tree_for_each_slot(slot, &entry->root_tree, &iter, 0) {
+
+		entry_node = radix_tree_deref_slot(slot);
+		if ( unlikely(!entry_node) )
+			continue;
+
+		if (radix_tree_exception(entry_node)) {
+			if (radix_tree_deref_retry(entry_node))
+				slot = radix_tree_iter_retry(&iter);
+			continue;
+		}
+
+		if  (!strcmp(entry_node->base_name, base_name) &&
+				!strcmp(entry_node->dir_name, dir_name)) {
+			return entry_node;
+		}
+
+	}
+	return NULL;
+}
+
+/*
+ * @brief Returns the Full name of a file by combining path and file name.
+ * @param  entry: Pointer to the entry of tarfs file
+ * @return the full name.
+ */
+static char *tarfs_full_name(struct tarfs_entry *entry)
+{
+	size_t dir_len = strlen(entry->dir_name);
+	size_t base_len = strlen(entry->base_name);
+	size_t len = dir_len + base_len + 2;
+	char *name = kzalloc(len, GFP_KERNEL);
+
+	if (!name) {
+		tarfs_err("Error in allocating memory for name %ld", PTR_ERR(name));
+		return NULL;
+	}
+
+	/* Ignore the first / for a top level directory */
+	if (dir_len < 1)
+		strncpy(name, entry->base_name, base_len);
+	else if (dir_len == 1)
+		strncpy(name, entry->dir_name, dir_len);
+	else
+		snprintf(name, len, "%s/%s",entry->dir_name, entry->base_name);
+
+	tarfs_debug("found name = %s", name);
+
+	return name;
+
+}
+
+/*
+ * @brief Returns the Full name of a file based on inode number.
+ * @param  root_entry: Pointer to the ROOT entry of tarfs file
+ *	   inode: inode pointer of the tarfs file.
+ * @return the full name.
+ */
+static char *build_lookup_path(struct inode *inode, struct tarfs_entry *root_entry)
+{
+	struct tarfs_entry *entry;
+
+	tarfs_debug("i_ino = %ld", inode->i_ino);
+	if (inode->i_ino == root_entry->radix_root_key) {
+		return kzalloc(1, GFP_KERNEL);
+	}
+
+	entry = tarfs_find_by_inode(root_entry, inode->i_ino);
+	if (!entry) {
+		tarfs_err("Failed to find inode by entry, root->entry = %s",
+				root_entry->base_name);
+		return NULL;
+	}
+
+	tarfs_debug("full_name = %s%s ", entry->dir_name, entry->base_name);
+	return tarfs_full_name(entry);
+}
+
+/*
+ * @brief Get attributes of a file or dir.
+ * @param  path: real path of the file or directory.
+ *         stat: pointer to stat structure to be filled.
+ *         request_mask: Currently unused.
+ *         flags: Currently unused.
+ * @return dentry of the file or sub dir.
+ */
+int tarfs_getattr(const struct path *path, struct kstat *stat,
+		u32 request_mask, unsigned int flags)
+{
+
+	struct inode *inode = d_inode(path->dentry);
+
+	generic_fillattr(inode, stat);
+	if (stat->blocks == 0)
+		stat->blocks = inode->i_mapping->nrpages << (PAGE_SHIFT - TARFS_BLOCK_SIZE_BITS);
+
+	return 0;
+}
+EXPORT_SYMBOL(tarfs_getattr);
+
+/*
+ * @brief Ignore all pos beyond file size
+ * @pararm inode: Pointer to inode of the directory
+ *         ctx_pos: requested pos to check
+ * @return non-zero if requested pos is less than the size of inode
+ *         else zero
+ * */
+static int beyond_eof(struct inode *inode, loff_t ctx_pos)
+{
+	loff_t pos = ctx_pos << inode->i_sb->s_blocksize_bits;
+	return pos >= i_size_read(inode);
+}
+
+/*
+ * @brief Emits the contents of a directory.
+ * @param  file: file pointer of a directory
+ *	   ctx: context of fs on how dir entries will be filled.
+ * @return 0 on SUCCESS negetive errno on failure.
+ */
+int tarfs_read_dir(struct file *file, struct dir_context *ctx)
+{
+	struct inode *inode = file_inode(file);
+	struct tarfs_entry *entry = tarfs_get_first_entry(inode->i_sb);
+	char *dir_path;
+	int namelen = 0;
+
+	if (beyond_eof(inode, ctx->pos))
+		return 0;
+	/* Loop through the entry to find matching entry node with inode */
+	if (!dir_emit_dots(file, ctx)) {
+		tarfs_err("%lld", ctx->pos);
+		return 0;
+	}
+	tarfs_debug("[%lld] [%d] [%lld]", ctx->pos, inode->i_sb->s_blocksize_bits, inode->i_size);
+	dir_path = build_lookup_path(inode, entry);
+	if (!dir_path) {
+		tarfs_err("Failed to get dir path %ld", PTR_ERR(dir_path));
+		return -ENOENT;
+	}
+	tarfs_debug("In tarfs_read_dir dir_path=%s", dir_path);
+
+	while (entry) {
+		tarfs_debug("dir_path=%s entry->dir_name = %s base_name=%s",
+				dir_path, entry->dir_name, entry->base_name );
+		if (!strcmp(dir_path, entry->dir_name)) {
+			/* Print all sub dirs by iterating through entry */
+			namelen = strlen(entry->base_name);
+			if (!dir_emit(ctx, entry->base_name, namelen,
+						entry->inode, (entry->mode >> 12))){
+				break;
+			}
+			ctx->pos++;
+		}
+		entry = entry->next;
+	}
+	tarfs_debug("dir_path=%s", dir_path);
+	kfree(dir_path);
+	return 0;
+}
+EXPORT_SYMBOL(tarfs_read_dir);
+
+/*
+ * @brief get statfs info related to super block.
+ * @param dentry: dentry information of the superblock
+ * 	  buf:    pointer to kstatfs
+ * @return NULL
+ */
+int tarfs_statfs(struct dentry * dentry,  struct kstatfs *buf)
+{
+	struct super_block *sb = dentry->d_sb;
+	struct tarfs_sbi* sb_info = TARFS_SB(sb);
+
+	buf->f_type = sb->s_magic;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_blocks = sb_info->blocks;
+	buf->f_files = sb_info->files;
+	buf->f_namelen = MAX_FILE_NAME_SIZE;
+	buf->f_bfree = buf->f_ffree = 0;
+	return 0;
+}
+EXPORT_SYMBOL(tarfs_statfs);
+
+/*
+ * @brief lookup function to iterate through the contents of a directory.
+ * @param  dir: inode pointer of a directory
+ *	   dentry: dentry information of the entry of a file or sub dir.
+ *	   flags: Currently unused.
+ * @return dentry of the file or sub dir.
+ */
+struct dentry *tarfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)
+{
+	struct tarfs_entry *found_entry = NULL;
+	char *dir_path = NULL;
+	struct inode *build_inode = NULL;
+	struct tarfs_entry *entry;
+
+	tarfs_debug("In tarfs_lookup");
+
+	if ( !dir->i_sb ) {
+		tarfs_err("Error Missing superblock in tarfs_lookup");
+		return NULL;
+	}
+
+	entry = tarfs_get_first_entry(dir->i_sb);
+	dir_path = build_lookup_path(dir, entry);
+
+	found_entry = tarfs_find(entry, dir_path, dentry->d_name.name);
+
+	if ( found_entry ) {
+		build_inode = found_entry->ptr_inode;
+		tarfs_debug("found entry->name = %s%s & entry->inode = %ld",
+				found_entry->dir_name, found_entry->base_name,
+				found_entry->inode);
+	} else {
+		tarfs_debug("Dir entry not found %s",dir_path);
+	}
+	kfree(dir_path);
+
+	tarfs_debug("ends dir_path=%s", dir_path);
+	return d_splice_alias(build_inode, dentry);
+}
+EXPORT_SYMBOL(tarfs_lookup);
+
+/*
+ * @brief Iteratively read a file using IO Vectors..
+ * @param  iocb: iov object.
+ *         to: info about the stage of iteration.
+ * @return number of bytes read.
+ */
+ssize_t tarfs_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
+{
+	struct file *file = iocb->ki_filp;
+	struct inode *inode  = file_inode(file);
+	struct tarfs_entry *root_entry = tarfs_get_first_entry(inode->i_sb);
+	struct tarfs_entry *entry;
+	ssize_t count, to_read, inner_size, copied;
+	loff_t pos = iocb->ki_pos, inner_off;
+	unsigned int block;
+	struct buffer_head *bh;
+
+	entry = tarfs_find_by_inode(root_entry, inode->i_ino);
+	if (!entry) {
+		tarfs_err("No entry found for the file ");
+		return -ENOENT;
+	}
+	if ( pos < 0 )
+		return -EINVAL;
+	count = min_t(size_t, iov_iter_count(to), entry->data_size - pos);
+	if (pos >= entry->data_size || !count) {
+		tarfs_debug("File read complete pos=%llu size=%ld", pos,entry->data_size);
+		return 0;
+	}
+
+	to_read = count;
+	while (to_read > 0) {
+		block = (entry->data_offset + pos) / inode->i_sb->s_blocksize;
+		inner_off = (entry->data_offset + pos) % inode->i_sb->s_blocksize;
+		inner_size = min_t(size_t, inode->i_sb->s_blocksize - inner_off, to_read);
+
+		bh = sb_bread(inode->i_sb, block);
+
+		if (!bh) {
+			tarfs_err("Failed to read block %u", block);
+			return -EINVAL;
+		}
+
+		if (bh->b_size != inode->i_sb->s_blocksize) {
+			tarfs_err("Wanted %lu byte block, but got %lu", inode->i_sb->s_blocksize, bh->b_size);
+			break;
+		}
+
+		copied = copy_to_iter(bh->b_data + inner_off, inner_size, to);
+		brelse(bh);
+
+		pos += copied;
+		to_read -= copied;
+	}
+
+	if (count == to_read) {
+		tarfs_err("Failed to read any bytes %ld", to_read);
+	}
+	iocb->ki_pos += (count - to_read);
+	tarfs_debug("count=%ld res=%ld",count, to_read);
+	return (count - to_read);
+}
+EXPORT_SYMBOL_GPL(tarfs_file_read_iter);
+
+/**
+ * tarfs_get_block - locate buffer for given inode,block tuple
+ * @ip:		inode
+ * @block:	phy block
+ * @bp:		buffer skeleton
+ * @create:	%TRUE if blocks may be newly allocated.
+ *
+ * Description:
+ *   The tarfs_get_block function fills @bp with the right physical
+ *   block and device number to perform a lowlevel read/write on
+ *   it.
+ *
+ * Returns:
+ *   Zero on success, else a negativ error code (-EIO).
+ */
+static int tarfs_getblk(struct inode *inode, sector_t block, struct buffer_head *bp, int create)
+{
+	struct tarfs_entry *root = tarfs_get_first_entry(inode->i_sb);
+	struct tarfs_entry *entry;
+	sector_t blk_offset;
+
+	entry = tarfs_find_by_inode(root, inode->i_ino);
+	if (!entry)
+		return -EIO;
+	blk_offset = entry->data_offset / inode->i_sb->s_blocksize;
+	tarfs_debug("block=[%ld] [%ld] [%d] [%ld]",block, blk_offset, entry->data_offset, entry->data_size);
+	map_bh(bp, inode->i_sb, block + blk_offset);
+	return 0;
+}
+
+
+/**
+ * tarfs_readpage - read one page synchronously into the pagecache
+ * @file:	file context (unused)
+ * @page:	page frame to fill in.
+ *
+ * Description:
+ *   The tarfs_readpage routine reads @page synchronously into the
+ *   pagecache.
+ *
+ * Returns:
+ *   Zero on success, else a negative error code.
+ *
+ * Locking status:
+ *   @page is locked and will be unlocked.
+ */
+int tarfs_readpage(struct file *file, struct page *page)
+{
+	tarfs_debug("Readpage");
+	return block_read_full_page(page, tarfs_getblk);
+}
+EXPORT_SYMBOL_GPL(tarfs_readpage);
+
+/**
+ * tarfs_bmap - perform logical to physical block mapping
+ * @mapping:	logical to physical mapping to use
+ * @block:	logical block (relative to @mapping).
+ *
+ * Description:
+ *   tarfs_bmap find out the corresponding phsical block to the
+ *   @mapping, @block pair.
+ *
+ * Returns:
+ *   Physical block number on success, else Zero.
+ *
+ * Locking status:
+ *   We are under the bkl.
+ */
+sector_t tarfs_bmap(struct address_space *mapping, sector_t block)
+{
+	tarfs_debug("block=[%ld]",block);
+	return generic_block_bmap(mapping, block, tarfs_getblk);
+}
+EXPORT_SYMBOL_GPL(tarfs_bmap);
+
+/**
+ * @brief Releases a file handle.
+ * @param inode the affected inode
+ * @param file the file to close
+ * @return \c 0
+ */
+int tarfs_file_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
diff --git a/fs/tarfs/tarfs_inode.c b/fs/tarfs/tarfs_inode.c
new file mode 100644
index 000000000000..09732f1f3e26
--- /dev/null
+++ b/fs/tarfs/tarfs_inode.c
@@ -0,0 +1,706 @@
+/*
+ * Filesystem to directly mount tar archive.
+ *
+ * Copyright 2021 VMware, Inc. All Rights Reserved.
+ * SPDX-License-Identifier: GPL v2.0
+ *
+ * Licensed under the GNU Lesser General Public License version 2 (the "License");
+ * you may not use this file except in compliance with the License. The terms
+ * of the License are located in the LICENSE file of this distribution.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/fs.h>
+#include <linux/cred.h>
+#include <linux/buffer_head.h>
+
+#include "tarfs.h"
+
+#define ROOT_INO_MODE (S_IFDIR | 0555)
+#define ALIGN_SECTOR(x) (((x) % 512 > 0) ? 512 - ((x) % 512) : 0)
+#define OCTAL (8)
+
+static void tarfs_kill_super(struct super_block *sb);
+
+/*
+ * tarfs_get_inode : Allocate inode
+ * sb : Superblock of the file system
+ * mode : Permissions
+ **/
+struct inode *tarfs_get_inode(struct super_block *sb, umode_t mode)
+{
+
+	struct inode * inode = new_inode(sb);
+	struct tarfs_sbi* sb_info = TARFS_SB(sb);
+
+	if (inode) {
+		INIT_HLIST_NODE(&inode->i_hash);
+		inode->i_ino = get_next_ino();
+		inode->i_mode = mode;
+		inode->i_mapping->a_ops = &tarfs_ram_addr_ops;
+		mapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);
+		mapping_set_unevictable(inode->i_mapping);
+		inode->i_sb = sb;
+		tarfs_debug("inode created !!");
+		sb_info->files++;
+	}
+	return inode;
+
+}
+
+static char *build_dir_path(const char *link_path, char **link_name)
+{
+	char *dir_path;
+	char *name;
+	int len;
+
+	name = strrchr(link_path, '/');
+	name = (name) ? (name + 1) : (char *)(link_path);
+	*link_name = name;
+	len = strlen(link_path) - strlen(name);
+	len = (len > 0) ? (len) : (1);
+	dir_path = kzalloc(len, GFP_KERNEL);
+	if (!dir_path) {
+		tarfs_err("Error in allocating memory for dir_path %ld", PTR_ERR(dir_path));
+		return NULL;
+	}
+	memcpy(dir_path, link_path, len - 1);
+	tarfs_debug("dir_path=[%s]",dir_path);
+	return dir_path;
+}
+
+/*
+ * tarfs_create_inode : Allocate inode for file, dir and symlinks
+ * sb : Superblock of the file system
+ * entry : tarfs entry of ROOT
+ * mode : Permissions
+ **/
+struct inode *tarfs_create_inode(struct super_block *sb,
+		struct tarfs_entry *entry, umode_t mode)
+{
+
+	struct inode * inode = NULL;
+	struct inode * dentry_inode = d_inode(sb->s_root);
+	struct tarfs_sbi* sb_info = TARFS_SB(sb);
+	struct tarfs_entry *link_entry = NULL;
+	char *link_name = NULL;
+	char *link_dir_path = NULL;
+
+
+	inode = tarfs_get_inode(sb, tarfs_entry_mode(entry));
+	if(!inode) {
+		tarfs_err("Failed to allocate new inode");
+		return NULL;
+	}
+	i_uid_write(inode, entry->uid);
+	i_gid_write(inode, entry->gid);
+	inode->i_size = entry->data_size;
+	inode->i_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+	inode->i_atime = entry->atime;
+	inode->i_mtime = entry->mtime;
+	inode->i_ctime = entry->ctime;
+	__insert_inode_hash(inode, dentry_inode->i_ino);
+	entry->inode = inode->i_ino;
+	entry->ptr_inode = inode;
+	switch (entry->header.typeflag) {
+		case DIRTYPE:
+			inode->i_op = &tarfs_dir_inode_operations;
+			inode->i_fop = &tarfs_dir_operations;
+			if (inode->i_size == 0)
+				inode->i_size = sb->s_blocksize;
+			inode->i_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+			inc_nlink(inode);
+			break;
+		case LNKTYPE:
+			link_dir_path = build_dir_path(entry->link_name, &link_name);
+			if (link_dir_path) {
+				link_entry = tarfs_find(sb_info->first, link_dir_path, link_name);
+				kfree(link_dir_path);
+			}
+			tarfs_debug("HARDLINK: [%s] [%s] [%s]", entry->link_name, link_dir_path, link_name);
+			if (link_entry) {
+				tarfs_debug("HARDLINK: [%s]->[%ld]", link_entry->base_name, link_entry->inode);
+				entry->inode = link_entry->inode;
+				entry->ptr_inode = link_entry->ptr_inode;
+			} else {
+				tarfs_err("HARDLINK: Fail to find the linked file entry!! [%s] [%s] [%s]",
+						entry->link_name, link_dir_path, link_name);
+			}
+			break;
+		case SYMTYPE:
+			inode->i_op = &tarfs_symlink_inode_operations;
+			inode->i_link = entry->link_name;
+			inode->i_size = strlen(inode->i_link);
+			inode_nohighmem(inode);
+			break;
+		default:
+			inode->i_op = &tarfs_file_inode_operations;
+			inode->i_fop = &tarfs_file_operations;
+			break;
+	}
+	sb_info->blocks += entry->ptr_inode->i_blocks;
+	tarfs_debug("inode created = %ld", entry->inode);
+	return inode;
+}
+
+static char *build_name(struct star_header *header, char *longname, char type)
+{
+	char *name = longname;
+	char *src = header->name;
+	char *prefix_end = memchr(header->prefix, 0, sizeof(header->prefix));
+	size_t prefix_len;
+	size_t name_len;
+	char *name_end = NULL;
+
+	if (!prefix_end) {
+		tarfs_err("Header name is not proper, prefix_end is NULL!!");
+		return NULL;
+	}
+
+	prefix_len = prefix_end - header->prefix;
+	if (type == GNUTYPE_LONGNAME) {
+		name_len = strlen(longname);
+		src = longname;
+		tarfs_debug("[%ld] [%ld] [%c] [%s] [%s]",
+				prefix_len, name_len,type,header->prefix, longname);
+	} else {
+		name_end = memchr(header->name, 0, sizeof(header->name));
+		if (!name_end) {
+			tarfs_err("Header name is not proper, name_end is NULL!!");
+			return NULL;
+		}
+		name_len = name_end - header->name;
+		tarfs_debug("[%ld] [%ld] [%c] [%s] [%s]",
+				prefix_len, name_len,header->typeflag,header->prefix, header->name);
+	}
+	if (prefix_len != 0 || type != GNUTYPE_LONGNAME) {
+		name = kzalloc(prefix_len + name_len + 1, GFP_KERNEL);
+		if (!name) {
+			tarfs_err("Unable to allocate memory for full name");
+			return NULL;
+		}
+		memcpy(name, header->prefix, prefix_len);
+		memcpy(name + prefix_len, src, name_len);
+		if (type == GNUTYPE_LONGNAME) {
+			kfree(longname);
+			longname = NULL;
+		}
+	}
+
+	/* The path name ends with a slash if the entry is a directory */
+	if (name[prefix_len + name_len - 1] == '/')
+		name[prefix_len + name_len - 1] = 0x0;
+
+	return name;
+}
+
+/* Returns the checksum for the given ustar format HEADER. */
+static unsigned int calculate_chksum(const struct star_header *h)
+{
+	const uint8_t *header = (const uint8_t *) h;
+	const size_t chksum_start = offsetof(struct star_header, chksum);
+	const size_t chksum_end = chksum_start + sizeof(h->chksum);
+	unsigned int chksum = 0;
+	size_t i;
+
+	for (i = 0; i < TARFS_HDR_SIZE; i++)
+	{
+		/* The star checksum is calculated as if the chksum field
+		   were all spaces. */
+		chksum += (i >= chksum_start && i < chksum_end) ? ' ' : header[i];
+	}
+	return chksum;
+}
+
+static bool is_chksum_match(const struct star_header *h)
+{
+	unsigned int chksum, cal_chksum;
+
+	if (kstrtouint(h->chksum, OCTAL, (unsigned int *)&chksum) != 0) {
+		/* Reached EOF */
+		if (h->chksum[0] == 0)
+			return false;
+		tarfs_err("failed to read chksum");
+		return false;
+	}
+	cal_chksum = calculate_chksum(h);
+	if (cal_chksum != chksum) {
+		tarfs_err("Chksum Mismatch!! Calculated chksum=%d , stored chksum=%d", cal_chksum, chksum);
+		return false;
+	}
+	return true;
+}
+
+size_t tarfs_read(void *buffer, size_t size, off_t offset, struct super_block *sb)
+{
+	struct buffer_head *bh;
+	size_t pos = 0;
+	unsigned int block;
+	loff_t inner_off;
+	ssize_t inner_size;
+
+	while (size > 0) {
+		block = (offset + pos) / sb->s_blocksize;
+		inner_off = (offset + pos) % sb->s_blocksize;
+		inner_size = min_t(ssize_t, sb->s_blocksize - inner_off, size);
+
+		tarfs_debug("blk=[%d] offset=[%ld] pos=[%ld] inneroff=[%lld] innersize=[%ld] \
+				blksize=[%ld] size=[%ld]",block, offset, pos, inner_off,
+				inner_size, sb->s_blocksize, size);
+		bh = sb_bread(sb, block);
+		if (!bh) {
+			tarfs_err("Failed to read block %u Err=%ld", block, PTR_ERR(bh));
+			break;
+		}
+
+		if (bh->b_size != sb->s_blocksize) {
+			tarfs_err("Wanted %lu byte block, but got %lu", sb->s_blocksize, bh->b_size);
+			break;
+		}
+
+		memcpy(buffer, bh->b_data + inner_off, inner_size);
+		brelse(bh);
+
+		pos += inner_size;
+		size -= inner_size;
+		buffer += inner_size;
+	}
+
+	return pos;
+}
+
+/**
+ * @brief Reads a tar header at the \a offset.
+ * @param sb the superblock to read from
+ * @param offset the 512-byte aligned offset
+ * @return the entry on success, else \c NULL
+ */
+struct tarfs_entry *tarfs_read_entry(struct super_block *sb, off_t offset)
+{
+	struct star_header header;
+	struct tarfs_entry *entry = NULL;
+	char *full_name = NULL,*basename=NULL;
+	char *longname = NULL;
+	size_t namelen = 0;
+	size_t curlen = 0;
+	char typeflag = 0;
+	unsigned int length = 0;
+	unsigned int mode = 0;
+	uid_t uid = 0;
+	gid_t gid = 0;
+	struct timespec64 atime, mtime, ctime;
+	bool gnutar = true;
+
+	if (tarfs_read(&header, sizeof(header), offset, sb) != sizeof(header)) {
+		tarfs_err("Header data reading fails!!");
+		return NULL;
+	}
+	tarfs_debug("Header Data:\n \
+			header.name = [%s]\n \
+			header.mode = [%s]\n \
+			header.uid = [%s]\n \
+			header.gid = [%s]\n \
+			header.size = [%s]\n \
+			header.mtime = [%s]\n \
+			header.chksum = [%s]\n \
+			header.typeflag = [%c]\n \
+			header.linkname = [%s]\n \
+			header.magic = [%s]\n \
+			header.version = [%s]\n \
+			header.uname = [%s]\n \
+			header.gname = [%s]\n \
+			header.devmajor = [%s]\n \
+			header.devminor = [%s]\n \
+			header.prefix = [%s]",
+			header.name, header.mode,header.uid, header.gid,header.size,
+			header.mtime,header.chksum,header.typeflag, header.linkname,
+			header.magic, header.version,header.uname, header.gname,
+			header.devmajor, header.devminor,header.prefix);
+	if (!is_chksum_match(&header)) {
+		return NULL;
+	}
+
+	if ((header.typeflag == GNUTYPE_LONGLINK) || (header.typeflag == GNUTYPE_LONGNAME)) {
+		/**
+		 * 512-byte header.... [@LongLink/LongName] typeflag=K/L hdr.size=strlen(LongName/LongLink)
+		 * 512-byte header.... [Read LongName/LongLink]
+		 * ...                 [Read again 512-bytes header if Name more than 512-bytes ]
+		 * 512-byte header.... [Actual header data, replace hdr.name with @LongName if [L]
+		 *                       else replace hdr.linkname with @LongLink if [K]]
+		 **/
+		if (kstrtouint(header.size, OCTAL, (unsigned int *)&namelen) != 0) {
+			tarfs_err("failed to read size");
+			return NULL;
+		}
+		typeflag = header.typeflag;
+		longname = kzalloc(namelen + 1, GFP_KERNEL);
+		if (IS_ERR_OR_NULL(longname)) {
+			tarfs_err("Error in allocating mem for longname %ld", PTR_ERR(longname));
+			return NULL;
+		}
+		while(curlen < namelen) {
+			offset = offset + TARFS_HDR_SIZE + ALIGN_SECTOR(TARFS_HDR_SIZE);
+			if (tarfs_read(&header, sizeof(header), offset, sb) != sizeof(header)) {
+				tarfs_err("Header data reading fails!!");
+				goto err_lvl1;
+			}
+			memcpy(longname + curlen, &header, MIN(namelen - curlen, TARFS_HDR_SIZE));
+			curlen += TARFS_HDR_SIZE;
+		}
+		tarfs_debug("longname=[%s] len=[%lu] type=[%c]",longname, namelen, typeflag);
+		offset = offset + TARFS_HDR_SIZE + ALIGN_SECTOR(TARFS_HDR_SIZE);
+		if (tarfs_read(&header, sizeof(header), offset, sb) != sizeof(header)) {
+			tarfs_err("Header data reading fails!!");
+			goto err_lvl1;
+		}
+	}
+	if (!is_chksum_match(&header)) {
+		goto err_lvl1;
+	}
+
+	/**
+	 * Check for the header magic value
+	 * Supported Formats:
+	 * 	GNU
+	 * 	POSIX
+	 **/
+	if ((memcmp(header.magic, OLDGNU_MAGIC, sizeof(header.magic)) != 0) &&
+			(gnutar = (memcmp(header.magic, TMAGIC, sizeof(header.magic)) != 0))) {
+		tarfs_err("magic=%s", header.magic);
+		goto err_lvl1;
+	}
+	// Parse the data length from the header
+	if (kstrtouint(header.size, OCTAL, (unsigned int *)&length) !=
+			0) {
+		tarfs_err("failed to read size");
+		goto err_lvl1;
+	}
+	if (kstrtouint(header.mode, OCTAL, (unsigned int *)&mode) != 0) {
+		tarfs_err("failed to read mode");
+		goto err_lvl1;
+	}
+	if (kstrtouint(header.uid, OCTAL, (unsigned int *)&uid) != 0) {
+		tarfs_err("failed to read uid");
+		goto err_lvl1;
+	}
+	if (kstrtouint(header.gid, OCTAL, (unsigned int *)&gid) !=0) {
+		tarfs_err("failed to read gid");
+		goto err_lvl1;
+	}
+	if (kstrtoul(header.mtime, OCTAL, (long unsigned int *)&mtime.tv_sec) != 0) {
+		mtime.tv_sec = 0;
+		mtime.tv_nsec = 0;;
+	}
+	if (gnutar && kstrtoul(header.atime, OCTAL, (long unsigned int *)&atime.tv_sec) != 0) {
+		atime = mtime;
+	}
+	if (gnutar && kstrtoul(header.ctime, OCTAL, (long unsigned int *)&ctime.tv_sec) != 0) {
+		ctime = mtime;
+	}
+	if (!gnutar) {
+		atime = mtime;
+		ctime = mtime;
+	}
+	full_name = build_name(&header, longname, typeflag);
+	if (!full_name) {
+		tarfs_err("name allocation error");
+		goto err_lvl1;
+	}
+	basename = strrchr(full_name, '/');
+	if (basename) {
+		*basename = 0x0;
+		basename++;
+	} else {
+		basename = full_name;
+		full_name = basename + strlen(basename);
+	}
+
+	entry = kzalloc(sizeof(struct tarfs_entry), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(entry)) {
+		tarfs_err("Error in allocating mem for entry %ld", PTR_ERR(entry));
+		goto err_lvl1;
+	}
+	entry->header = header;
+	entry->dir_name = full_name;
+	entry->base_name = basename;
+	entry->data_size = length;
+	entry->mode = mode;
+	entry->uid = uid;
+	entry->gid = gid;
+	entry->mtime = mtime;
+	entry->atime = atime;
+	entry->ctime = ctime;
+	entry->offset = offset;
+	entry->data_offset = offset + TARFS_HDR_SIZE + ALIGN_SECTOR(TARFS_HDR_SIZE);
+	entry->link_name = (typeflag == GNUTYPE_LONGLINK) ? (longname) : (entry->header.linkname);
+	tarfs_debug("full_name = [%s] [%s] linkname=[%s]", entry->dir_name, entry->base_name, entry->link_name);
+	return entry;
+
+err_lvl1:
+	if (longname)
+		kfree(longname);
+	return NULL;
+}
+
+
+
+
+/**
+ * @brief Reads all file headers from the \a sb
+ * @param sb the underlying super block
+ * @return the first entry, pointing at all other entries
+ */
+struct tarfs_entry *tarfs_open(struct super_block *sb)
+{
+	struct tarfs_entry *first = tarfs_read_entry(sb, 0);
+	struct tarfs_entry *parent = first;
+	struct tarfs_sbi *sb_info = TARFS_SB(sb);
+	struct tarfs_entry *next;
+	struct inode *alloc_inode;
+	loff_t length;
+	int err;
+
+	if (first) {
+		sb_info->first = first;
+		alloc_inode = tarfs_create_inode(sb, parent, parent->mode);
+		if (IS_ERR_OR_NULL(alloc_inode)) {
+			tarfs_err("alloc_inode failed !!");
+			return NULL;
+		}
+		radix_tree_preload(GFP_NOIO);
+		INIT_RADIX_TREE(&first->root_tree, GFP_NOIO);
+		err = radix_tree_insert(&first->root_tree, (unsigned long)first->ptr_inode->i_ino, first);
+		if (err) {
+			tarfs_err("Radix tree insert first err=%d, inode %ld", err, first->ptr_inode->i_ino);
+			radix_tree_preload_end();
+			return NULL;
+		}
+		radix_tree_preload_end();
+	}
+	while (parent) {
+		/* Skipping the data of previous entry */
+		length = parent->data_offset + parent->data_size;
+		next = tarfs_read_entry(sb, length + ALIGN_SECTOR(length));
+		parent->next = next;
+		if (IS_ERR_OR_NULL(next))
+			break;
+		parent->next->radix_root_key = parent->inode;
+		parent = next;
+		alloc_inode = tarfs_create_inode(sb, parent, parent->mode);
+		if (IS_ERR_OR_NULL(alloc_inode)) {
+			tarfs_err("alloc_inode failed !!");
+			parent->inode = 2;
+			break;
+		}
+		radix_tree_preload(GFP_NOIO);
+		err = radix_tree_insert(&first->root_tree, (unsigned long)alloc_inode->i_ino, parent);
+		if (err) {
+			tarfs_err("Radix tree insert err=%d, inode %ld", err, alloc_inode->i_ino);
+			radix_tree_preload_end();
+			break;
+		}
+		radix_tree_preload_end();
+		if (parent->header.typeflag == LNKTYPE)
+			iput(alloc_inode);
+	}
+	return first;
+}
+
+static int tarfs_parse_mount_ops(char *data, struct tarfs_mount_opts *opts)
+{
+	/*TODO: Hardcode it to Read Only mode */
+	opts->mode = S_IRUGO | S_IXUGO;
+	return 0;
+}
+
+/**
+ * @brief Sets up the \a sb.
+ * @param sb the super block
+ * @param data
+ * @param silent if messages shall be suppressed
+ * @return an error code
+ */
+static int tarfs_fill_sb(struct super_block *sb, void *data, int silent)
+{
+	struct tarfs_entry *entry = NULL;
+	struct inode *inode = NULL;
+	struct tarfs_mount_opts mount_opts;
+	int err = -EINVAL;
+	struct tarfs_sbi *sb_info;
+
+	sb_info = kzalloc(sizeof(struct tarfs_sbi), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(sb_info)) {
+		tarfs_err("Error in allocating mem for sb_info! Err: %ld", PTR_ERR(sb_info));
+		return -ENOMEM;
+	}
+	sb->s_fs_info = sb_info;
+
+	err = tarfs_parse_mount_ops(data, &mount_opts);
+	if (err) {
+		tarfs_err("Error in reading mount options for tarfs");
+		goto error;
+	}
+	sb->s_op = &tarfs_super_ops;
+	sb->s_d_op = &simple_dentry_operations;
+	sb->s_time_gran = 1;
+	sb->s_flags |= MS_RDONLY | MS_NOATIME; /*Read only file system*/
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+	if (!sb_set_blocksize(sb, TARFS_BLOCK_SIZE)) {
+		tarfs_err("device does not support %d byte blocks", TARFS_BLOCK_SIZE);
+		err = -EINVAL;
+		goto error;
+	}
+
+	inode = tarfs_get_inode(sb, S_IFDIR | mount_opts.mode);
+	if (!inode) {
+		tarfs_err("Failed to create new inode!!");
+		err = -ENOMEM;
+		goto error;
+	}
+	inode->i_uid = current_fsuid();
+	inode->i_gid = current_fsgid();
+	inode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);
+	inode->i_size = sb->s_blocksize;
+	inode->i_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+	inode->i_op = &tarfs_dir_inode_operations;
+	inode->i_fop = &tarfs_dir_operations;
+	inode_init_owner(inode, NULL, ROOT_INO_MODE);
+	/*directory inodes start off with i_nlink=2(for "." entry)*/
+	inc_nlink(inode);
+	inc_nlink(inode);
+
+	sb_info->blocks = inode->i_blocks;
+	sb->s_root = d_make_root(inode);
+	if (!sb->s_root) {
+		iput(inode);
+		tarfs_err("Error in creating root point for tarfs");
+		err = -ENOMEM;
+		goto error;
+	}
+
+	tarfs_debug("populate_first_entry");
+	__insert_inode_hash(inode, inode->i_ino);
+	entry = tarfs_open(sb);
+	if (!entry) {
+		tarfs_err("Failed to read first entry");
+		tarfs_kill_super(sb);
+		return -ENOMEM;
+	}
+	entry->radix_root_key = inode->i_ino;
+	sb->s_magic = (unsigned long)entry->header.magic;
+	tarfs_debug("first allocated root inode num = %ld and sb = %p magic=[%s]", inode->i_ino, sb, (char *)sb->s_magic);
+	return 0;
+
+error:
+	kfree(sb_info);
+	return err;
+}
+
+/**
+ * @brief Called by linux to mount \a dev.
+ * @param type our file system type
+ * @param flags mount flags
+ * @param dev the device path to mount
+ * @param data
+ * @return the root directory entry
+ */
+static struct dentry *tarfs_mount(struct file_system_type *type, int flags,
+		char const *dev, void *data)
+{
+	return mount_bdev(type, flags, dev, data, tarfs_fill_sb);
+}
+
+/**
+ * @brief Called by linux to unmount \a sb.
+ * @param sb the super block of the instance to unmount
+ */
+static void tarfs_kill_super(struct super_block *sb)
+{
+	struct tarfs_sbi *sb_info = TARFS_SB(sb);
+	struct tarfs_entry* entry = sb_info ? (sb_info->first) : NULL;
+	unsigned long root_ino = entry ? entry->radix_root_key : 0;
+	struct tarfs_entry *next;
+
+	tarfs_debug("Kill super");
+	while (entry) {
+		next = entry->next;
+		tarfs_debug("basename=%s dirn=%s",entry->base_name,
+				entry->dir_name);
+
+		if (entry->dir_name < entry->base_name)
+			kfree(entry->dir_name);
+		else
+			kfree(entry->base_name);
+		if (strlen(entry->link_name) > MAX_FILE_NAME_SIZE)
+			kfree(entry->link_name);
+		if (entry->header.typeflag != LNKTYPE)
+			iput(entry->ptr_inode);
+		kfree(entry);
+		entry = next;
+	}
+	if (root_ino) {
+		iput(sb->s_root->d_inode);
+	}
+	if (sb->s_root) {
+		kfree(sb->s_root->d_fsdata);
+	}
+	if (sb_info) {
+		kfree(sb_info);
+	}
+	generic_shutdown_super(sb);
+}
+
+static struct file_system_type tarfs_type = {
+	.owner     = THIS_MODULE,
+	.name      = "tarfs",
+	.mount     = tarfs_mount,
+	.kill_sb   = tarfs_kill_super,
+	.fs_flags  = FS_REQUIRES_DEV,
+};
+
+/** @brief Called by linux to initialize the module. */
+static int __init tarfs_init(void)
+{
+	int err = 0;
+
+	tarfs_info("filesystem module load start");
+
+	err = register_filesystem(&tarfs_type);
+	if (unlikely(err)) {
+		tarfs_err("Failed to register tarfs type %d. Exiting!!", err);
+		goto err;
+	}
+	tarfs_debug("filesystem module registered");
+
+	return 0;
+err:
+	return err;
+}
+
+/** @brief Called by linux to unload the module. */
+static void __exit tarfs_exit(void)
+{
+	int err = 0;
+
+	tarfs_info("filesystem module unload");
+	err = unregister_filesystem(&tarfs_type);
+	if (unlikely(err))
+		tarfs_err("Failed to unregister tarfs filesystem %d", err);
+}
+
+module_init(tarfs_init);
+module_exit(tarfs_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("A tar filesystem driver");
+MODULE_AUTHOR("VMware Photon OS : Srinidhi Rao <srinidhir@vmware.com>");
+MODULE_AUTHOR("VMware Photon OS : Alexey Makhalov <amakhalov@vmware.com>");
+MODULE_AUTHOR("VMware Photon OS : Ankit Jain <ankitja@vmware.com>");
+MODULE_AUTHOR("VMware Photon OS : Ashwin Dayanand Kamat <kashwindayan@vmware.com>");
-- 
2.23.1

