From 1e19eba2fa9d4f0e8c1c8f314c1592aca032feb8 Mon Sep 17 00:00:00 2001
From: Kamal Charan <kcharan@vmware.com>
Date: Tue, 20 Nov 2018 02:31:42 -0800
Subject: [PATCH] Add 9p zero copy data path using crossfd

Add new rpc calls to 9p protocol to allow zero copy
read and write requests from the client to the server.
The client sends only the page addresses of the io
buffer where the data is to be transferred, and the
server directly does the data transfer to that buffer,
and does not send or receive the data over the transport.

These calls are allowed only over vsock transport,
where both the client and the server are on same host,
and server can transfer the data to client memory using
the crossfd feature of ESXi.
---
 include/net/9p/9p.h     |   8 +
 include/net/9p/client.h |   2 +
 net/9p/client.c         | 418 +++++++++++++++++++++++++++++++++++++-----------
 net/9p/protocol.c       |  14 ++
 4 files changed, 351 insertions(+), 91 deletions(-)

diff --git a/include/net/9p/9p.h b/include/net/9p/9p.h
index 27dfe85..48dd4c4 100644
--- a/include/net/9p/9p.h
+++ b/include/net/9p/9p.h
@@ -109,6 +109,10 @@ void _p9_debug(enum p9_debug_flags level, const char *func,
  * @P9_RREAD: response with data requested
  * @P9_TWRITE: reuqest to transfer data to a file
  * @P9_RWRITE: response with out much data was transferred to file
+ * @P9_TREADX: request to zero copy data from a file to user buffer
+ * @P9_RREADX: response with how much data was transferred from file
+ * @P9_TWRITEX: reuqest to zero copy data to a file from user buffer
+ * @P9_RWRITEX: response with how much data was transferred to file
  * @P9_TCLUNK: forget about a handle to an entity within the file system
  * @P9_RCLUNK: response when server has forgotten about the handle
  * @P9_TREMOVE: request to remove an entity from the hierarchy
@@ -168,6 +172,10 @@ enum p9_msg_t {
 	P9_RRENAMEAT,
 	P9_TUNLINKAT = 76,
 	P9_RUNLINKAT,
+	P9_TREADX = 96,
+	P9_RREADX,
+	P9_TWRITEX = 98,
+	P9_RWRITEX,
 	P9_TVERSION = 100,
 	P9_RVERSION,
 	P9_TAUTH = 102,
diff --git a/include/net/9p/client.h b/include/net/9p/client.h
index c6b97e5..c7f1a7d 100644
--- a/include/net/9p/client.h
+++ b/include/net/9p/client.h
@@ -124,6 +124,7 @@ struct p9_req_t {
  * struct p9_client - per client instance state
  * @lock: protect @fidlist
  * @msize: maximum data size negotiated by protocol
+ * @is_crossfd: whether zero copy io using crossfd is allowed
  * @dotu: extension flags negotiated by protocol
  * @proto_version: 9P protocol version to use
  * @trans_mod: module API instantiated with this client
@@ -152,6 +153,7 @@ struct p9_req_t {
 struct p9_client {
 	spinlock_t lock; /* protect client structure */
 	unsigned int msize;
+	unsigned int is_crossfd;
 	unsigned char proto_version;
 	struct p9_trans_module *trans_mod;
 	enum p9_trans_status status;
diff --git a/net/9p/client.c b/net/9p/client.c
index ed8738c4..3125a1f 100644
--- a/net/9p/client.c
+++ b/net/9p/client.c
@@ -25,6 +25,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
@@ -44,6 +45,9 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/9p.h>
 
+#define CROSSFD_ZC_MAXPAGES 1024
+#define CROSSFD_ZC_TRANSPORT "vsock"
+
 /*
   * Client Option Parsing (code inspired by NFS code)
   *  - a little lazy - parse all client options
@@ -54,6 +58,7 @@ enum {
 	Opt_trans,
 	Opt_legacy,
 	Opt_version,
+	Opt_crossfd,
 	Opt_err,
 };
 
@@ -62,6 +67,7 @@ static const match_table_t tokens = {
 	{Opt_legacy, "noextend"},
 	{Opt_trans, "trans=%s"},
 	{Opt_version, "version=%s"},
+	{Opt_crossfd, "crossfd"},
 	{Opt_err, NULL},
 };
 
@@ -77,6 +83,12 @@ inline int p9_is_proto_dotu(struct p9_client *clnt)
 }
 EXPORT_SYMBOL(p9_is_proto_dotu);
 
+inline int p9_is_option_crossfd(struct p9_client *clnt)
+{
+	return clnt->is_crossfd != 0;
+}
+EXPORT_SYMBOL(p9_is_option_crossfd);
+
 /*
  * Some error codes are taken directly from the server replies,
  * make sure they are valid.
@@ -179,6 +191,9 @@ static int parse_opts(char *opts, struct p9_client *clnt)
 		case Opt_legacy:
 			clnt->proto_version = p9_proto_legacy;
 			break;
+		case Opt_crossfd:
+			clnt->is_crossfd = 1;
+			break;
 		case Opt_version:
 			s = match_strdup(&args[0]);
 			if (!s) {
@@ -199,6 +214,16 @@ static int parse_opts(char *opts, struct p9_client *clnt)
 			continue;
 		}
 	}
+	if (clnt->is_crossfd &&
+	    (!clnt->trans_mod ||
+	     strcmp(clnt->trans_mod->name, CROSSFD_ZC_TRANSPORT))) {
+		p9_debug(P9_DEBUG_ERROR,
+			 "crossfd option requires %s transport",
+			 CROSSFD_ZC_TRANSPORT);
+		ret = -EINVAL;
+		goto free_and_return;
+	}
+
 
 free_and_return:
 	kfree(tmp_options);
@@ -999,6 +1024,7 @@ struct p9_client *p9_client_create(const char *dev_name, char *options)
 
 	clnt->trans_mod = NULL;
 	clnt->trans = NULL;
+	clnt->is_crossfd = 0;
 
 	client_id = utsname()->nodename;
 	memcpy(clnt->name, client_id, strlen(client_id) + 1);
@@ -1534,136 +1560,346 @@ error:
 }
 EXPORT_SYMBOL(p9_client_unlinkat);
 
+static int
+crossfd_can_zc(const struct iov_iter *iter)
+{
+	return iter_is_iovec(iter) && iov_iter_count(iter) > PAGE_SIZE;
+}
+
+static int
+p9_client_read_nocrossfd(struct p9_fid *fid, u64 offset, struct iov_iter *to, int *err)
+{
+	struct p9_client *clnt = fid->clnt;
+	struct p9_req_t *req;
+	int total = 0;
+	int count = iov_iter_count(to);
+	int rsize, non_zc = 0;
+	char *dataptr;
+
+	*err = 0;
+
+	rsize = fid->iounit;
+	if (!rsize || rsize > clnt->msize-P9_IOHDRSZ)
+		rsize = clnt->msize - P9_IOHDRSZ;
+
+	if (count < rsize)
+		rsize = count;
+
+	/* Don't bother zerocopy for small IO (< 1024) */
+	if (clnt->trans_mod->zc_request && rsize > 1024) {
+		/*
+		 * response header len is 11
+		 * PDU Header(7) + IO Size (4)
+		 */
+		req = p9_client_zc_rpc(clnt, P9_TREAD, to, NULL, rsize,
+				       0, 11, "dqd", fid->fid, offset, rsize);
+	} else {
+		non_zc = 1;
+		req = p9_client_rpc(clnt, P9_TREAD, "dqd", fid->fid, offset,
+				    rsize);
+	}
+
+	if (IS_ERR(req)) {
+		p9_debug(P9_DEBUG_9P, "          rpc error\n");
+		*err = PTR_ERR(req);
+		return 0;
+	}
+
+	*err = p9pdu_readf(req->rc, clnt->proto_version, "D", &count, &dataptr);
+	if (*err) {
+		p9_debug(P9_DEBUG_9P, "          ret err %d \n", *err);
+		trace_9p_protocol_dump(clnt, req->rc);
+		goto error;
+	}
+	if (rsize < count) {
+		pr_err("bogus RREAD count (%d > %d)\n", count, rsize);
+		count = rsize;
+	}
+
+	if (count == 0)
+		goto error;
+
+	if (non_zc) {
+		int n = copy_to_iter(dataptr, count, to);
+		if (n != count) {
+			*err = -EFAULT;
+			total = n;
+			goto error;
+		}
+	} else {
+		iov_iter_advance(to, count);
+	}
+	total = count;
+
+error:
+	p9_free_req(clnt, req);
+	return total;
+}
+
+static int
+p9_client_read_crossfdzc(struct p9_fid *fid, u64 offset, struct iov_iter *to, int *err)
+{
+	struct p9_client *clnt = fid->clnt;
+	struct p9_req_t *req = NULL;
+	int total = 0;
+	int count = iov_iter_count(to);
+	int rsize;
+	size_t off;
+
+	int i, maxpages, npages = 0;
+	struct page **pages = NULL;
+	unsigned long *ppns = NULL;
+
+	*err = 0;
+
+	maxpages = DIV_ROUND_UP(count, PAGE_SIZE);
+	maxpages = min(CROSSFD_ZC_MAXPAGES, maxpages);
+
+	pages = kmalloc(sizeof(struct page *) * maxpages, GFP_KERNEL);
+	if (!pages) {
+		*err = -ENOMEM;
+		goto error;
+	}
+	ppns = kmalloc(sizeof(unsigned long) * maxpages, GFP_KERNEL);
+	if (!ppns) {
+		*err = -ENOMEM;
+		goto error;
+	}
+
+	rsize = iov_iter_get_pages(to, pages, count, maxpages, &off);
+	if (rsize < 0) {
+		*err = rsize;
+		goto error;
+	}
+
+	npages = DIV_ROUND_UP(off + rsize, PAGE_SIZE);
+	for (i = 0; i < npages; i++) {
+		ppns[i] = page_to_pfn(pages[i]);
+	}
+
+	req = p9_client_rpc(clnt, P9_TREADX, "dqddp", fid->fid, offset, rsize,
+			    (unsigned int) off, npages, ppns);
+	if (IS_ERR(req)) {
+		p9_debug(P9_DEBUG_9P, "          rpc error\n");
+		*err = PTR_ERR(req);
+		goto error;
+	}
+
+	*err = p9pdu_readf(req->rc, clnt->proto_version, "d", &count);
+	if (*err) {
+		p9_debug(P9_DEBUG_9P, "          ret err %d \n", *err);
+		trace_9p_protocol_dump(clnt, req->rc);
+		goto error;
+	}
+	if (rsize < count) {
+		pr_err("bogus RREADX count (%d > %d)\n", count, rsize);
+		goto error;
+	}
+
+	if (count == 0)
+		goto error;
+
+	iov_iter_advance(to, count);
+	total = count;
+
+error:
+	if (req && !IS_ERR(req))
+		p9_free_req(clnt, req);
+
+	for (i = 0; i < npages; i++) {
+		put_page(pages[i]);
+	}
+
+	kfree(pages);
+	kfree(ppns);
+
+	return total;
+}
+
 int
 p9_client_read(struct p9_fid *fid, u64 offset, struct iov_iter *to, int *err)
 {
-	struct p9_client *clnt = fid->clnt;
-	struct p9_req_t *req;
 	int total = 0;
+	int is_crossfd = p9_is_option_crossfd(fid->clnt);
+
 	*err = 0;
 
 	p9_debug(P9_DEBUG_9P, ">>> TREAD fid %d offset %llu %d\n",
-		   fid->fid, (unsigned long long) offset, (int)iov_iter_count(to));
+		 fid->fid, (unsigned long long) offset, (int)iov_iter_count(to));
 
 	while (iov_iter_count(to)) {
-		int count = iov_iter_count(to);
-		int rsize, non_zc = 0;
-		char *dataptr;
-			
-		rsize = fid->iounit;
-		if (!rsize || rsize > clnt->msize-P9_IOHDRSZ)
-			rsize = clnt->msize - P9_IOHDRSZ;
+		int count;
 
-		if (count < rsize)
-			rsize = count;
-
-		/* Don't bother zerocopy for small IO (< 1024) */
-		if (clnt->trans_mod->zc_request && rsize > 1024) {
-			/*
-			 * response header len is 11
-			 * PDU Header(7) + IO Size (4)
-			 */
-			req = p9_client_zc_rpc(clnt, P9_TREAD, to, NULL, rsize,
-					       0, 11, "dqd", fid->fid,
-					       offset, rsize);
+		if (is_crossfd && crossfd_can_zc(to)) {
+			count = p9_client_read_crossfdzc(fid, offset, to, err);
 		} else {
-			non_zc = 1;
-			req = p9_client_rpc(clnt, P9_TREAD, "dqd", fid->fid, offset,
-					    rsize);
-		}
-		if (IS_ERR(req)) {
-			*err = PTR_ERR(req);
-			break;
+			count = p9_client_read_nocrossfd(fid, offset, to, err);
 		}
 
-		*err = p9pdu_readf(req->rc, clnt->proto_version,
-				   "D", &count, &dataptr);
-		if (*err) {
-			trace_9p_protocol_dump(clnt, req->rc);
-			p9_free_req(clnt, req);
+		if (*err || count == 0)
 			break;
-		}
-		if (rsize < count) {
-			pr_err("bogus RREAD count (%d > %d)\n", count, rsize);
-			count = rsize;
-		}
 
 		p9_debug(P9_DEBUG_9P, "<<< RREAD count %d\n", count);
-		if (!count) {
-			p9_free_req(clnt, req);
-			break;
-		}
 
-		if (non_zc) {
-			int n = copy_to_iter(dataptr, count, to);
-			total += n;
-			offset += n;
-			if (n != count) {
-				*err = -EFAULT;
-				p9_free_req(clnt, req);
-				break;
-			}
-		} else {
-			iov_iter_advance(to, count);
-			total += count;
-			offset += count;
-		}
-		p9_free_req(clnt, req);
+		total += count;
+		offset += count;
 	}
 	return total;
 }
 EXPORT_SYMBOL(p9_client_read);
 
+static int
+p9_client_write_nocrossfd(struct p9_fid *fid, u64 offset, struct iov_iter *from, int *err)
+{
+	struct p9_client *clnt = fid->clnt;
+	struct p9_req_t *req;
+	int total = 0;
+	int count = iov_iter_count(from);
+	int rsize;
+
+	*err = 0;
+
+	rsize = fid->iounit;
+	if (!rsize || rsize > clnt->msize-P9_IOHDRSZ)
+		rsize = clnt->msize - P9_IOHDRSZ;
+
+	if (count < rsize)
+		rsize = count;
+
+	/* Don't bother zerocopy for small IO (< 1024) */
+	if (clnt->trans_mod->zc_request && rsize > 1024) {
+		req = p9_client_zc_rpc(clnt, P9_TWRITE, NULL, from, 0, rsize,
+				       P9_ZC_HDR_SZ, "dqd", fid->fid, offset,
+				       rsize);
+	} else {
+		req = p9_client_rpc(clnt, P9_TWRITE, "dqV", fid->fid, offset,
+				    rsize, from);
+	}
+	if (IS_ERR(req)) {
+		p9_debug(P9_DEBUG_9P, "          rpc error\n");
+		*err = PTR_ERR(req);
+		return 0;
+	}
+
+	*err = p9pdu_readf(req->rc, clnt->proto_version, "d", &count);
+	if (*err) {
+		p9_debug(P9_DEBUG_9P, "          ret err %d \n", *err);
+		trace_9p_protocol_dump(clnt, req->rc);
+		goto error;
+	}
+	if (rsize < count) {
+		pr_err("bogus RWRITE count (%d > %d)\n", count, rsize);
+		count = rsize;
+	}
+
+	iov_iter_advance(from, count);
+	total = count;
+error:
+	p9_free_req(clnt, req);
+
+	return total;
+}
+
+static int
+p9_client_write_crossfdzc(struct p9_fid *fid, u64 offset, struct iov_iter *from, int *err)
+{
+	struct p9_client *clnt = fid->clnt;
+	struct p9_req_t *req = NULL;
+	int total = 0;
+	int count = iov_iter_count(from);
+	int rsize;
+	size_t off;
+
+	int i, maxpages, npages = 0;
+	struct page **pages = NULL;
+	unsigned long *ppns = NULL;
+
+	*err = 0;
+
+	maxpages = DIV_ROUND_UP(count, PAGE_SIZE);
+	maxpages = min(CROSSFD_ZC_MAXPAGES, maxpages);
+
+	pages = kmalloc(sizeof(struct page *) * maxpages, GFP_KERNEL);
+	if (!pages) {
+		*err = -ENOMEM;
+		goto error;
+	}
+	ppns = kmalloc(sizeof(unsigned long) * maxpages, GFP_KERNEL);
+	if (!ppns) {
+		*err = -ENOMEM;
+		goto error;
+	}
+	rsize = iov_iter_get_pages(from, pages, count, maxpages, &off);
+	if (rsize < 0) {
+		*err = rsize;
+		goto error;
+	}
+
+	npages = DIV_ROUND_UP(off + rsize, PAGE_SIZE);
+	for (i = 0; i < npages; i++) {
+		ppns[i] = page_to_pfn(pages[i]);
+	}
+
+	req = p9_client_rpc(clnt, P9_TWRITEX, "dqddp", fid->fid, offset, rsize,
+			    (unsigned int) off, npages, ppns);
+	if (IS_ERR(req)) {
+		p9_debug(P9_DEBUG_9P, "          rpc error\n");
+		*err = PTR_ERR(req);
+		goto error;
+	}
+
+	*err = p9pdu_readf(req->rc, clnt->proto_version, "d", &count);
+	if (*err) {
+		p9_debug(P9_DEBUG_9P, "          ret err %d \n", *err);
+		trace_9p_protocol_dump(clnt, req->rc);
+		goto error;
+	}
+	if (rsize < count) {
+		pr_err("bogus RWRITEX count (%d > %d)\n", count, rsize);
+		goto error;
+	}
+
+	iov_iter_advance(from, count);
+	total = count;
+error:
+	if (req && !IS_ERR(req))
+		p9_free_req(clnt, req);
+
+	for (i = 0; i < npages; i++) {
+		put_page(pages[i]);
+	}
+
+	kfree(pages);
+	kfree(ppns);
+
+	return total;
+}
+
 int
 p9_client_write(struct p9_fid *fid, u64 offset, struct iov_iter *from, int *err)
 {
-	struct p9_client *clnt = fid->clnt;
-	struct p9_req_t *req;
 	int total = 0;
+	int is_crossfd = p9_is_option_crossfd(fid->clnt);
+
 	*err = 0;
 
 	p9_debug(P9_DEBUG_9P, ">>> TWRITE fid %d offset %llu count %zd\n",
-				fid->fid, (unsigned long long) offset,
-				iov_iter_count(from));
+		 fid->fid, (unsigned long long) offset, iov_iter_count(from));
 
 	while (iov_iter_count(from)) {
-		int count = iov_iter_count(from);
-		int rsize = fid->iounit;
-		if (!rsize || rsize > clnt->msize-P9_IOHDRSZ)
-			rsize = clnt->msize - P9_IOHDRSZ;
+		int count;
 
-		if (count < rsize)
-			rsize = count;
-
-		/* Don't bother zerocopy for small IO (< 1024) */
-		if (clnt->trans_mod->zc_request && rsize > 1024) {
-			req = p9_client_zc_rpc(clnt, P9_TWRITE, NULL, from, 0,
-					       rsize, P9_ZC_HDR_SZ, "dqd",
-					       fid->fid, offset, rsize);
+		if (is_crossfd && crossfd_can_zc(from)) {
+			count = p9_client_write_crossfdzc(fid, offset, from, err);
 		} else {
-			req = p9_client_rpc(clnt, P9_TWRITE, "dqV", fid->fid,
-						    offset, rsize, from);
-		}
-		if (IS_ERR(req)) {
-			*err = PTR_ERR(req);
-			break;
+			count = p9_client_write_nocrossfd(fid, offset, from, err);
 		}
 
-		*err = p9pdu_readf(req->rc, clnt->proto_version, "d", &count);
-		if (*err) {
-			trace_9p_protocol_dump(clnt, req->rc);
-			p9_free_req(clnt, req);
+		if (*err || count == 0)
 			break;
-		}
-		if (rsize < count) {
-			pr_err("bogus RWRITE count (%d > %d)\n", count, rsize);
-			count = rsize;
-		}
 
 		p9_debug(P9_DEBUG_9P, "<<< RWRITE count %d\n", count);
 
-		p9_free_req(clnt, req);
-		iov_iter_advance(from, count);
 		total += count;
 		offset += count;
 	}
diff --git a/net/9p/protocol.c b/net/9p/protocol.c
index 16d2875..ebf324e 100644
--- a/net/9p/protocol.c
+++ b/net/9p/protocol.c
@@ -449,6 +449,20 @@ p9pdu_vwritef(struct p9_fcall *pdu, int proto_version, const char *fmt,
 					errcode = -EFAULT;
 			}
 			break;
+		case 'p':{
+				int j;
+				uint32_t npages = va_arg(ap, uint32_t);
+				uint64_t *ppns = va_arg(ap, uint64_t *);
+				errcode =
+				    p9pdu_writef(pdu, proto_version, "d",
+								 npages);
+				for (j = 0; !errcode && j < npages; j++) {
+					errcode =
+					    p9pdu_writef(pdu, proto_version,
+							 "q", ppns[j]);
+				}
+			}
+			break;
 		case 'T':{
 				uint16_t nwname = va_arg(ap, int);
 				const char **wnames = va_arg(ap, const char **);
-- 
2.6.2

