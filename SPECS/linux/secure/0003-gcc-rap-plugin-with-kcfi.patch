From aa1039dcce919e14e73aaa3fdd1a514d04c47c6f Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Wed, 8 Feb 2023 13:59:02 +0000
Subject: [PATCH] gcc rap plugin with kcfi

This patch adopts the forward-edge control-flow integrity
scheme for Clang known as KCFI in gcc with the help
of RAP plugin.

The original RAP gcc plugin code developed by PaX team
is modified to adopt to kcfi implementation in kernel.

Following changes are made to adopt KCFI in GCC RAP plugin:

- Padding and hash size is changed to match with KCFI
- Function label and size paramter are added
  E.g:
0000000000000000 <__cfi_func>:
       0:       cc                      int3
       1:       cc                      int3
       2:       b8 a7 9e 9e 58          mov    $0x589e9ea7,%eax
       7:       cc                      int3
       8:       cc                      int3
- weak attribute handling and skip generation of rap hash
  for direct calls
- change the runtime comparison injection code of RAP plugin
  to use 4 bytes hash comparision instead of 8 bytes
- Remove SYM_TYPED_FUNC_START from __memcpy asm function,
  as it is already handled by RAP plugin code.
- Add Kconfig changes to enable CFI_CLANG when PAX_RAP is 'y'
- Fix rap_hash injection for bpf_prog_run() to use int instead of
  long as the size of rap_hash is 4 bytes now

Signed-off-by: Keerthana K <keerthanak@vmware.com>
---
 Makefile                                      |   2 +
 arch/Kconfig                                  |   8 +-
 arch/x86/entry/Makefile                       |   2 +
 arch/x86/entry/common.c                       |  51 ++
 arch/x86/include/asm/text-patching.h          |   4 +
 arch/x86/include/asm/vermagic.h               |   9 +-
 arch/x86/kernel/alternative.c                 |   7 +
 arch/x86/kernel/cpu/vmware.c                  |   9 +-
 arch/x86/kernel/module.c                      |   6 +-
 arch/x86/kernel/paravirt.c                    |   7 +-
 arch/x86/kernel/traps.c                       |   4 +
 arch/x86/lib/memcpy_64.S                      |   2 +-
 drivers/char/tpm/tpm-chip.c                   |   9 +-
 drivers/firmware/dmi-id.c                     |   7 +-
 .../gpu/drm/nouveau/nvkm/subdev/bios/shadow.c |   7 +-
 drivers/net/ethernet/brocade/bna/bfa_cs.h     |  42 +-
 drivers/net/ethernet/brocade/bna/bfa_ioc.c    |  10 +-
 drivers/net/ethernet/brocade/bna/bfa_ioc.h    |   4 +-
 drivers/net/ethernet/brocade/bna/bfa_msgq.h   |   8 +-
 drivers/net/ethernet/brocade/bna/bna_enet.c   |   6 +-
 drivers/net/ethernet/brocade/bna/bna_tx_rx.c  |   6 +-
 drivers/net/ethernet/brocade/bna/bna_types.h  |  24 +-
 drivers/net/ethernet/brocade/bna/bnad.c       |  11 +-
 drivers/scsi/bfa/bfa.h                        |   4 +-
 drivers/scsi/bfa/bfa_core.c                   |   4 +-
 drivers/scsi/bfa/bfa_cs.h                     | 124 +++-
 drivers/scsi/bfa/bfa_fcpim.h                  |  12 +-
 drivers/scsi/bfa/bfa_fcs.h                    |  34 +-
 drivers/scsi/bfa/bfa_fcs_fcpim.c              |   6 +-
 drivers/scsi/bfa/bfa_fcs_lport.c              |   4 +-
 drivers/scsi/bfa/bfa_fcs_rport.c              |   4 +-
 drivers/scsi/bfa/bfa_ioc.c                    |   8 +-
 drivers/scsi/bfa/bfa_ioc.h                    |  12 +-
 drivers/scsi/bfa/bfa_svc.c                    |  12 +-
 drivers/scsi/bfa/bfa_svc.h                    |  20 +-
 drivers/scsi/bfa/bfad.c                       |  12 +-
 drivers/scsi/bfa/bfad_bsg.c                   |   8 +-
 drivers/scsi/bfa/bfad_drv.h                   |   5 +-
 drivers/scsi/csiostor/csio_defs.h             |  19 +-
 drivers/scsi/csiostor/csio_hw.c               |  69 +-
 drivers/scsi/csiostor/csio_init.c             |   2 +-
 drivers/scsi/csiostor/csio_lnode.c            |  32 +-
 drivers/scsi/csiostor/csio_rnode.c            |  28 +-
 drivers/scsi/csiostor/csio_scsi.c             |  37 +-
 fs/nfsd/nfs4xdr.c                             | 620 +++++++++++-------
 include/linux/compiler_types.h                |   4 +
 include/linux/moduleparam.h                   |   4 +-
 include/linux/pci.h                           |   2 +-
 include/linux/syscalls.h                      |  18 +-
 kernel/bpf/core.c                             |  17 +
 kernel/events/core.c                          |   3 +-
 kernel/module/main.c                          |   9 +-
 kernel/sched/core.c                           |   2 +-
 net/bridge/br_private.h                       |   3 +-
 net/netfilter/ipset/ip_set_core.c             |   1 -
 scripts/Makefile.gcc-plugins                  |  12 +
 scripts/gcc-plugins/Makefile                  |   4 +-
 scripts/gcc-plugins/rap_plugin/rap.h          |  38 ++
 .../gcc-plugins/rap_plugin/rap_fptr_pass.c    | 224 +++++++
 scripts/gcc-plugins/rap_plugin/rap_hash.c     | 396 +++++++++++
 scripts/gcc-plugins/rap_plugin/rap_plugin.c   | 553 ++++++++++++++++
 scripts/gcc-plugins/rap_plugin/sip.c          |  96 +++
 scripts/mod/modpost.c                         |   6 -
 security/Kconfig                              |  20 +
 64 files changed, 2288 insertions(+), 445 deletions(-)
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap.h
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_hash.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_plugin.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/sip.c

diff --git a/Makefile b/Makefile
index 1f8dafe96..e849d765e 100644
--- a/Makefile
+++ b/Makefile
@@ -1006,10 +1006,12 @@ export CC_FLAGS_LTO
 endif
 
 ifdef CONFIG_CFI_CLANG
+ifdef CONFIG_KCFI_CLANG
 CC_FLAGS_CFI	:= -fsanitize=kcfi
 KBUILD_CFLAGS	+= $(CC_FLAGS_CFI)
 export CC_FLAGS_CFI
 endif
+endif
 
 ifdef CONFIG_DEBUG_FORCE_FUNCTION_ALIGN_64B
 KBUILD_CFLAGS += -falign-functions=64
diff --git a/arch/Kconfig b/arch/Kconfig
index b60d271bf..edf9a4c77 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -750,10 +750,16 @@ config ARCH_SUPPORTS_CFI_CLANG
 config ARCH_USES_CFI_TRAPS
 	bool
 
+config KCFI_CLANG
+	bool "Use Clang's Kernel Control Flow Integrity (KCFI)"
+	depends on $(cc-option,-fsanitize=kcfi)
+	help
+	  This option is Clang's Kernel Control Flow Integrity checking
+
 config CFI_CLANG
 	bool "Use Clang's Control Flow Integrity (CFI)"
 	depends on ARCH_SUPPORTS_CFI_CLANG
-	depends on $(cc-option,-fsanitize=kcfi)
+	depends on GCC_PLUGINS || KCFI_CLANG
 	help
 	  This option enables Clangâ€™s forward-edge Control Flow Integrity
 	  (CFI) checking, where the compiler injects a runtime check to each
diff --git a/arch/x86/entry/Makefile b/arch/x86/entry/Makefile
index ca2fe1869..faf2e5a87 100644
--- a/arch/x86/entry/Makefile
+++ b/arch/x86/entry/Makefile
@@ -21,3 +21,5 @@ obj-$(CONFIG_PREEMPTION)	+= thunk_$(BITS).o
 obj-$(CONFIG_IA32_EMULATION)	+= entry_64_compat.o syscall_32.o
 obj-$(CONFIG_X86_X32_ABI)	+= syscall_x32.o
 
+CFLAGS_REMOVE_syscall_32.o += -fplugin-arg-rap_plugin-hash=abs-finish
+CFLAGS_REMOVE_syscall_64.o += -fplugin-arg-rap_plugin-hash=abs-finish
diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c
index 6c2826417..e6c5e6fff 100644
--- a/arch/x86/entry/common.c
+++ b/arch/x86/entry/common.c
@@ -47,7 +47,17 @@ static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)
 
 	if (likely(unr < NR_syscalls)) {
 		unr = array_index_nospec(unr, NR_syscalls);
+#ifdef CONFIG_PAX_RAP
+		asm volatile("movq %[param],%%rdi\n\t"
+			"call *%P[syscall]\n\t"
+			"mov %%rax,%[result]\n\t"
+			: [result] "=m" (regs->ax)
+			: [syscall] "m" (sys_call_table[unr]),
+			[param] "m" (regs)
+			: "ax", "cx", "dx", "r8", "r9", "r10", "r11", "di", "memory");
+#else
 		regs->ax = sys_call_table[unr](regs);
+#endif
 		return true;
 	}
 	return false;
@@ -109,7 +119,48 @@ static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs, int nr)
 
 	if (likely(unr < IA32_NR_syscalls)) {
 		unr = array_index_nospec(unr, IA32_NR_syscalls);
+#ifdef CONFIG_PAX_RAP
+#ifdef CONFIG_X86_64
+		asm volatile("movl %[param1],%%edi\n\t"
+			     "movl %[param2],%%esi\n\t"
+			     "movl %[param3],%%edx\n\t"
+			     "movl %[param4],%%ecx\n\t"
+			     "movl %[param5],%%r8d\n\t"
+			     "movl %[param6],%%r9d\n\t"
+			     "call *%P[syscall]\n\t"
+			     "mov %%rax,%[result]\n\t"
+			: [result] "=m" (regs->ax)
+			: [syscall] "m" (ia32_sys_call_table[unr]),
+			  [param1] "m" (regs->bx),
+			  [param2] "m" (regs->cx),
+			  [param3] "m" (regs->dx),
+			  [param4] "m" (regs->si),
+			  [param5] "m" (regs->di),
+			  [param6] "m" (regs->bp)
+			: "ax", "di", "si", "dx", "cx", "r8", "r9", "r10", "r11", "memory");
+#else
+		asm volatile("pushl %[param6]\n\t"
+			     "pushl %[param5]\n\t"
+			     "pushl %[param4]\n\t"
+			     "pushl %[param3]\n\t"
+			     "pushl %[param2]\n\t"
+			     "pushl %[param1]\n\t"
+			     "call *%P[syscall]\n\t"
+			     "addl $6*8,%%esp\n\t"
+			     "mov %%eax,%[result]\n\t"
+			: [result] "=m" (regs->ax)
+			: [syscall] "m" (ia32_sys_call_table[unr]),
+			  [param1] "m" (regs->bx),
+			  [param2] "m" (regs->cx),
+			  [param3] "m" (regs->dx),
+			  [param4] "m" (regs->si),
+			  [param5] "m" (regs->di),
+			  [param6] "m" (regs->bp)
+			: "ax", "dx", "cx", "memory");
+#endif
+#else
 		regs->ax = ia32_sys_call_table[unr](regs);
+#endif
 	} else if (nr != -1) {
 		regs->ax = __ia32_sys_ni_syscall(regs);
 	}
diff --git a/arch/x86/include/asm/text-patching.h b/arch/x86/include/asm/text-patching.h
index 85b85a275..71814bf4f 100644
--- a/arch/x86/include/asm/text-patching.h
+++ b/arch/x86/include/asm/text-patching.h
@@ -52,6 +52,10 @@ extern void text_poke_bp(void *addr, const void *opcode, size_t len, const void
 extern void text_poke_queue(void *addr, const void *opcode, size_t len, const void *emulate);
 extern void text_poke_finish(void);
 
+#ifdef CONFIG_PAX_RAP
+extern void *memcpy_alt(void *addr, const void *opcode, size_t len);
+#endif
+
 #define INT3_INSN_SIZE		1
 #define INT3_INSN_OPCODE	0xCC
 
diff --git a/arch/x86/include/asm/vermagic.h b/arch/x86/include/asm/vermagic.h
index 75884d2cd..266f5ce89 100644
--- a/arch/x86/include/asm/vermagic.h
+++ b/arch/x86/include/asm/vermagic.h
@@ -5,6 +5,7 @@
 
 #ifdef CONFIG_X86_64
 /* X86_64 does not define MODULE_PROC_FAMILY */
+#define MODULE_PROC_FAMILY ""
 #elif defined CONFIG_M486SX
 #define MODULE_PROC_FAMILY "486SX "
 #elif defined CONFIG_M486
@@ -59,10 +60,12 @@
 #error unknown processor family
 #endif
 
-#ifdef CONFIG_X86_32
-# define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY
+#ifdef CONFIG_PAX_RAP
+#define MODULE_PAX_RAP "RAP "
 #else
-# define MODULE_ARCH_VERMAGIC ""
+#define MODULE_PAX_RAP ""
 #endif
 
+#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_PAX_RAP
+
 #endif /* _ASM_VERMAGIC_H */
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index 46b7ee0ab..346340873 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -1235,6 +1235,13 @@ void *text_poke(void *addr, const void *opcode, size_t len)
 	return __text_poke(text_poke_memcpy, addr, opcode, len);
 }
 
+#ifdef CONFIG_PAX_RAP
+void *memcpy_alt(void *addr, const void *opcode, size_t len)
+{
+    return memcpy(addr, opcode, len);
+}
+#endif
+
 /**
  * text_poke_kgdb - Update instructions on a live kernel by kgdb
  * @addr: address to modify
diff --git a/arch/x86/kernel/cpu/vmware.c b/arch/x86/kernel/cpu/vmware.c
index c34d7e533..bc14f801f 100644
--- a/arch/x86/kernel/cpu/vmware.c
+++ b/arch/x86/kernel/cpu/vmware.c
@@ -333,10 +333,17 @@ static __init int activate_jump_labels(void)
 }
 arch_initcall(activate_jump_labels);
 
+/*
+ * No need for any "IO delay" on VMware hypervisor
+ */
+static void vmware_io_delay(void)
+{
+}
+
 static void __init vmware_paravirt_ops_setup(void)
 {
 	pv_info.name = "VMware hypervisor";
-	pv_ops.cpu.io_delay = paravirt_nop;
+	pv_ops.cpu.io_delay = vmware_io_delay;
 
 	if (vmware_tsc_khz == 0)
 		return;
diff --git a/arch/x86/kernel/module.c b/arch/x86/kernel/module.c
index c032edcd3..e41af9f86 100644
--- a/arch/x86/kernel/module.c
+++ b/arch/x86/kernel/module.c
@@ -227,7 +227,11 @@ int apply_relocate_add(Elf64_Shdr *sechdrs,
 {
 	int ret;
 	bool early = me->state == MODULE_STATE_UNFORMED;
-	void *(*write)(void *, const void *, size_t) = memcpy;
+#ifdef CONFIG_PAX_RAP
+    void *(*write)(void *, const void *, size_t) = memcpy_alt;
+#else
+    void *(*write)(void *, const void *, size_t) = memcpy;
+#endif
 
 	if (!early) {
 		write = text_poke;
diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c
index 7ca2d46c0..e0129c791 100644
--- a/arch/x86/kernel/paravirt.c
+++ b/arch/x86/kernel/paravirt.c
@@ -262,6 +262,10 @@ struct pv_info pv_info = {
 /* 64-bit pagetable entries */
 #define PTE_IDENT	__PV_IS_CALLEE_SAVE(_paravirt_ident_64)
 
+void tlb_remove_page_wrapper(struct mmu_gather *tlb, void *table) {
+	tlb_remove_page(tlb, (struct page *)table);
+}
+
 struct paravirt_patch_template pv_ops = {
 	/* Cpu ops. */
 	.cpu.io_delay		= native_io_delay,
@@ -316,8 +320,7 @@ struct paravirt_patch_template pv_ops = {
 	.mmu.flush_tlb_kernel	= native_flush_tlb_global,
 	.mmu.flush_tlb_one_user	= native_flush_tlb_one_user,
 	.mmu.flush_tlb_multi	= native_flush_tlb_multi,
-	.mmu.tlb_remove_table	=
-			(void (*)(struct mmu_gather *, void *))tlb_remove_page,
+	.mmu.tlb_remove_table	= tlb_remove_page_wrapper,
 
 	.mmu.exit_mmap		= paravirt_nop,
 	.mmu.notify_page_enc_status_changed	= paravirt_nop,
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index c0a5a4f22..5d88ced16 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -121,6 +121,10 @@ do_trap_no_signal(struct task_struct *tsk, int trapnr, const char *str,
 
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_nr = trapnr;
+#ifdef CONFIG_PAX_RAP
+		if (trapnr == X86_TRAP_UD)
+			str = "PAX: overwritten function pointer or return address detected";
+#endif
 		die(str, regs, error_code);
 	} else {
 		if (fixup_vdso_exception(regs, trapnr, error_code, 0))
diff --git a/arch/x86/lib/memcpy_64.S b/arch/x86/lib/memcpy_64.S
index dd8cd8831..d96964621 100644
--- a/arch/x86/lib/memcpy_64.S
+++ b/arch/x86/lib/memcpy_64.S
@@ -28,7 +28,7 @@
  * Output:
  * rax original destination
  */
-SYM_TYPED_FUNC_START(__memcpy)
+SYM_FUNC_START(__memcpy)
 	ALTERNATIVE_2 "jmp memcpy_orig", "", X86_FEATURE_REP_GOOD, \
 		      "jmp memcpy_erms", X86_FEATURE_ERMS
 
diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c
index c0759d49f..64395bfef 100644
--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@ -373,6 +373,11 @@ struct tpm_chip *tpm_chip_alloc(struct device *pdev,
 }
 EXPORT_SYMBOL_GPL(tpm_chip_alloc);
 
+static void tpm_put_device(void *dev)
+{
+	put_device(dev);
+}
+
 /**
  * tpmm_chip_alloc() - allocate a new struct tpm_chip instance
  * @pdev: parent device to which the chip is associated
@@ -390,9 +395,7 @@ struct tpm_chip *tpmm_chip_alloc(struct device *pdev,
 	if (IS_ERR(chip))
 		return chip;
 
-	rc = devm_add_action_or_reset(pdev,
-				      (void (*)(void *)) put_device,
-				      &chip->dev);
+	rc = devm_add_action_or_reset(pdev, tpm_put_device, &chip->dev);
 	if (rc)
 		return ERR_PTR(rc);
 
diff --git a/drivers/firmware/dmi-id.c b/drivers/firmware/dmi-id.c
index 940ddf916..77a8d43e6 100644
--- a/drivers/firmware/dmi-id.c
+++ b/drivers/firmware/dmi-id.c
@@ -169,9 +169,14 @@ static int dmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static void dmi_dev_release(struct device *dev)
+{
+	kfree(dev);
+}
+
 static struct class dmi_class = {
 	.name = "dmi",
-	.dev_release = (void(*)(struct device *)) kfree,
+	.dev_release = dmi_dev_release,
 	.dev_uevent = dmi_dev_uevent,
 };
 
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/shadow.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/shadow.c
index 19188683c..9c9e9193e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/shadow.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/shadow.c
@@ -154,11 +154,16 @@ shadow_fw_init(struct nvkm_bios *bios, const char *name)
 	return (void *)fw;
 }
 
+static void shadow_fw_fini(void *fw)
+{
+	release_firmware(fw);
+}
+
 static const struct nvbios_source
 shadow_fw = {
 	.name = "firmware",
 	.init = shadow_fw_init,
-	.fini = (void(*)(void *))release_firmware,
+	.fini = shadow_fw_fini,
 	.read = shadow_fw_read,
 	.rw = false,
 };
diff --git a/drivers/net/ethernet/brocade/bna/bfa_cs.h b/drivers/net/ethernet/brocade/bna/bfa_cs.h
index 8f0ac7b99..dffc8837b 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_cs.h
+++ b/drivers/net/ethernet/brocade/bna/bfa_cs.h
@@ -26,10 +26,19 @@ struct bfa_sm_table {
 	int		state;	/*!< state machine encoding	*/
 	char		*name;	/*!< state name for display	*/
 };
-#define BFA_SM(_sm)		((bfa_sm_t)(_sm))
+#define BFA_SM(_sm)		(_sm)
+
+#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (_state))
+#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (_state))
 
 /* State machine with entry actions. */
-typedef void (*bfa_fsm_t)(void *fsm, int event);
+struct bfa_ioc;
+enum ioc_event;
+struct bfa_iocpf;
+enum iocpf_event;
+
+typedef void (*bfa_fsm_ioc_t)(struct bfa_ioc *fsm, enum ioc_event event);
+typedef void (*bfa_fsm_iocpf_t)(struct bfa_iocpf *fsm, enum iocpf_event event);
 
 /* oc - object class eg. bfa_ioc
  * st - state, eg. reset
@@ -41,16 +50,37 @@ typedef void (*bfa_fsm_t)(void *fsm, int event);
 	static void oc ## _sm_ ## st ## _entry(otype * fsm)
 
 #define bfa_fsm_set_state(_fsm, _state) do {				\
-	(_fsm)->fsm = (bfa_fsm_t)(_state);				\
+	(_fsm)->fsm = (_state);						\
 	_state ## _entry(_fsm);						\
 } while (0)
 
 #define bfa_fsm_send_event(_fsm, _event)	((_fsm)->fsm((_fsm), (_event)))
-#define bfa_fsm_cmp_state(_fsm, _state)					\
-	((_fsm)->fsm == (bfa_fsm_t)(_state))
+#define bfa_fsm_cmp_state(_fsm, _state)		((_fsm)->fsm == (_state))
+
+/* For converting from state machine function to state encoding. */
+struct iocpf_sm_table {
+	bfa_fsm_iocpf_t	sm;	/*!< state machine function	*/
+	int		state;	/*!< state machine encoding	*/
+	char		*name;	/*!< state name for display	*/
+};
+struct ioc_sm_table {
+	bfa_fsm_ioc_t	sm;	/*!< state machine function	*/
+	int		state;	/*!< state machine encoding	*/
+	char		*name;	/*!< state name for display	*/
+};
+
+static inline int
+iocpf_sm_to_state(const struct iocpf_sm_table *smt, bfa_fsm_iocpf_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
 
 static inline int
-bfa_sm_to_state(const struct bfa_sm_table *smt, bfa_sm_t sm)
+ioc_sm_to_state(const struct ioc_sm_table *smt, bfa_fsm_ioc_t sm)
 {
 	int	i = 0;
 
diff --git a/drivers/net/ethernet/brocade/bna/bfa_ioc.c b/drivers/net/ethernet/brocade/bna/bfa_ioc.c
index cd933817a..d2fb975f9 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_ioc.c
+++ b/drivers/net/ethernet/brocade/bna/bfa_ioc.c
@@ -114,7 +114,7 @@ bfa_fsm_state_decl(bfa_ioc, disabling, struct bfa_ioc, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, disabled, struct bfa_ioc, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, hwfail, struct bfa_ioc, enum ioc_event);
 
-static struct bfa_sm_table ioc_sm_table[] = {
+static struct ioc_sm_table ioc_sm_table[] = {
 	{BFA_SM(bfa_ioc_sm_uninit), BFA_IOC_UNINIT},
 	{BFA_SM(bfa_ioc_sm_reset), BFA_IOC_RESET},
 	{BFA_SM(bfa_ioc_sm_enabling), BFA_IOC_ENABLING},
@@ -183,7 +183,7 @@ bfa_fsm_state_decl(bfa_iocpf, disabling_sync, struct bfa_iocpf,
 						enum iocpf_event);
 bfa_fsm_state_decl(bfa_iocpf, disabled, struct bfa_iocpf, enum iocpf_event);
 
-static struct bfa_sm_table iocpf_sm_table[] = {
+static struct iocpf_sm_table iocpf_sm_table[] = {
 	{BFA_SM(bfa_iocpf_sm_reset), BFA_IOCPF_RESET},
 	{BFA_SM(bfa_iocpf_sm_fwcheck), BFA_IOCPF_FWMISMATCH},
 	{BFA_SM(bfa_iocpf_sm_mismatch), BFA_IOCPF_FWMISMATCH},
@@ -2860,12 +2860,12 @@ static enum bfa_ioc_state
 bfa_ioc_get_state(struct bfa_ioc *ioc)
 {
 	enum bfa_iocpf_state iocpf_st;
-	enum bfa_ioc_state ioc_st = bfa_sm_to_state(ioc_sm_table, ioc->fsm);
+	enum bfa_ioc_state ioc_st = ioc_sm_to_state(ioc_sm_table, ioc->fsm);
 
 	if (ioc_st == BFA_IOC_ENABLING ||
 		ioc_st == BFA_IOC_FAIL || ioc_st == BFA_IOC_INITFAIL) {
 
-		iocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
+		iocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
 
 		switch (iocpf_st) {
 		case BFA_IOCPF_SEMWAIT:
@@ -2983,7 +2983,7 @@ bfa_nw_iocpf_timeout(struct bfa_ioc *ioc)
 {
 	enum bfa_iocpf_state iocpf_st;
 
-	iocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
+	iocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
 
 	if (iocpf_st == BFA_IOCPF_HWINIT)
 		bfa_ioc_poll_fwinit(ioc);
diff --git a/drivers/net/ethernet/brocade/bna/bfa_ioc.h b/drivers/net/ethernet/brocade/bna/bfa_ioc.h
index edd0ed5b5..1b93441ae 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_ioc.h
+++ b/drivers/net/ethernet/brocade/bna/bfa_ioc.h
@@ -148,7 +148,7 @@ struct bfa_ioc_notify {
 } while (0)
 
 struct bfa_iocpf {
-	bfa_fsm_t		fsm;
+	bfa_fsm_iocpf_t		fsm;
 	struct bfa_ioc		*ioc;
 	bool			fw_mismatch_notified;
 	bool			auto_recover;
@@ -156,7 +156,7 @@ struct bfa_iocpf {
 };
 
 struct bfa_ioc {
-	bfa_fsm_t		fsm;
+	bfa_fsm_ioc_t		fsm;
 	struct bfa		*bfa;
 	struct bfa_pcidev	pcidev;
 	struct timer_list	ioc_timer;
diff --git a/drivers/net/ethernet/brocade/bna/bfa_msgq.h b/drivers/net/ethernet/brocade/bna/bfa_msgq.h
index 75343b535..ad775b035 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_msgq.h
+++ b/drivers/net/ethernet/brocade/bna/bfa_msgq.h
@@ -55,8 +55,10 @@ enum bfa_msgq_cmdq_flags {
 	BFA_MSGQ_CMDQ_F_DB_UPDATE	= 1,
 };
 
+enum cmdq_event;
+
 struct bfa_msgq_cmdq {
-	bfa_fsm_t			fsm;
+	void (*fsm)(struct bfa_msgq_cmdq *, enum cmdq_event);
 	enum bfa_msgq_cmdq_flags flags;
 
 	u16			producer_index;
@@ -81,8 +83,10 @@ enum bfa_msgq_rspq_flags {
 
 typedef void (*bfa_msgq_mcfunc_t)(void *cbarg, struct bfi_msgq_mhdr *mhdr);
 
+enum rspq_event;
+
 struct bfa_msgq_rspq {
-	bfa_fsm_t			fsm;
+	void (*fsm)(struct bfa_msgq_rspq *, enum rspq_event);
 	enum bfa_msgq_rspq_flags flags;
 
 	u16			producer_index;
diff --git a/drivers/net/ethernet/brocade/bna/bna_enet.c b/drivers/net/ethernet/brocade/bna/bna_enet.c
index a2c983f56..883de0ac8 100644
--- a/drivers/net/ethernet/brocade/bna/bna_enet.c
+++ b/drivers/net/ethernet/brocade/bna/bna_enet.c
@@ -1257,7 +1257,7 @@ bna_enet_mtu_get(struct bna_enet *enet)
 void
 bna_enet_enable(struct bna_enet *enet)
 {
-	if (enet->fsm != (bfa_sm_t)bna_enet_sm_stopped)
+	if (enet->fsm != bna_enet_sm_stopped)
 		return;
 
 	enet->flags |= BNA_ENET_F_ENABLED;
@@ -1751,12 +1751,12 @@ bna_ioceth_uninit(struct bna_ioceth *ioceth)
 void
 bna_ioceth_enable(struct bna_ioceth *ioceth)
 {
-	if (ioceth->fsm == (bfa_fsm_t)bna_ioceth_sm_ready) {
+	if (ioceth->fsm == bna_ioceth_sm_ready) {
 		bnad_cb_ioceth_ready(ioceth->bna->bnad);
 		return;
 	}
 
-	if (ioceth->fsm == (bfa_fsm_t)bna_ioceth_sm_stopped)
+	if (ioceth->fsm == bna_ioceth_sm_stopped)
 		bfa_fsm_send_event(ioceth, IOCETH_E_ENABLE);
 }
 
diff --git a/drivers/net/ethernet/brocade/bna/bna_tx_rx.c b/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
index 2623a0da4..c05dc7a1c 100644
--- a/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
+++ b/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
@@ -1956,7 +1956,7 @@ static void
 bna_rx_stop(struct bna_rx *rx)
 {
 	rx->rx_flags &= ~BNA_RX_F_ENET_STARTED;
-	if (rx->fsm == (bfa_fsm_t) bna_rx_sm_stopped)
+	if (rx->fsm == bna_rx_sm_stopped)
 		bna_rx_mod_cb_rx_stopped(&rx->bna->rx_mod, rx);
 	else {
 		rx->stop_cbfn = bna_rx_mod_cb_rx_stopped;
@@ -2535,7 +2535,7 @@ bna_rx_destroy(struct bna_rx *rx)
 void
 bna_rx_enable(struct bna_rx *rx)
 {
-	if (rx->fsm != (bfa_sm_t)bna_rx_sm_stopped)
+	if (rx->fsm != bna_rx_sm_stopped)
 		return;
 
 	rx->rx_flags |= BNA_RX_F_ENABLED;
@@ -3523,7 +3523,7 @@ bna_tx_destroy(struct bna_tx *tx)
 void
 bna_tx_enable(struct bna_tx *tx)
 {
-	if (tx->fsm != (bfa_sm_t)bna_tx_sm_stopped)
+	if (tx->fsm != bna_tx_sm_stopped)
 		return;
 
 	tx->flags |= BNA_TX_F_ENABLED;
diff --git a/drivers/net/ethernet/brocade/bna/bna_types.h b/drivers/net/ethernet/brocade/bna/bna_types.h
index 666b6922e..94261bb24 100644
--- a/drivers/net/ethernet/brocade/bna/bna_types.h
+++ b/drivers/net/ethernet/brocade/bna/bna_types.h
@@ -312,8 +312,10 @@ struct bna_attr {
 
 /* IOCEth */
 
+enum bna_ioceth_event;
+
 struct bna_ioceth {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_ioceth *, enum bna_ioceth_event);
 	struct bfa_ioc ioc;
 
 	struct bna_attr attr;
@@ -334,8 +336,10 @@ struct bna_pause_config {
 	enum bna_status rx_pause;
 };
 
+enum bna_enet_event;
+
 struct bna_enet {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_enet *, enum bna_enet_event);
 	enum bna_enet_flags flags;
 
 	enum bna_enet_type type;
@@ -360,8 +364,10 @@ struct bna_enet {
 
 /* Ethport */
 
+enum bna_ethport_event;
+
 struct bna_ethport {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_ethport *, enum bna_ethport_event);
 	enum bna_ethport_flags flags;
 
 	enum bna_link_status link_status;
@@ -454,13 +460,15 @@ struct bna_txq {
 };
 
 /* Tx object */
+enum bna_tx_event;
+
 struct bna_tx {
 	/* This should be the first one */
 	struct list_head			qe;
 	int			rid;
 	int			hw_id;
 
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_tx *, enum bna_tx_event);
 	enum bna_tx_flags flags;
 
 	enum bna_tx_type type;
@@ -698,8 +706,10 @@ struct bna_rxp {
 };
 
 /* RxF structure (hardware Rx Function) */
+enum bna_rxf_event;
+
 struct bna_rxf {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_rxf *, enum bna_rxf_event);
 
 	struct bfa_msgq_cmd_entry msgq_cmd;
 	union {
@@ -769,13 +779,15 @@ struct bna_rxf {
 };
 
 /* Rx object */
+enum bna_rx_event;
+
 struct bna_rx {
 	/* This should be the first one */
 	struct list_head			qe;
 	int			rid;
 	int			hw_id;
 
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_rx *, enum bna_rx_event);
 
 	enum bna_rx_type type;
 
diff --git a/drivers/net/ethernet/brocade/bna/bnad.c b/drivers/net/ethernet/brocade/bna/bnad.c
index d6d90f972..cb8e17ddf 100644
--- a/drivers/net/ethernet/brocade/bna/bnad.c
+++ b/drivers/net/ethernet/brocade/bna/bnad.c
@@ -1092,8 +1092,9 @@ bnad_cb_tx_resume(struct bnad *bnad, struct bna_tx *tx)
  * Free all TxQs buffers and then notify TX_E_CLEANUP_DONE to Tx fsm.
  */
 static void
-bnad_tx_cleanup(struct delayed_work *work)
+bnad_tx_cleanup(struct work_struct *_work)
 {
+	struct delayed_work *work = (struct delayed_work *)_work;
 	struct bnad_tx_info *tx_info =
 		container_of(work, struct bnad_tx_info, tx_cleanup_work);
 	struct bnad *bnad = NULL;
@@ -1171,7 +1172,7 @@ bnad_cb_rx_stall(struct bnad *bnad, struct bna_rx *rx)
  * Free all RxQs buffers and then notify RX_E_CLEANUP_DONE to Rx fsm.
  */
 static void
-bnad_rx_cleanup(void *work)
+bnad_rx_cleanup(struct work_struct *work)
 {
 	struct bnad_rx_info *rx_info =
 		container_of(work, struct bnad_rx_info, rx_cleanup_work);
@@ -1992,8 +1993,7 @@ bnad_setup_tx(struct bnad *bnad, u32 tx_id)
 	}
 	tx_info->tx = tx;
 
-	INIT_DELAYED_WORK(&tx_info->tx_cleanup_work,
-			(work_func_t)bnad_tx_cleanup);
+	INIT_DELAYED_WORK(&tx_info->tx_cleanup_work, bnad_tx_cleanup);
 
 	/* Register ISR for the Tx object */
 	if (intr_info->intr_type == BNA_INTR_T_MSIX) {
@@ -2249,8 +2249,7 @@ bnad_setup_rx(struct bnad *bnad, u32 rx_id)
 	rx_info->rx = rx;
 	spin_unlock_irqrestore(&bnad->bna_lock, flags);
 
-	INIT_WORK(&rx_info->rx_cleanup_work,
-			(work_func_t)(bnad_rx_cleanup));
+	INIT_WORK(&rx_info->rx_cleanup_work, bnad_rx_cleanup);
 
 	/*
 	 * Init NAPI, so that state is set to NAPI_STATE_SCHED,
diff --git a/drivers/scsi/bfa/bfa.h b/drivers/scsi/bfa/bfa.h
index 7bd2ba1ad..3d4bba3c4 100644
--- a/drivers/scsi/bfa/bfa.h
+++ b/drivers/scsi/bfa/bfa.h
@@ -216,8 +216,10 @@ struct bfa_faa_args_s {
 	bfa_boolean_t		busy;
 };
 
+enum iocfc_event;
+
 struct bfa_iocfc_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_iocfc_s *, enum iocfc_event);
 	struct bfa_s		*bfa;
 	struct bfa_iocfc_cfg_s	cfg;
 	u32		req_cq_pi[BFI_IOC_MAX_CQS];
diff --git a/drivers/scsi/bfa/bfa_core.c b/drivers/scsi/bfa/bfa_core.c
index 6846ca8f7..5c8ca0ff8 100644
--- a/drivers/scsi/bfa/bfa_core.c
+++ b/drivers/scsi/bfa/bfa_core.c
@@ -1907,15 +1907,13 @@ bfa_comp_process(struct bfa_s *bfa, struct list_head *comp_q)
 	struct list_head		*qe;
 	struct list_head		*qen;
 	struct bfa_cb_qe_s	*hcb_qe;
-	bfa_cb_cbfn_status_t	cbfn;
 
 	list_for_each_safe(qe, qen, comp_q) {
 		hcb_qe = (struct bfa_cb_qe_s *) qe;
 		if (hcb_qe->pre_rmv) {
 			/* qe is invalid after return, dequeue before cbfn() */
 			list_del(qe);
-			cbfn = (bfa_cb_cbfn_status_t)(hcb_qe->cbfn);
-			cbfn(hcb_qe->cbarg, hcb_qe->fw_status);
+			hcb_qe->cbfn(hcb_qe->cbarg, hcb_qe->fw_status);
 		} else
 			hcb_qe->cbfn(hcb_qe->cbarg, BFA_TRUE);
 	}
diff --git a/drivers/scsi/bfa/bfa_cs.h b/drivers/scsi/bfa/bfa_cs.h
index 6b606bf58..aac8ad1f5 100644
--- a/drivers/scsi/bfa/bfa_cs.h
+++ b/drivers/scsi/bfa/bfa_cs.h
@@ -176,8 +176,6 @@ bfa_q_is_on_q_func(struct list_head *q, struct list_head *qe)
  * @ BFA state machine interfaces
  */
 
-typedef void (*bfa_sm_t)(void *sm, int event);
-
 /*
  * oc - object class eg. bfa_ioc
  * st - state, eg. reset
@@ -187,20 +185,75 @@ typedef void (*bfa_sm_t)(void *sm, int event);
 #define bfa_sm_state_decl(oc, st, otype, etype)		\
 	static void oc ## _sm_ ## st(otype * fsm, etype event)
 
-#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (bfa_sm_t)(_state))
+#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (_state))
 #define bfa_sm_send_event(_sm, _event)	((_sm)->sm((_sm), (_event)))
 #define bfa_sm_get_state(_sm)		((_sm)->sm)
-#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (bfa_sm_t)(_state))
+#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (_state))
 
 /*
  * For converting from state machine function to state encoding.
  */
-struct bfa_sm_table_s {
-	bfa_sm_t	sm;	/*  state machine function	*/
+struct bfa_iocpf_s;
+enum iocpf_event;
+typedef void (*bfa_fsm_iocpf_t)(struct bfa_iocpf_s *, enum iocpf_event);
+
+struct iocpf_sm_table_s {
+	bfa_fsm_iocpf_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_ioc_s;
+enum ioc_event;
+typedef void (*bfa_fsm_ioc_t)(struct bfa_ioc_s *, enum ioc_event);
+
+struct ioc_sm_table_s {
+	bfa_fsm_ioc_t sm;	/*  state machine function	*/
 	int		state;	/*  state machine encoding	*/
 	char		*name;	/*  state name for display	*/
 };
-#define BFA_SM(_sm)	((bfa_sm_t)(_sm))
+
+struct bfa_fcs_rport_s;
+enum rport_event;
+typedef void(*bfa_fcs_rport_t)(struct bfa_fcs_rport_s *, enum rport_event);
+
+struct rport_sm_table_s {
+	bfa_fcs_rport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcs_vport_s;
+enum bfa_fcs_vport_event;
+typedef void(*bfa_fcs_vport_t)(struct bfa_fcs_vport_s *, enum bfa_fcs_vport_event);
+
+struct vport_sm_table_s {
+	bfa_fcs_vport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcs_itnim_s;
+enum bfa_fcs_itnim_event;
+typedef void(*bfa_fcs_itnim_t)(struct bfa_fcs_itnim_s *, enum bfa_fcs_itnim_event);
+
+struct itnim_sm_table_s {
+	bfa_fcs_itnim_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcport_s;
+enum bfa_fcport_sm_event;
+typedef void(*bfa_fcport_t)(struct bfa_fcport_s *, enum bfa_fcport_sm_event);
+
+struct fcport_sm_table_s {
+	bfa_fcport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+#define BFA_SM(_sm)	(_sm)
 
 /*
  * State machine with entry actions.
@@ -218,17 +271,66 @@ typedef void (*bfa_fsm_t)(void *fsm, int event);
 	static void oc ## _sm_ ## st ## _entry(otype * fsm)
 
 #define bfa_fsm_set_state(_fsm, _state) do {	\
-	(_fsm)->fsm = (bfa_fsm_t)(_state);      \
+	(_fsm)->fsm = (_state);      \
 	_state ## _entry(_fsm);      \
 } while (0)
 
 #define bfa_fsm_send_event(_fsm, _event)	((_fsm)->fsm((_fsm), (_event)))
 #define bfa_fsm_get_state(_fsm)			((_fsm)->fsm)
-#define bfa_fsm_cmp_state(_fsm, _state)		\
-	((_fsm)->fsm == (bfa_fsm_t)(_state))
+#define bfa_fsm_cmp_state(_fsm, _state)		((_fsm)->fsm == (_state))
+
+static inline int
+iocpf_sm_to_state(struct iocpf_sm_table_s *smt, bfa_fsm_iocpf_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+ioc_sm_to_state(struct ioc_sm_table_s *smt, bfa_fsm_ioc_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+rport_sm_to_state(struct rport_sm_table_s *smt, bfa_fcs_rport_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+vport_sm_to_state(struct vport_sm_table_s *smt, bfa_fcs_vport_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+itnim_sm_to_state(struct itnim_sm_table_s *smt, bfa_fcs_itnim_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
 
 static inline int
-bfa_sm_to_state(struct bfa_sm_table_s *smt, bfa_sm_t sm)
+fcport_sm_to_state(struct fcport_sm_table_s *smt, bfa_fcport_t sm)
 {
 	int	i = 0;
 
diff --git a/drivers/scsi/bfa/bfa_fcpim.h b/drivers/scsi/bfa/bfa_fcpim.h
index 8bf094335..060af3ac4 100644
--- a/drivers/scsi/bfa/bfa_fcpim.h
+++ b/drivers/scsi/bfa/bfa_fcpim.h
@@ -157,9 +157,11 @@ struct bfa_fcp_mod_s {
 /*
  * BFA IO (initiator mode)
  */
+enum bfa_ioim_event;
+
 struct bfa_ioim_s {
 	struct list_head	qe;		/*  queue elememt	*/
-	bfa_sm_t		sm;		/*  BFA ioim state machine */
+	void (*sm)(struct bfa_ioim_s *, enum bfa_ioim_event);/*  BFA ioim state machine */
 	struct bfa_s		*bfa;		/*  BFA module	*/
 	struct bfa_fcpim_s	*fcpim;		/*  parent fcpim module */
 	struct bfa_itnim_s	*itnim;		/*  i-t-n nexus for this IO  */
@@ -189,9 +191,11 @@ struct bfa_ioim_sp_s {
 /*
  * BFA Task management command (initiator mode)
  */
+enum bfa_tskim_event;
+
 struct bfa_tskim_s {
 	struct list_head	qe;
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_tskim_s *, enum bfa_tskim_event);
 	struct bfa_s		*bfa;	/*  BFA module  */
 	struct bfa_fcpim_s	*fcpim;	/*  parent fcpim module	*/
 	struct bfa_itnim_s	*itnim;	/*  i-t-n nexus for this IO  */
@@ -211,9 +215,11 @@ struct bfa_tskim_s {
 /*
  * BFA i-t-n (initiator mode)
  */
+enum bfa_itnim_event;
+
 struct bfa_itnim_s {
 	struct list_head	qe;	/*  queue element	*/
-	bfa_sm_t		sm;	/*  i-t-n im BFA state machine  */
+	void (*sm)(struct bfa_itnim_s *, enum bfa_itnim_event);/*  i-t-n im BFA state machine  */
 	struct bfa_s		*bfa;	/*  bfa instance	*/
 	struct bfa_rport_s	*rport;	/*  bfa rport	*/
 	void			*ditn;	/*  driver i-t-n structure	*/
diff --git a/drivers/scsi/bfa/bfa_fcs.h b/drivers/scsi/bfa/bfa_fcs.h
index c1baf5cd0..733a2993b 100644
--- a/drivers/scsi/bfa/bfa_fcs.h
+++ b/drivers/scsi/bfa/bfa_fcs.h
@@ -59,8 +59,10 @@ struct bfa_fcs_s;
 #define BFA_FCS_PID_IS_WKA(pid)  ((bfa_ntoh3b(pid) > 0xFFF000) ?  1 : 0)
 #define BFA_FCS_MAX_RPORT_LOGINS 1024
 
+enum vport_ns_event;
+
 struct bfa_fcs_lport_ns_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_ns_s *, enum vport_ns_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
@@ -69,18 +71,20 @@ struct bfa_fcs_lport_ns_s {
 	u8	num_rsnn_nn_retries;
 };
 
+enum port_scn_event;
 
 struct bfa_fcs_lport_scn_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_scn_s *, enum port_scn_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
 	struct bfa_fcxp_wqe_s fcxp_wqe;
 };
 
+enum port_fdmi_event;
 
 struct bfa_fcs_lport_fdmi_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_fdmi_s *, enum port_fdmi_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_ms_s *ms;	/*  parent ms */
 	struct bfa_fcxp_s *fcxp;
@@ -89,9 +93,10 @@ struct bfa_fcs_lport_fdmi_s {
 	u8	rsvd[3];
 };
 
+enum port_ms_event;
 
 struct bfa_fcs_lport_ms_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_ms_s *, enum port_ms_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
@@ -131,10 +136,11 @@ union bfa_fcs_lport_topo_u {
 	struct bfa_fcs_lport_n2n_s pn2n;
 };
 
+enum bfa_fcs_lport_event;
 
 struct bfa_fcs_lport_s {
 	struct list_head         qe;	/*  used by port/vport */
-	bfa_sm_t               sm;	/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_s *, enum bfa_fcs_lport_event);	/*  state machine */
 	struct bfa_fcs_fabric_s *fabric;	/*  parent fabric */
 	struct bfa_lport_cfg_s  port_cfg;	/*  port configuration */
 	struct bfa_timer_s link_timer;	/*  timer for link offline */
@@ -171,10 +177,11 @@ enum bfa_fcs_fabric_type {
 	BFA_FCS_FABRIC_LOOP = 3,
 };
 
+enum bfa_fcs_fabric_event;
 
 struct bfa_fcs_fabric_s {
 	struct list_head   qe;		/*  queue element */
-	bfa_sm_t	 sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_fabric_s *, enum bfa_fcs_fabric_event); /*  state machine */
 	struct bfa_fcs_s *fcs;		/*  FCS instance */
 	struct bfa_fcs_lport_s  bport;	/*  base logical port */
 	enum bfa_fcs_fabric_type fab_type; /*  fabric type */
@@ -344,9 +351,11 @@ void            bfa_fcs_lport_scn_process_rscn(struct bfa_fcs_lport_s *port,
 					      struct fchs_s *rx_frame, u32 len);
 void		bfa_fcs_lport_lip_scn_online(bfa_fcs_lport_t *port);
 
+enum bfa_fcs_vport_event;
+
 struct bfa_fcs_vport_s {
 	struct list_head		qe;		/*  queue elem	*/
-	bfa_sm_t		sm;		/*  state machine	*/
+	void (*sm)(struct bfa_fcs_vport_s *, enum bfa_fcs_vport_event);/*  state machine	*/
 	bfa_fcs_lport_t		lport;		/*  logical port	*/
 	struct bfa_timer_s	timer;
 	struct bfad_vport_s	*vport_drv;	/*  Driver private	*/
@@ -398,8 +407,10 @@ struct bfa_fcs_tin_s;
 struct bfa_fcs_iprp_s;
 
 /* Rport Features (RPF) */
+enum rpf_event;
+
 struct bfa_fcs_rpf_s {
-	bfa_sm_t	sm;	/*  state machine */
+	void (*sm)(struct bfa_fcs_rpf_s *, enum rpf_event); /*  state machine */
 	struct bfa_fcs_rport_s *rport;	/*  parent rport */
 	struct bfa_timer_s	timer;	/*  general purpose timer */
 	struct bfa_fcxp_s	*fcxp;	/*  FCXP needed for discarding */
@@ -414,6 +425,8 @@ struct bfa_fcs_rpf_s {
 	 */
 };
 
+enum rport_event;
+
 struct bfa_fcs_rport_s {
 	struct list_head	qe;	/*  used by port/vport */
 	struct bfa_fcs_lport_s *port;	/*  parent FCS port */
@@ -430,7 +443,7 @@ struct bfa_fcs_rport_s {
 	wwn_t	pwwn;	/*  port wwn of rport */
 	wwn_t	nwwn;	/*  node wwn of rport */
 	struct bfa_rport_symname_s psym_name; /*  port symbolic name  */
-	bfa_sm_t	sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_rport_s *, enum rport_event); /*  state machine */
 	struct bfa_timer_s timer;	/*  general purpose timer */
 	struct bfa_fcs_itnim_s *itnim;	/*  ITN initiator mode role */
 	struct bfa_fcs_tin_s *tin;	/*  ITN initiator mode role */
@@ -491,9 +504,10 @@ void  bfa_fcs_rpf_rport_offline(struct bfa_fcs_rport_s *rport);
  * forward declarations
  */
 struct bfad_itnim_s;
+enum bfa_fcs_itnim_event;
 
 struct bfa_fcs_itnim_s {
-	bfa_sm_t		sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_itnim_s *, enum bfa_fcs_itnim_event);/*  state machine */
 	struct bfa_fcs_rport_s	*rport;		/*  parent remote rport  */
 	struct bfad_itnim_s	*itnim_drv;	/*  driver peer instance */
 	struct bfa_fcs_s	*fcs;		/*  fcs instance	*/
diff --git a/drivers/scsi/bfa/bfa_fcs_fcpim.c b/drivers/scsi/bfa/bfa_fcs_fcpim.c
index c7de62bae..27ccaf6a4 100644
--- a/drivers/scsi/bfa/bfa_fcs_fcpim.c
+++ b/drivers/scsi/bfa/bfa_fcs_fcpim.c
@@ -52,7 +52,7 @@ static void	bfa_fcs_itnim_sm_hcb_offline(struct bfa_fcs_itnim_s *itnim,
 static void	bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim,
 					   enum bfa_fcs_itnim_event event);
 
-static struct bfa_sm_table_s itnim_sm_table[] = {
+static struct itnim_sm_table_s itnim_sm_table[] = {
 	{BFA_SM(bfa_fcs_itnim_sm_offline), BFA_ITNIM_OFFLINE},
 	{BFA_SM(bfa_fcs_itnim_sm_prli_send), BFA_ITNIM_PRLI_SEND},
 	{BFA_SM(bfa_fcs_itnim_sm_prli), BFA_ITNIM_PRLI_SENT},
@@ -665,7 +665,7 @@ bfa_status_t
 bfa_fcs_itnim_get_online_state(struct bfa_fcs_itnim_s *itnim)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pid);
-	switch (bfa_sm_to_state(itnim_sm_table, itnim->sm)) {
+	switch (itnim_sm_to_state(itnim_sm_table, itnim->sm)) {
 	case BFA_ITNIM_ONLINE:
 	case BFA_ITNIM_INITIATIOR:
 		return BFA_STATUS_OK;
@@ -765,7 +765,7 @@ bfa_fcs_itnim_attr_get(struct bfa_fcs_lport_s *port, wwn_t rpwwn,
 	if (itnim == NULL)
 		return BFA_STATUS_NO_FCPIM_NEXUS;
 
-	attr->state	    = bfa_sm_to_state(itnim_sm_table, itnim->sm);
+	attr->state	    = itnim_sm_to_state(itnim_sm_table, itnim->sm);
 	attr->retry	    = itnim->seq_rec;
 	attr->rec_support   = itnim->rec_support;
 	attr->conf_comp	    = itnim->conf_comp;
diff --git a/drivers/scsi/bfa/bfa_fcs_lport.c b/drivers/scsi/bfa/bfa_fcs_lport.c
index b12afcc4b..c84c526f8 100644
--- a/drivers/scsi/bfa/bfa_fcs_lport.c
+++ b/drivers/scsi/bfa/bfa_fcs_lport.c
@@ -6037,7 +6037,7 @@ static void	bfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport,
 static void	bfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport,
 					enum bfa_fcs_vport_event event);
 
-static struct bfa_sm_table_s  vport_sm_table[] = {
+static struct vport_sm_table_s vport_sm_table[] = {
 	{BFA_SM(bfa_fcs_vport_sm_uninit), BFA_FCS_VPORT_UNINIT},
 	{BFA_SM(bfa_fcs_vport_sm_created), BFA_FCS_VPORT_CREATED},
 	{BFA_SM(bfa_fcs_vport_sm_offline), BFA_FCS_VPORT_OFFLINE},
@@ -6864,7 +6864,7 @@ bfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport,
 	memset(attr, 0, sizeof(struct bfa_vport_attr_s));
 
 	bfa_fcs_lport_get_attr(&vport->lport, &attr->port_attr);
-	attr->vport_state = bfa_sm_to_state(vport_sm_table, vport->sm);
+	attr->vport_state = vport_sm_to_state(vport_sm_table, vport->sm);
 }
 
 
diff --git a/drivers/scsi/bfa/bfa_fcs_rport.c b/drivers/scsi/bfa/bfa_fcs_rport.c
index c21aa37b8..6db306c60 100644
--- a/drivers/scsi/bfa/bfa_fcs_rport.c
+++ b/drivers/scsi/bfa/bfa_fcs_rport.c
@@ -136,7 +136,7 @@ static void	bfa_fcs_rport_sm_fc4_off_delete(struct bfa_fcs_rport_s *rport,
 static void	bfa_fcs_rport_sm_delete_pending(struct bfa_fcs_rport_s *rport,
 						enum rport_event event);
 
-static struct bfa_sm_table_s rport_sm_table[] = {
+static struct rport_sm_table_s rport_sm_table[] = {
 	{BFA_SM(bfa_fcs_rport_sm_uninit), BFA_RPORT_UNINIT},
 	{BFA_SM(bfa_fcs_rport_sm_plogi_sending), BFA_RPORT_PLOGI},
 	{BFA_SM(bfa_fcs_rport_sm_plogiacc_sending), BFA_RPORT_ONLINE},
@@ -2964,7 +2964,7 @@ bfa_fcs_rport_send_ls_rjt(struct bfa_fcs_rport_s *rport, struct fchs_s *rx_fchs,
 int
 bfa_fcs_rport_get_state(struct bfa_fcs_rport_s *rport)
 {
-	return bfa_sm_to_state(rport_sm_table, rport->sm);
+	return rport_sm_to_state(rport_sm_table, rport->sm);
 }
 
 
diff --git a/drivers/scsi/bfa/bfa_ioc.c b/drivers/scsi/bfa/bfa_ioc.c
index 5740302d8..9e19e4f5f 100644
--- a/drivers/scsi/bfa/bfa_ioc.c
+++ b/drivers/scsi/bfa/bfa_ioc.c
@@ -140,7 +140,7 @@ bfa_fsm_state_decl(bfa_ioc, disabling, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, disabled, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, hwfail, struct bfa_ioc_s, enum ioc_event);
 
-static struct bfa_sm_table_s ioc_sm_table[] = {
+static struct ioc_sm_table_s ioc_sm_table[] = {
 	{BFA_SM(bfa_ioc_sm_uninit), BFA_IOC_UNINIT},
 	{BFA_SM(bfa_ioc_sm_reset), BFA_IOC_RESET},
 	{BFA_SM(bfa_ioc_sm_enabling), BFA_IOC_ENABLING},
@@ -228,7 +228,7 @@ bfa_fsm_state_decl(bfa_iocpf, disabling_sync, struct bfa_iocpf_s,
 						enum iocpf_event);
 bfa_fsm_state_decl(bfa_iocpf, disabled, struct bfa_iocpf_s, enum iocpf_event);
 
-static struct bfa_sm_table_s iocpf_sm_table[] = {
+static struct iocpf_sm_table_s iocpf_sm_table[] = {
 	{BFA_SM(bfa_iocpf_sm_reset), BFA_IOCPF_RESET},
 	{BFA_SM(bfa_iocpf_sm_fwcheck), BFA_IOCPF_FWMISMATCH},
 	{BFA_SM(bfa_iocpf_sm_mismatch), BFA_IOCPF_FWMISMATCH},
@@ -2815,12 +2815,12 @@ enum bfa_ioc_state
 bfa_ioc_get_state(struct bfa_ioc_s *ioc)
 {
 	enum bfa_iocpf_state iocpf_st;
-	enum bfa_ioc_state ioc_st = bfa_sm_to_state(ioc_sm_table, ioc->fsm);
+	enum bfa_ioc_state ioc_st = ioc_sm_to_state(ioc_sm_table, ioc->fsm);
 
 	if (ioc_st == BFA_IOC_ENABLING ||
 		ioc_st == BFA_IOC_FAIL || ioc_st == BFA_IOC_INITFAIL) {
 
-		iocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
+		iocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
 
 		switch (iocpf_st) {
 		case BFA_IOCPF_SEMWAIT:
diff --git a/drivers/scsi/bfa/bfa_ioc.h b/drivers/scsi/bfa/bfa_ioc.h
index 933a1c389..4e2524c76 100644
--- a/drivers/scsi/bfa/bfa_ioc.h
+++ b/drivers/scsi/bfa/bfa_ioc.h
@@ -282,16 +282,20 @@ struct bfa_ioc_notify_s {
 	(__notify)->cbarg = (__cbarg);      \
 } while (0)
 
+enum iocpf_event;
+
 struct bfa_iocpf_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_iocpf_s *, enum iocpf_event);
 	struct bfa_ioc_s	*ioc;
 	bfa_boolean_t		fw_mismatch_notified;
 	bfa_boolean_t		auto_recover;
 	u32			poll_time;
 };
 
+enum ioc_event;
+
 struct bfa_ioc_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_ioc_s *, enum ioc_event);
 	struct bfa_s		*bfa;
 	struct bfa_pcidev_s	pcidev;
 	struct bfa_timer_mod_s	*timer_mod;
@@ -775,8 +779,10 @@ struct bfa_dconf_s {
 };
 #pragma pack()
 
+enum bfa_dconf_event;
+
 struct bfa_dconf_mod_s {
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_dconf_mod_s *, enum bfa_dconf_event);
 	u8			instance;
 	bfa_boolean_t		read_data_valid;
 	bfa_boolean_t		min_cfg;
diff --git a/drivers/scsi/bfa/bfa_svc.c b/drivers/scsi/bfa/bfa_svc.c
index 4e3cef02f..6aad7ddcd 100644
--- a/drivers/scsi/bfa/bfa_svc.c
+++ b/drivers/scsi/bfa/bfa_svc.c
@@ -201,7 +201,7 @@ static void     bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln,
 static void     bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln,
 					enum bfa_fcport_ln_sm_event event);
 
-static struct bfa_sm_table_s hal_port_sm_table[] = {
+static struct fcport_sm_table_s hal_port_sm_table[] = {
 	{BFA_SM(bfa_fcport_sm_uninit), BFA_PORT_ST_UNINIT},
 	{BFA_SM(bfa_fcport_sm_enabling_qwait), BFA_PORT_ST_ENABLING_QWAIT},
 	{BFA_SM(bfa_fcport_sm_enabling), BFA_PORT_ST_ENABLING},
@@ -3545,7 +3545,7 @@ bfa_fcport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)
 	fcport->event_arg.i2hmsg = i2hmsg;
 
 	bfa_trc(bfa, msg->mhdr.msg_id);
-	bfa_trc(bfa, bfa_sm_to_state(hal_port_sm_table, fcport->sm));
+	bfa_trc(bfa, fcport_sm_to_state(hal_port_sm_table, fcport->sm));
 
 	switch (msg->mhdr.msg_id) {
 	case BFI_FCPORT_I2H_ENABLE_RSP:
@@ -3980,7 +3980,7 @@ bfa_fcport_get_attr(struct bfa_s *bfa, struct bfa_port_attr_s *attr)
 
 	attr->pport_cfg.path_tov  = bfa_fcpim_path_tov_get(bfa);
 	attr->pport_cfg.q_depth  = bfa_fcpim_qdepth_get(bfa);
-	attr->port_state = bfa_sm_to_state(hal_port_sm_table, fcport->sm);
+	attr->port_state = fcport_sm_to_state(hal_port_sm_table, fcport->sm);
 
 	attr->fec_state = fcport->fec_state;
 
@@ -4062,7 +4062,7 @@ bfa_fcport_is_disabled(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DISABLED;
 
 }
@@ -4072,7 +4072,7 @@ bfa_fcport_is_dport(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return (fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DPORT);
 }
 
@@ -4081,7 +4081,7 @@ bfa_fcport_is_ddport(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return (fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DDPORT);
 }
 
diff --git a/drivers/scsi/bfa/bfa_svc.h b/drivers/scsi/bfa/bfa_svc.h
index 9c8310957..5a4ad66bc 100644
--- a/drivers/scsi/bfa/bfa_svc.h
+++ b/drivers/scsi/bfa/bfa_svc.h
@@ -152,6 +152,8 @@ struct bfa_fcxp_rsp_info_s {
 	u32	rsp_maxlen;	/*  max response length expected */
 };
 
+typedef void (*bfa_sm_t)(void *sm, int event);
+
 struct bfa_fcxp_s {
 	struct list_head	qe;		/*  fcxp queue element */
 	bfa_sm_t	sm;		/*  state machine */
@@ -287,9 +289,11 @@ struct bfa_rport_info_s {
 /*
  * BFA rport data structure
  */
+enum bfa_rport_event;
+
 struct bfa_rport_s {
 	struct list_head	qe;	/*  queue element		    */
-	bfa_sm_t	sm;		/*  state machine		    */
+	void (*sm)(struct bfa_rport_s *, enum bfa_rport_event);/*  state machine		    */
 	struct bfa_s	*bfa;		/*  backpointer to BFA		    */
 	void		*rport_drv;	/*  fcs/driver rport object	    */
 	u16	fw_handle;	/*  firmware rport handle	    */
@@ -380,10 +384,12 @@ void	bfa_uf_res_recfg(struct bfa_s *bfa, u16 num_uf_fw);
 /*
  * LPS - bfa lport login/logout service interface
  */
+enum bfa_lps_event;
+
 struct bfa_lps_s {
 	struct list_head	qe;	/*  queue element		*/
 	struct bfa_s	*bfa;		/*  parent bfa instance	*/
-	bfa_sm_t	sm;		/*  finite state machine	*/
+	void (*sm)(struct bfa_lps_s *, enum bfa_lps_event);/*  finite state machine	*/
 	u8		bfa_tag;	/*  lport tag		*/
 	u8		fw_tag;		/*  lport fw tag                */
 	u8		reqq;		/*  lport request queue	*/
@@ -442,9 +448,11 @@ void	bfa_lps_isr(struct bfa_s *bfa, struct bfi_msg_s *msg);
 /*
  * Link notification data structure
  */
+enum bfa_fcport_ln_sm_event;
+
 struct bfa_fcport_ln_s {
 	struct bfa_fcport_s	*fcport;
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_fcport_ln_s *, enum bfa_fcport_ln_sm_event);
 	struct bfa_cb_qe_s	ln_qe;	/*  BFA callback queue elem for ln */
 	enum bfa_port_linkstate ln_event; /*  ln event for callback */
 };
@@ -458,7 +466,7 @@ struct bfa_fcport_trunk_s {
  */
 struct bfa_fcport_s {
 	struct bfa_s		*bfa;	/*  parent BFA instance */
-	bfa_sm_t		sm;	/*  port state machine */
+	void (*sm)(struct bfa_fcport_s *, enum bfa_fcport_sm_event);	/*  port state machine */
 	wwn_t			nwwn;	/*  node wwn of physical port */
 	wwn_t			pwwn;	/*  port wwn of physical oprt */
 	enum bfa_port_speed speed_sup;
@@ -706,9 +714,11 @@ struct bfa_fcdiag_lb_s {
 	u32        status;
 };
 
+enum bfa_dport_sm_event;
+
 struct bfa_dport_s {
 	struct bfa_s	*bfa;		/* Back pointer to BFA	*/
-	bfa_sm_t	sm;		/* finite state machine */
+	void (*sm)(struct bfa_dport_s *, enum bfa_dport_sm_event);/* finite state machine */
 	struct bfa_reqq_wait_s reqq_wait;
 	bfa_cb_diag_t	cbfn;
 	void		*cbarg;
diff --git a/drivers/scsi/bfa/bfad.c b/drivers/scsi/bfa/bfad.c
index e5aa982ff..4f9dd0b8a 100644
--- a/drivers/scsi/bfa/bfad.c
+++ b/drivers/scsi/bfa/bfad.c
@@ -400,6 +400,16 @@ bfad_hcb_comp(void *arg, bfa_status_t status)
 	complete(&fcomp->comp);
 }
 
+void
+bfad_stats_comp(void *arg, bfa_boolean_t _status)
+{
+	struct bfad_hal_comp *fcomp = (struct bfad_hal_comp *)arg;
+	bfa_status_t status = (bfa_status_t)_status;
+
+	fcomp->status = status;
+	complete(&fcomp->comp);
+}
+
 /*
  * bfa_init callback
  */
@@ -1429,7 +1439,7 @@ bfad_pci_remove(struct pci_dev *pdev)
  * PCI Error Recovery entry, error detected.
  */
 static pci_ers_result_t
-bfad_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
+bfad_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state state)
 {
 	struct bfad_s *bfad = pci_get_drvdata(pdev);
 	unsigned long	flags;
diff --git a/drivers/scsi/bfa/bfad_bsg.c b/drivers/scsi/bfa/bfad_bsg.c
index be8dfbe13..aea3dbbfe 100644
--- a/drivers/scsi/bfa/bfad_bsg.c
+++ b/drivers/scsi/bfa/bfad_bsg.c
@@ -2135,7 +2135,7 @@ bfad_iocmd_fcport_get_stats(struct bfad_s *bfad, void *cmd)
 	struct bfa_cb_pending_q_s cb_qe;
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp,
+	bfa_pending_q_init(&cb_qe, bfad_stats_comp,
 			   &fcomp, &iocmd->stats);
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	iocmd->status = bfa_fcport_get_stats(&bfad->bfa, &cb_qe);
@@ -2159,7 +2159,7 @@ bfad_iocmd_fcport_reset_stats(struct bfad_s *bfad, void *cmd)
 	struct bfa_cb_pending_q_s cb_qe;
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp, &fcomp, NULL);
+	bfa_pending_q_init(&cb_qe, bfad_stats_comp, &fcomp, NULL);
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	iocmd->status = bfa_fcport_clear_stats(&bfad->bfa, &cb_qe);
@@ -2443,7 +2443,7 @@ bfad_iocmd_qos_get_stats(struct bfad_s *bfad, void *cmd)
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(&bfad->bfa);
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp,
+	bfa_pending_q_init(&cb_qe, bfad_stats_comp,
 			   &fcomp, &iocmd->stats);
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
@@ -2474,7 +2474,7 @@ bfad_iocmd_qos_reset_stats(struct bfad_s *bfad, void *cmd)
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(&bfad->bfa);
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp,
+	bfa_pending_q_init(&cb_qe, bfad_stats_comp,
 			   &fcomp, NULL);
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
diff --git a/drivers/scsi/bfa/bfad_drv.h b/drivers/scsi/bfa/bfad_drv.h
index eaee7c8bc..1c0368fbe 100644
--- a/drivers/scsi/bfa/bfad_drv.h
+++ b/drivers/scsi/bfa/bfad_drv.h
@@ -179,8 +179,10 @@ union bfad_tmp_buf {
 /*
  * BFAD (PCI function) data structure
  */
+enum bfad_sm_event;
+
 struct bfad_s {
-	bfa_sm_t	sm;	/* state machine */
+	void (*sm)(struct bfad_s *, enum bfad_sm_event); /* state machine */
 	struct list_head list_entry;
 	struct bfa_s	bfa;
 	struct bfa_fcs_s bfa_fcs;
@@ -301,6 +303,7 @@ void		bfad_fcs_stop(struct bfad_s *bfad);
 void		bfad_remove_intr(struct bfad_s *bfad);
 void		bfad_hal_mem_release(struct bfad_s *bfad);
 void		bfad_hcb_comp(void *arg, bfa_status_t status);
+void		bfad_stats_comp(void *arg, bfa_boolean_t _status);
 
 int		bfad_setup_intr(struct bfad_s *bfad);
 void		bfad_remove_intr(struct bfad_s *bfad);
diff --git a/drivers/scsi/csiostor/csio_defs.h b/drivers/scsi/csiostor/csio_defs.h
index c38017b4a..3268e62fd 100644
--- a/drivers/scsi/csiostor/csio_defs.h
+++ b/drivers/scsi/csiostor/csio_defs.h
@@ -73,7 +73,8 @@ csio_list_deleted(struct list_head *list)
 #define csio_list_prev(elem)	(((struct list_head *)(elem))->prev)
 
 /* State machine */
-typedef void (*csio_sm_state_t)(void *, uint32_t);
+struct csio_sm;
+typedef void (*csio_sm_state_t)(struct csio_sm *, uint32_t);
 
 struct csio_sm {
 	struct list_head	sm_list;
@@ -81,9 +82,9 @@ struct csio_sm {
 };
 
 static inline void
-csio_set_state(void *smp, void *state)
+csio_set_state(struct csio_sm *smp, csio_sm_state_t state)
 {
-	((struct csio_sm *)smp)->sm_state = (csio_sm_state_t)state;
+	smp->sm_state = state;
 }
 
 static inline void
@@ -93,21 +94,21 @@ csio_init_state(struct csio_sm *smp, void *state)
 }
 
 static inline void
-csio_post_event(void *smp, uint32_t evt)
+csio_post_event(struct csio_sm *smp, uint32_t evt)
 {
-	((struct csio_sm *)smp)->sm_state(smp, evt);
+	smp->sm_state(smp, evt);
 }
 
 static inline csio_sm_state_t
-csio_get_state(void *smp)
+csio_get_state(struct csio_sm *smp)
 {
-	return ((struct csio_sm *)smp)->sm_state;
+	return smp->sm_state;
 }
 
 static inline bool
-csio_match_state(void *smp, void *state)
+csio_match_state(struct csio_sm *smp, csio_sm_state_t state)
 {
-	return (csio_get_state(smp) == (csio_sm_state_t)state);
+	return (csio_get_state(smp) == state);
 }
 
 #define	CSIO_ASSERT(cond)		BUG_ON(!(cond))
diff --git a/drivers/scsi/csiostor/csio_hw.c b/drivers/scsi/csiostor/csio_hw.c
index e43c5413c..3ee049d50 100644
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@ -89,15 +89,15 @@ static void csio_mgmtm_cleanup(struct csio_mgmtm *);
 static void csio_hw_mbm_cleanup(struct csio_hw *);
 
 /* State machine forward declarations */
-static void csio_hws_uninit(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_configuring(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_initializing(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_ready(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_quiescing(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_quiesced(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_resetting(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_removing(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_pcierr(struct csio_hw *, enum csio_hw_ev);
+static void csio_hws_uninit(struct csio_sm *, uint32_t);
+static void csio_hws_configuring(struct csio_sm *, uint32_t);
+static void csio_hws_initializing(struct csio_sm *, uint32_t);
+static void csio_hws_ready(struct csio_sm *, uint32_t);
+static void csio_hws_quiescing(struct csio_sm *, uint32_t);
+static void csio_hws_quiesced(struct csio_sm *, uint32_t);
+static void csio_hws_resetting(struct csio_sm *, uint32_t);
+static void csio_hws_removing(struct csio_sm *, uint32_t);
+static void csio_hws_pcierr(struct csio_sm *, uint32_t);
 
 static void csio_hw_initialize(struct csio_hw *hw);
 static void csio_evtq_stop(struct csio_hw *hw);
@@ -105,12 +105,12 @@ static void csio_evtq_start(struct csio_hw *hw);
 
 int csio_is_hw_ready(struct csio_hw *hw)
 {
-	return csio_match_state(hw, csio_hws_ready);
+	return csio_match_state(&hw->sm, csio_hws_ready);
 }
 
 int csio_is_hw_removing(struct csio_hw *hw)
 {
-	return csio_match_state(hw, csio_hws_removing);
+	return csio_match_state(&hw->sm, csio_hws_removing);
 }
 
 
@@ -2777,8 +2777,11 @@ csio_hw_fatal_err(struct csio_hw *hw)
  *
  */
 static void
-csio_hws_uninit(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_uninit(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2802,8 +2805,11 @@ csio_hws_uninit(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_configuring(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_configuring(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2840,8 +2846,11 @@ csio_hws_configuring(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_initializing(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_initializing(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2878,8 +2887,11 @@ csio_hws_initializing(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_ready(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_ready(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	/* Remember the event */
 	hw->evtflag = evt;
 
@@ -2927,8 +2939,11 @@ csio_hws_ready(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_quiescing(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_quiescing(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2987,8 +3002,11 @@ csio_hws_quiescing(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_quiesced(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_quiesced(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -3012,8 +3030,11 @@ csio_hws_quiesced(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_resetting(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_resetting(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -3038,8 +3059,11 @@ csio_hws_resetting(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_removing(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_removing(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -3073,8 +3097,11 @@ csio_hws_removing(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_pcierr(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_pcierr(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -4231,7 +4258,7 @@ csio_hw_start(struct csio_hw *hw)
 
 	if (csio_is_hw_ready(hw))
 		return 0;
-	else if (csio_match_state(hw, csio_hws_uninit))
+	else if (csio_match_state(&hw->sm, csio_hws_uninit))
 		return -EINVAL;
 	else
 		return -ENODEV;
diff --git a/drivers/scsi/csiostor/csio_init.c b/drivers/scsi/csiostor/csio_init.c
index ccbded335..59de675c4 100644
--- a/drivers/scsi/csiostor/csio_init.c
+++ b/drivers/scsi/csiostor/csio_init.c
@@ -1054,7 +1054,7 @@ static void csio_remove_one(struct pci_dev *pdev)
  *
  */
 static pci_ers_result_t
-csio_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
+csio_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state state)
 {
 	struct csio_hw *hw = pci_get_drvdata(pdev);
 
diff --git a/drivers/scsi/csiostor/csio_lnode.c b/drivers/scsi/csiostor/csio_lnode.c
index d5ac93897..f8db0065d 100644
--- a/drivers/scsi/csiostor/csio_lnode.c
+++ b/drivers/scsi/csiostor/csio_lnode.c
@@ -55,10 +55,10 @@ int csio_fdmi_enable = 1;
 #define PORT_ID_PTR(_x)         ((uint8_t *)(&_x) + 1)
 
 /* Lnode SM declarations */
-static void csio_lns_uninit(struct csio_lnode *, enum csio_ln_ev);
-static void csio_lns_online(struct csio_lnode *, enum csio_ln_ev);
-static void csio_lns_ready(struct csio_lnode *, enum csio_ln_ev);
-static void csio_lns_offline(struct csio_lnode *, enum csio_ln_ev);
+static void csio_lns_uninit(struct csio_sm *, uint32_t);
+static void csio_lns_online(struct csio_sm *, uint32_t);
+static void csio_lns_ready(struct csio_sm *, uint32_t);
+static void csio_lns_offline(struct csio_sm *, uint32_t);
 
 static int csio_ln_mgmt_submit_req(struct csio_ioreq *,
 		void (*io_cbfn) (struct csio_hw *, struct csio_ioreq *),
@@ -1095,7 +1095,7 @@ csio_handle_link_down(struct csio_hw *hw, uint8_t portid, uint32_t fcfi,
 int
 csio_is_lnode_ready(struct csio_lnode *ln)
 {
-	return (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready));
+	return (csio_get_state(&ln->sm) == csio_lns_ready);
 }
 
 /*****************************************************************************/
@@ -1111,8 +1111,10 @@ csio_is_lnode_ready(struct csio_lnode *ln)
  * Return - none.
  */
 static void
-csio_lns_uninit(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_uninit(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 	struct csio_lnode *rln = hw->rln;
 	int rv;
@@ -1164,8 +1166,10 @@ csio_lns_uninit(struct csio_lnode *ln, enum csio_ln_ev evt)
  * Return - none.
  */
 static void
-csio_lns_online(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_online(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 
 	CSIO_INC_STATS(ln, n_evt_sm[evt]);
@@ -1215,8 +1219,10 @@ csio_lns_online(struct csio_lnode *ln, enum csio_ln_ev evt)
  * Return - none.
  */
 static void
-csio_lns_ready(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_ready(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 
 	CSIO_INC_STATS(ln, n_evt_sm[evt]);
@@ -1289,8 +1295,10 @@ csio_lns_ready(struct csio_lnode *ln, enum csio_ln_ev evt)
  * Return - none.
  */
 static void
-csio_lns_offline(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_offline(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 	struct csio_lnode *rln = hw->rln;
 	int rv;
@@ -1366,15 +1374,15 @@ csio_free_fcfinfo(struct kref *kref)
 void
 csio_lnode_state_to_str(struct csio_lnode *ln, int8_t *str)
 {
-	if (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_uninit)) {
+	if (csio_get_state(&ln->sm) == csio_lns_uninit) {
 		strcpy(str, "UNINIT");
 		return;
 	}
-	if (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready)) {
+	if (csio_get_state(&ln->sm) == csio_lns_ready) {
 		strcpy(str, "READY");
 		return;
 	}
-	if (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_offline)) {
+	if (csio_get_state(&ln->sm) == csio_lns_offline) {
 		strcpy(str, "OFFLINE");
 		return;
 	}
diff --git a/drivers/scsi/csiostor/csio_rnode.c b/drivers/scsi/csiostor/csio_rnode.c
index 713e13adf..dcbdf1125 100644
--- a/drivers/scsi/csiostor/csio_rnode.c
+++ b/drivers/scsi/csiostor/csio_rnode.c
@@ -46,10 +46,10 @@ static int csio_rnode_init(struct csio_rnode *, struct csio_lnode *);
 static void csio_rnode_exit(struct csio_rnode *);
 
 /* Static machine forward declarations */
-static void csio_rns_uninit(struct csio_rnode *, enum csio_rn_ev);
-static void csio_rns_ready(struct csio_rnode *, enum csio_rn_ev);
-static void csio_rns_offline(struct csio_rnode *, enum csio_rn_ev);
-static void csio_rns_disappeared(struct csio_rnode *, enum csio_rn_ev);
+static void csio_rns_uninit(struct csio_sm *, uint32_t);
+static void csio_rns_ready(struct csio_sm *, uint32_t);
+static void csio_rns_offline(struct csio_sm *, uint32_t);
+static void csio_rns_disappeared(struct csio_sm *, uint32_t);
 
 /* RNF event mapping */
 static enum csio_rn_ev fwevt_to_rnevt[] = {
@@ -88,13 +88,13 @@ static enum csio_rn_ev fwevt_to_rnevt[] = {
 int
 csio_is_rnode_ready(struct csio_rnode *rn)
 {
-	return csio_match_state(rn, csio_rns_ready);
+	return csio_match_state(&rn->sm, csio_rns_ready);
 }
 
 static int
 csio_is_rnode_uninit(struct csio_rnode *rn)
 {
-	return csio_match_state(rn, csio_rns_uninit);
+	return csio_match_state(&rn->sm, csio_rns_uninit);
 }
 
 static int
@@ -601,8 +601,10 @@ __csio_unreg_rnode(struct csio_rnode *rn)
  *
  */
 static void
-csio_rns_uninit(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_uninit(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
@@ -641,8 +643,10 @@ csio_rns_uninit(struct csio_rnode *rn, enum csio_rn_ev evt)
  *
  */
 static void
-csio_rns_ready(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_ready(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
@@ -726,8 +730,10 @@ csio_rns_ready(struct csio_rnode *rn, enum csio_rn_ev evt)
  *
  */
 static void
-csio_rns_offline(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_offline(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
@@ -785,8 +791,10 @@ csio_rns_offline(struct csio_rnode *rn, enum csio_rn_ev evt)
  *
  */
 static void
-csio_rns_disappeared(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_disappeared(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
diff --git a/drivers/scsi/csiostor/csio_scsi.c b/drivers/scsi/csiostor/csio_scsi.c
index 05e1a63e0..3b5dff3b6 100644
--- a/drivers/scsi/csiostor/csio_scsi.c
+++ b/drivers/scsi/csiostor/csio_scsi.c
@@ -65,12 +65,12 @@ static int csio_ddp_descs = 128;
 static int csio_do_abrt_cls(struct csio_hw *,
 				      struct csio_ioreq *, bool);
 
-static void csio_scsis_uninit(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_io_active(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_tm_active(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_aborting(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_closing(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_shost_cmpl_await(struct csio_ioreq *, enum csio_scsi_ev);
+static void csio_scsis_uninit(struct csio_sm *, uint32_t);
+static void csio_scsis_io_active(struct csio_sm *, uint32_t);
+static void csio_scsis_tm_active(struct csio_sm *, uint32_t);
+static void csio_scsis_aborting(struct csio_sm *, uint32_t);
+static void csio_scsis_closing(struct csio_sm *, uint32_t);
+static void csio_scsis_shost_cmpl_await(struct csio_sm *, uint32_t);
 
 /*
  * csio_scsi_match_io - Match an ioreq with the given SCSI level data.
@@ -700,8 +700,10 @@ csio_scsi_abrt_cls(struct csio_ioreq *req, bool abort)
 /* START: SCSI SM                                                            */
 /*****************************************************************************/
 static void
-csio_scsis_uninit(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_uninit(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scsim = csio_hw_to_scsim(hw);
 
@@ -770,8 +772,10 @@ csio_scsis_uninit(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_io_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_io_active(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 	struct csio_rnode *rn;
@@ -842,8 +846,10 @@ csio_scsis_io_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_tm_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_tm_active(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 
@@ -885,8 +891,10 @@ csio_scsis_tm_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_aborting(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_aborting(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 
@@ -982,8 +990,10 @@ csio_scsis_aborting(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_closing(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_closing(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 
@@ -1046,8 +1056,11 @@ csio_scsis_closing(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_shost_cmpl_await(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_shost_cmpl_await(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
+
 	switch (evt) {
 	case CSIO_SCSIE_ABORT:
 	case CSIO_SCSIE_CLOSE:
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 89a579be0..a53960847 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -529,8 +529,9 @@ nfsd4_decode_fattr4(struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen,
 }
 
 static __be32
-nfsd4_decode_stateid4(struct nfsd4_compoundargs *argp, stateid_t *sid)
+nfsd4_decode_stateid4(struct nfsd4_compoundargs *argp, void *_sid)
 {
+	stateid_t *sid = _sid;
 	__be32 *p;
 
 	p = xdr_inline_decode(argp->xdr, NFS4_STATEID_SIZE);
@@ -722,8 +723,9 @@ nfsd4_decode_gss_cb_handles4(struct nfsd4_compoundargs *argp,
 
 /* a counted array of callback_sec_parms4 items */
 static __be32
-nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
+nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, void *_cbs)
 {
+	struct nfsd4_cb_sec *cbs = _cbs;
 	u32 i, secflavor, nr_secflavs;
 	__be32 status;
 
@@ -770,16 +772,19 @@ nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)
 
 static __be32
 nfsd4_decode_access(struct nfsd4_compoundargs *argp,
-		    struct nfsd4_access *access)
+		    void *_access)
 {
+	struct nfsd4_access *access = _access;
 	if (xdr_stream_decode_u32(argp->xdr, &access->ac_req_access) < 0)
 		return nfserr_bad_xdr;
 	return nfs_ok;
 }
 
 static __be32
-nfsd4_decode_close(struct nfsd4_compoundargs *argp, struct nfsd4_close *close)
+nfsd4_decode_close(struct nfsd4_compoundargs *argp, void *_close)
 {
+	struct nfsd4_close *close = _close;
+
 	if (xdr_stream_decode_u32(argp->xdr, &close->cl_seqid) < 0)
 		return nfserr_bad_xdr;
 	return nfsd4_decode_stateid4(argp, &close->cl_stateid);
@@ -787,8 +792,10 @@ nfsd4_decode_close(struct nfsd4_compoundargs *argp, struct nfsd4_close *close)
 
 
 static __be32
-nfsd4_decode_commit(struct nfsd4_compoundargs *argp, struct nfsd4_commit *commit)
+nfsd4_decode_commit(struct nfsd4_compoundargs *argp, void *_commit)
 {
+	struct nfsd4_commit *commit = _commit;
+
 	if (xdr_stream_decode_u64(argp->xdr, &commit->co_offset) < 0)
 		return nfserr_bad_xdr;
 	if (xdr_stream_decode_u32(argp->xdr, &commit->co_count) < 0)
@@ -798,8 +805,9 @@ nfsd4_decode_commit(struct nfsd4_compoundargs *argp, struct nfsd4_commit *commit
 }
 
 static __be32
-nfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create)
+nfsd4_decode_create(struct nfsd4_compoundargs *argp, void *_create)
 {
+	struct nfsd4_create *create = _create;
 	__be32 *p, status;
 
 	memset(create, 0, sizeof(*create));
@@ -844,22 +852,28 @@ nfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create
 }
 
 static inline __be32
-nfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, struct nfsd4_delegreturn *dr)
+nfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, void *_dr)
 {
+	struct nfsd4_delegreturn *dr = _dr;
+
 	return nfsd4_decode_stateid4(argp, &dr->dr_stateid);
 }
 
 static inline __be32
-nfsd4_decode_getattr(struct nfsd4_compoundargs *argp, struct nfsd4_getattr *getattr)
+nfsd4_decode_getattr(struct nfsd4_compoundargs *argp, void *_getattr)
 {
+	struct nfsd4_getattr *getattr = _getattr;
+
 	memset(getattr, 0, sizeof(*getattr));
 	return nfsd4_decode_bitmap4(argp, getattr->ga_bmval,
 				    ARRAY_SIZE(getattr->ga_bmval));
 }
 
 static __be32
-nfsd4_decode_link(struct nfsd4_compoundargs *argp, struct nfsd4_link *link)
+nfsd4_decode_link(struct nfsd4_compoundargs *argp, void *_link)
 {
+	struct nfsd4_link *link = _link;
+
 	memset(link, 0, sizeof(*link));
 	return nfsd4_decode_component4(argp, &link->li_name, &link->li_namelen);
 }
@@ -907,8 +921,10 @@ nfsd4_decode_locker4(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)
 }
 
 static __be32
-nfsd4_decode_lock(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)
+nfsd4_decode_lock(struct nfsd4_compoundargs *argp, void *_lock)
 {
+	struct nfsd4_lock *lock = _lock;
+
 	memset(lock, 0, sizeof(*lock));
 	if (xdr_stream_decode_u32(argp->xdr, &lock->lk_type) < 0)
 		return nfserr_bad_xdr;
@@ -924,8 +940,10 @@ nfsd4_decode_lock(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)
 }
 
 static __be32
-nfsd4_decode_lockt(struct nfsd4_compoundargs *argp, struct nfsd4_lockt *lockt)
+nfsd4_decode_lockt(struct nfsd4_compoundargs *argp, void *_lockt)
 {
+	struct nfsd4_lockt *lockt = _lockt;
+
 	memset(lockt, 0, sizeof(*lockt));
 	if (xdr_stream_decode_u32(argp->xdr, &lockt->lt_type) < 0)
 		return nfserr_bad_xdr;
@@ -940,8 +958,9 @@ nfsd4_decode_lockt(struct nfsd4_compoundargs *argp, struct nfsd4_lockt *lockt)
 }
 
 static __be32
-nfsd4_decode_locku(struct nfsd4_compoundargs *argp, struct nfsd4_locku *locku)
+nfsd4_decode_locku(struct nfsd4_compoundargs *argp, void *_locku)
 {
+	struct nfsd4_locku *locku = _locku;
 	__be32 status;
 
 	if (xdr_stream_decode_u32(argp->xdr, &locku->lu_type) < 0)
@@ -962,8 +981,10 @@ nfsd4_decode_locku(struct nfsd4_compoundargs *argp, struct nfsd4_locku *locku)
 }
 
 static __be32
-nfsd4_decode_lookup(struct nfsd4_compoundargs *argp, struct nfsd4_lookup *lookup)
+nfsd4_decode_lookup(struct nfsd4_compoundargs *argp, void *_lookup)
 {
+	struct nfsd4_lookup *lookup = _lookup;
+
 	return nfsd4_decode_component4(argp, &lookup->lo_name, &lookup->lo_len);
 }
 
@@ -1143,8 +1164,9 @@ nfsd4_decode_open_claim4(struct nfsd4_compoundargs *argp,
 }
 
 static __be32
-nfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)
+nfsd4_decode_open(struct nfsd4_compoundargs *argp, void *_open)
 {
+	struct nfsd4_open *open = _open;
 	__be32 status;
 	u32 dummy;
 
@@ -1171,8 +1193,9 @@ nfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)
 }
 
 static __be32
-nfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_open_confirm *open_conf)
+nfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, void *_open_conf)
 {
+	struct nfsd4_open_confirm *open_conf = _open_conf;
 	__be32 status;
 
 	if (argp->minorversion >= 1)
@@ -1190,8 +1213,9 @@ nfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_open_con
 }
 
 static __be32
-nfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, struct nfsd4_open_downgrade *open_down)
+nfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, void *_open_down)
 {
+	struct nfsd4_open_downgrade *open_down = _open_down;
 	__be32 status;
 
 	memset(open_down, 0, sizeof(*open_down));
@@ -1209,8 +1233,9 @@ nfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, struct nfsd4_open_d
 }
 
 static __be32
-nfsd4_decode_putfh(struct nfsd4_compoundargs *argp, struct nfsd4_putfh *putfh)
+nfsd4_decode_putfh(struct nfsd4_compoundargs *argp, void *_putfh)
 {
+	struct nfsd4_putfh *putfh = _putfh;
 	__be32 *p;
 
 	if (xdr_stream_decode_u32(argp->xdr, &putfh->pf_fhlen) < 0)
@@ -1237,8 +1262,9 @@ nfsd4_decode_putpubfh(struct nfsd4_compoundargs *argp, void *p)
 }
 
 static __be32
-nfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)
+nfsd4_decode_read(struct nfsd4_compoundargs *argp, void *_read)
 {
+	struct nfsd4_read *read = _read;
 	__be32 status;
 
 	memset(read, 0, sizeof(*read));
@@ -1254,8 +1280,9 @@ nfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)
 }
 
 static __be32
-nfsd4_decode_readdir(struct nfsd4_compoundargs *argp, struct nfsd4_readdir *readdir)
+nfsd4_decode_readdir(struct nfsd4_compoundargs *argp, void *_readdir)
 {
+	struct nfsd4_readdir *readdir = _readdir;
 	__be32 status;
 
 	memset(readdir, 0, sizeof(*readdir));
@@ -1276,15 +1303,18 @@ nfsd4_decode_readdir(struct nfsd4_compoundargs *argp, struct nfsd4_readdir *read
 }
 
 static __be32
-nfsd4_decode_remove(struct nfsd4_compoundargs *argp, struct nfsd4_remove *remove)
+nfsd4_decode_remove(struct nfsd4_compoundargs *argp, void *_remove)
 {
+	struct nfsd4_remove *remove = _remove;
+
 	memset(&remove->rm_cinfo, 0, sizeof(remove->rm_cinfo));
 	return nfsd4_decode_component4(argp, &remove->rm_name, &remove->rm_namelen);
 }
 
 static __be32
-nfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename)
+nfsd4_decode_rename(struct nfsd4_compoundargs *argp, void *_rename)
 {
+	struct nfsd4_rename *rename = _rename;
 	__be32 status;
 
 	memset(rename, 0, sizeof(*rename));
@@ -1295,22 +1325,25 @@ nfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename
 }
 
 static __be32
-nfsd4_decode_renew(struct nfsd4_compoundargs *argp, clientid_t *clientid)
+nfsd4_decode_renew(struct nfsd4_compoundargs *argp, void *clientid)
 {
 	return nfsd4_decode_clientid4(argp, clientid);
 }
 
 static __be32
 nfsd4_decode_secinfo(struct nfsd4_compoundargs *argp,
-		     struct nfsd4_secinfo *secinfo)
+		     void *_secinfo)
 {
+	struct nfsd4_secinfo *secinfo = _secinfo;
+
 	secinfo->si_exp = NULL;
 	return nfsd4_decode_component4(argp, &secinfo->si_name, &secinfo->si_namelen);
 }
 
 static __be32
-nfsd4_decode_setattr(struct nfsd4_compoundargs *argp, struct nfsd4_setattr *setattr)
+nfsd4_decode_setattr(struct nfsd4_compoundargs *argp, void *_setattr)
 {
+	struct nfsd4_setattr *setattr = _setattr;
 	__be32 status;
 
 	memset(setattr, 0, sizeof(*setattr));
@@ -1324,8 +1357,9 @@ nfsd4_decode_setattr(struct nfsd4_compoundargs *argp, struct nfsd4_setattr *seta
 }
 
 static __be32
-nfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid *setclientid)
+nfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, void *_setclientid)
 {
+	struct nfsd4_setclientid *setclientid = _setclientid;
 	__be32 *p, status;
 
 	memset(setclientid, 0, sizeof(*setclientid));
@@ -1367,8 +1401,9 @@ nfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclient
 }
 
 static __be32
-nfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid_confirm *scd_c)
+nfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, void *_scd_c)
 {
+	struct nfsd4_setclientid_confirm *scd_c = _scd_c;
 	__be32 status;
 
 	if (argp->minorversion >= 1)
@@ -1382,8 +1417,9 @@ nfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_s
 
 /* Also used for NVERIFY */
 static __be32
-nfsd4_decode_verify(struct nfsd4_compoundargs *argp, struct nfsd4_verify *verify)
+nfsd4_decode_verify(struct nfsd4_compoundargs *argp, void *_verify)
 {
+	struct nfsd4_verify *verify = _verify;
 	__be32 *p, status;
 
 	memset(verify, 0, sizeof(*verify));
@@ -1409,8 +1445,9 @@ nfsd4_decode_verify(struct nfsd4_compoundargs *argp, struct nfsd4_verify *verify
 }
 
 static __be32
-nfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)
+nfsd4_decode_write(struct nfsd4_compoundargs *argp, void *_write)
 {
+	struct nfsd4_write *write = _write;
 	__be32 status;
 
 	status = nfsd4_decode_stateid4(argp, &write->wr_stateid);
@@ -1434,8 +1471,9 @@ nfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)
 }
 
 static __be32
-nfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, struct nfsd4_release_lockowner *rlockowner)
+nfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, void *_rlockowner)
 {
+	struct nfsd4_release_lockowner *rlockowner = _rlockowner;
 	__be32 status;
 
 	if (argp->minorversion >= 1)
@@ -1452,16 +1490,19 @@ nfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, struct nfsd4_rel
 	return nfs_ok;
 }
 
-static __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, struct nfsd4_backchannel_ctl *bc)
+static __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, void *_bc)
 {
+	struct nfsd4_backchannel_ctl *bc = _bc;
+
 	memset(bc, 0, sizeof(*bc));
 	if (xdr_stream_decode_u32(argp->xdr, &bc->bc_cb_program) < 0)
 		return nfserr_bad_xdr;
 	return nfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);
 }
 
-static __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)
+static __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, void *_bcts)
 {
+	struct nfsd4_bind_conn_to_session *bcts = _bcts;
 	u32 use_conn_in_rdma_mode;
 	__be32 status;
 
@@ -1603,8 +1644,9 @@ nfsd4_decode_nfs_impl_id4(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,
-			 struct nfsd4_exchange_id *exid)
+			 void *_exid)
 {
+	struct nfsd4_exchange_id *exid = _exid;
 	__be32 status;
 
 	memset(exid, 0, sizeof(*exid));
@@ -1656,8 +1698,9 @@ nfsd4_decode_channel_attrs4(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_create_session(struct nfsd4_compoundargs *argp,
-			    struct nfsd4_create_session *sess)
+			    void *_sess)
 {
+	struct nfsd4_create_session *sess = _sess;
 	__be32 status;
 
 	memset(sess, 0, sizeof(*sess));
@@ -1681,23 +1724,28 @@ nfsd4_decode_create_session(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_destroy_session(struct nfsd4_compoundargs *argp,
-			     struct nfsd4_destroy_session *destroy_session)
+			     void *_destroy_session)
 {
+	struct nfsd4_destroy_session *destroy_session = _destroy_session;
+
 	return nfsd4_decode_sessionid4(argp, &destroy_session->sessionid);
 }
 
 static __be32
 nfsd4_decode_free_stateid(struct nfsd4_compoundargs *argp,
-			  struct nfsd4_free_stateid *free_stateid)
+			  void *_free_stateid)
 {
+	struct nfsd4_free_stateid *free_stateid = _free_stateid;
+
 	return nfsd4_decode_stateid4(argp, &free_stateid->fr_stateid);
 }
 
 #ifdef CONFIG_NFSD_PNFS
 static __be32
 nfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,
-		struct nfsd4_getdeviceinfo *gdev)
+		void *_gdev)
 {
+	struct nfsd4_getdeviceinfo *gdev = _gdev;
 	__be32 status;
 
 	memset(gdev, 0, sizeof(*gdev));
@@ -1717,8 +1765,9 @@ nfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,
-			  struct nfsd4_layoutcommit *lcp)
+			  void *_lcp)
 {
+	struct nfsd4_layoutcommit *lcp = _lcp;
 	__be32 *p, status;
 
 	memset(lcp, 0, sizeof(*lcp));
@@ -1753,8 +1802,9 @@ nfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,
-		struct nfsd4_layoutget *lgp)
+		void *_lgp)
 {
+	struct nfsd4_layoutget *lgp = _lgp;
 	__be32 status;
 
 	memset(lgp, 0, sizeof(*lgp));
@@ -1781,8 +1831,10 @@ nfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,
-		struct nfsd4_layoutreturn *lrp)
+		void *_lrp)
 {
+	struct nfsd4_layoutreturn *lrp = _lrp;
+
 	memset(lrp, 0, sizeof(*lrp));
 	if (xdr_stream_decode_bool(argp->xdr, &lrp->lr_reclaim) < 0)
 		return nfserr_bad_xdr;
@@ -1795,8 +1847,10 @@ nfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,
 #endif /* CONFIG_NFSD_PNFS */
 
 static __be32 nfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,
-					   struct nfsd4_secinfo_no_name *sin)
+					   void *_sin)
 {
+	struct nfsd4_secinfo_no_name *sin = _sin;
+
 	if (xdr_stream_decode_u32(argp->xdr, &sin->sin_style) < 0)
 		return nfserr_bad_xdr;
 
@@ -1806,8 +1860,9 @@ static __be32 nfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_sequence(struct nfsd4_compoundargs *argp,
-		      struct nfsd4_sequence *seq)
+		      void *_seq)
 {
+	struct nfsd4_sequence *seq = _seq;
 	__be32 *p, status;
 
 	status = nfsd4_decode_sessionid4(argp, &seq->sessionid);
@@ -1826,8 +1881,9 @@ nfsd4_decode_sequence(struct nfsd4_compoundargs *argp,
 }
 
 static __be32
-nfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, struct nfsd4_test_stateid *test_stateid)
+nfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, void *_test_stateid)
 {
+	struct nfsd4_test_stateid *test_stateid = _test_stateid;
 	struct nfsd4_test_stateid_id *stateid;
 	__be32 status;
 	u32 i;
@@ -1852,14 +1908,18 @@ nfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, struct nfsd4_test_sta
 }
 
 static __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp,
-					    struct nfsd4_destroy_clientid *dc)
+					    void *_dc)
 {
+	struct nfsd4_destroy_clientid *dc = _dc;
+
 	return nfsd4_decode_clientid4(argp, &dc->clientid);
 }
 
 static __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp,
-					    struct nfsd4_reclaim_complete *rc)
+					    void *_rc)
 {
+	struct nfsd4_reclaim_complete *rc = _rc;
+
 	if (xdr_stream_decode_bool(argp->xdr, &rc->rca_one_fs) < 0)
 		return nfserr_bad_xdr;
 	return nfs_ok;
@@ -1867,8 +1927,9 @@ static __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_fallocate(struct nfsd4_compoundargs *argp,
-		       struct nfsd4_fallocate *fallocate)
+		       void *_fallocate)
 {
+	struct nfsd4_fallocate *fallocate = _fallocate;
 	__be32 status;
 
 	status = nfsd4_decode_stateid4(argp, &fallocate->falloc_stateid);
@@ -1924,8 +1985,9 @@ static __be32 nfsd4_decode_nl4_server(struct nfsd4_compoundargs *argp,
 }
 
 static __be32
-nfsd4_decode_copy(struct nfsd4_compoundargs *argp, struct nfsd4_copy *copy)
+nfsd4_decode_copy(struct nfsd4_compoundargs *argp, void *_copy)
 {
+	struct nfsd4_copy *copy = _copy;
 	u32 consecutive, i, count, sync;
 	struct nl4_server *ns_dummy;
 	__be32 status;
@@ -1982,8 +2044,9 @@ nfsd4_decode_copy(struct nfsd4_compoundargs *argp, struct nfsd4_copy *copy)
 
 static __be32
 nfsd4_decode_copy_notify(struct nfsd4_compoundargs *argp,
-			 struct nfsd4_copy_notify *cn)
+			 void *_cn)
 {
+	struct nfsd4_copy_notify *cn = _cn;
 	__be32 status;
 
 	memset(cn, 0, sizeof(*cn));
@@ -2002,16 +2065,18 @@ nfsd4_decode_copy_notify(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_offload_status(struct nfsd4_compoundargs *argp,
-			    struct nfsd4_offload_status *os)
+			    void *_os)
 {
+	struct nfsd4_offload_status *os = _os;
 	os->count = 0;
 	os->status = 0;
 	return nfsd4_decode_stateid4(argp, &os->stateid);
 }
 
 static __be32
-nfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)
+nfsd4_decode_seek(struct nfsd4_compoundargs *argp, void *_seek)
 {
+	struct nfsd4_seek *seek = _seek;
 	__be32 status;
 
 	status = nfsd4_decode_stateid4(argp, &seek->seek_stateid);
@@ -2028,8 +2093,9 @@ nfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)
 }
 
 static __be32
-nfsd4_decode_clone(struct nfsd4_compoundargs *argp, struct nfsd4_clone *clone)
+nfsd4_decode_clone(struct nfsd4_compoundargs *argp, void *_clone)
 {
+	struct nfsd4_clone *clone = _clone;
 	__be32 status;
 
 	status = nfsd4_decode_stateid4(argp, &clone->cl_src_stateid);
@@ -2154,8 +2220,9 @@ nfsd4_decode_xattr_name(struct nfsd4_compoundargs *argp, char **namep)
  */
 static __be32
 nfsd4_decode_getxattr(struct nfsd4_compoundargs *argp,
-		      struct nfsd4_getxattr *getxattr)
+		      void *_getxattr)
 {
+    struct nfsd4_getxattr *getxattr = _getxattr;
 	__be32 status;
 	u32 maxcount;
 
@@ -2173,8 +2240,9 @@ nfsd4_decode_getxattr(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_setxattr(struct nfsd4_compoundargs *argp,
-		      struct nfsd4_setxattr *setxattr)
+		      void *_setxattr)
 {
+	struct nfsd4_setxattr *setxattr = _setxattr;
 	u32 flags, maxcount, size;
 	__be32 status;
 
@@ -2214,8 +2282,9 @@ nfsd4_decode_setxattr(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_listxattrs(struct nfsd4_compoundargs *argp,
-			struct nfsd4_listxattrs *listxattrs)
+			void *_listxattrs)
 {
+	struct nfsd4_listxattrs *listxattrs = _listxattrs;
 	u32 maxcount;
 
 	memset(listxattrs, 0, sizeof(*listxattrs));
@@ -2245,8 +2314,9 @@ nfsd4_decode_listxattrs(struct nfsd4_compoundargs *argp,
 
 static __be32
 nfsd4_decode_removexattr(struct nfsd4_compoundargs *argp,
-			 struct nfsd4_removexattr *removexattr)
+			 void *_removexattr)
 {
+	struct nfsd4_removexattr *removexattr = _removexattr;
 	memset(removexattr, 0, sizeof(*removexattr));
 	return nfsd4_decode_xattr_name(argp, &removexattr->rmxa_name);
 }
@@ -2266,92 +2336,91 @@ nfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)
 typedef __be32(*nfsd4_dec)(struct nfsd4_compoundargs *argp, void *);
 
 static const nfsd4_dec nfsd4_dec_ops[] = {
-	[OP_ACCESS]		= (nfsd4_dec)nfsd4_decode_access,
-	[OP_CLOSE]		= (nfsd4_dec)nfsd4_decode_close,
-	[OP_COMMIT]		= (nfsd4_dec)nfsd4_decode_commit,
-	[OP_CREATE]		= (nfsd4_dec)nfsd4_decode_create,
-	[OP_DELEGPURGE]		= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_DELEGRETURN]	= (nfsd4_dec)nfsd4_decode_delegreturn,
-	[OP_GETATTR]		= (nfsd4_dec)nfsd4_decode_getattr,
-	[OP_GETFH]		= (nfsd4_dec)nfsd4_decode_noop,
-	[OP_LINK]		= (nfsd4_dec)nfsd4_decode_link,
-	[OP_LOCK]		= (nfsd4_dec)nfsd4_decode_lock,
-	[OP_LOCKT]		= (nfsd4_dec)nfsd4_decode_lockt,
-	[OP_LOCKU]		= (nfsd4_dec)nfsd4_decode_locku,
-	[OP_LOOKUP]		= (nfsd4_dec)nfsd4_decode_lookup,
-	[OP_LOOKUPP]		= (nfsd4_dec)nfsd4_decode_noop,
-	[OP_NVERIFY]		= (nfsd4_dec)nfsd4_decode_verify,
-	[OP_OPEN]		= (nfsd4_dec)nfsd4_decode_open,
-	[OP_OPENATTR]		= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_OPEN_CONFIRM]	= (nfsd4_dec)nfsd4_decode_open_confirm,
-	[OP_OPEN_DOWNGRADE]	= (nfsd4_dec)nfsd4_decode_open_downgrade,
-	[OP_PUTFH]		= (nfsd4_dec)nfsd4_decode_putfh,
-	[OP_PUTPUBFH]		= (nfsd4_dec)nfsd4_decode_putpubfh,
-	[OP_PUTROOTFH]		= (nfsd4_dec)nfsd4_decode_noop,
-	[OP_READ]		= (nfsd4_dec)nfsd4_decode_read,
-	[OP_READDIR]		= (nfsd4_dec)nfsd4_decode_readdir,
-	[OP_READLINK]		= (nfsd4_dec)nfsd4_decode_noop,
-	[OP_REMOVE]		= (nfsd4_dec)nfsd4_decode_remove,
-	[OP_RENAME]		= (nfsd4_dec)nfsd4_decode_rename,
-	[OP_RENEW]		= (nfsd4_dec)nfsd4_decode_renew,
-	[OP_RESTOREFH]		= (nfsd4_dec)nfsd4_decode_noop,
-	[OP_SAVEFH]		= (nfsd4_dec)nfsd4_decode_noop,
-	[OP_SECINFO]		= (nfsd4_dec)nfsd4_decode_secinfo,
-	[OP_SETATTR]		= (nfsd4_dec)nfsd4_decode_setattr,
-	[OP_SETCLIENTID]	= (nfsd4_dec)nfsd4_decode_setclientid,
-	[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,
-	[OP_VERIFY]		= (nfsd4_dec)nfsd4_decode_verify,
-	[OP_WRITE]		= (nfsd4_dec)nfsd4_decode_write,
-	[OP_RELEASE_LOCKOWNER]	= (nfsd4_dec)nfsd4_decode_release_lockowner,
-
+	[OP_ACCESS]		= nfsd4_decode_access,
+	[OP_CLOSE]		= nfsd4_decode_close,
+	[OP_COMMIT]		= nfsd4_decode_commit,
+	[OP_CREATE]		= nfsd4_decode_create,
+	[OP_DELEGPURGE]		= nfsd4_decode_notsupp,
+	[OP_DELEGRETURN]	= nfsd4_decode_delegreturn,
+	[OP_GETATTR]		= nfsd4_decode_getattr,
+	[OP_GETFH]		= nfsd4_decode_noop,
+	[OP_LINK]		= nfsd4_decode_link,
+	[OP_LOCK]		= nfsd4_decode_lock,
+	[OP_LOCKT]		= nfsd4_decode_lockt,
+	[OP_LOCKU]		= nfsd4_decode_locku,
+	[OP_LOOKUP]		= nfsd4_decode_lookup,
+	[OP_LOOKUPP]		= nfsd4_decode_noop,
+	[OP_NVERIFY]		= nfsd4_decode_verify,
+	[OP_OPEN]		= nfsd4_decode_open,
+	[OP_OPENATTR]		= nfsd4_decode_notsupp,
+	[OP_OPEN_CONFIRM]	= nfsd4_decode_open_confirm,
+	[OP_OPEN_DOWNGRADE]	= nfsd4_decode_open_downgrade,
+	[OP_PUTFH]		= nfsd4_decode_putfh,
+	[OP_PUTPUBFH]		= nfsd4_decode_putpubfh,
+	[OP_PUTROOTFH]		= nfsd4_decode_noop,
+	[OP_READ]		= nfsd4_decode_read,
+	[OP_READDIR]		= nfsd4_decode_readdir,
+	[OP_READLINK]		= nfsd4_decode_noop,
+	[OP_REMOVE]		= nfsd4_decode_remove,
+	[OP_RENAME]		= nfsd4_decode_rename,
+	[OP_RENEW]		= nfsd4_decode_renew,
+	[OP_RESTOREFH]		= nfsd4_decode_noop,
+	[OP_SAVEFH]		= nfsd4_decode_noop,
+	[OP_SECINFO]		= nfsd4_decode_secinfo,
+	[OP_SETATTR]		= nfsd4_decode_setattr,
+	[OP_SETCLIENTID]	= nfsd4_decode_setclientid,
+	[OP_SETCLIENTID_CONFIRM] = nfsd4_decode_setclientid_confirm,
+	[OP_VERIFY]		= nfsd4_decode_verify,
+	[OP_WRITE]		= nfsd4_decode_write,
+	[OP_RELEASE_LOCKOWNER]  = nfsd4_decode_release_lockowner,
 	/* new operations for NFSv4.1 */
-	[OP_BACKCHANNEL_CTL]	= (nfsd4_dec)nfsd4_decode_backchannel_ctl,
-	[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,
-	[OP_EXCHANGE_ID]	= (nfsd4_dec)nfsd4_decode_exchange_id,
-	[OP_CREATE_SESSION]	= (nfsd4_dec)nfsd4_decode_create_session,
-	[OP_DESTROY_SESSION]	= (nfsd4_dec)nfsd4_decode_destroy_session,
-	[OP_FREE_STATEID]	= (nfsd4_dec)nfsd4_decode_free_stateid,
-	[OP_GET_DIR_DELEGATION]	= (nfsd4_dec)nfsd4_decode_notsupp,
+	[OP_BACKCHANNEL_CTL]	= nfsd4_decode_backchannel_ctl,
+	[OP_BIND_CONN_TO_SESSION]= nfsd4_decode_bind_conn_to_session,
+	[OP_EXCHANGE_ID]	= nfsd4_decode_exchange_id,
+	[OP_CREATE_SESSION]	= nfsd4_decode_create_session,
+	[OP_DESTROY_SESSION]	= nfsd4_decode_destroy_session,
+	[OP_FREE_STATEID]	= nfsd4_decode_free_stateid,
+	[OP_GET_DIR_DELEGATION]	= nfsd4_decode_notsupp,
 #ifdef CONFIG_NFSD_PNFS
-	[OP_GETDEVICEINFO]	= (nfsd4_dec)nfsd4_decode_getdeviceinfo,
-	[OP_GETDEVICELIST]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_LAYOUTCOMMIT]	= (nfsd4_dec)nfsd4_decode_layoutcommit,
-	[OP_LAYOUTGET]		= (nfsd4_dec)nfsd4_decode_layoutget,
-	[OP_LAYOUTRETURN]	= (nfsd4_dec)nfsd4_decode_layoutreturn,
+	[OP_GETDEVICEINFO]	= nfsd4_decode_getdeviceinfo,
+	[OP_GETDEVICELIST]	= nfsd4_decode_notsupp,
+	[OP_LAYOUTCOMMIT]	= nfsd4_decode_layoutcommit,
+	[OP_LAYOUTGET]		= nfsd4_decode_layoutget,
+	[OP_LAYOUTRETURN]	= nfsd4_decode_layoutreturn,
 #else
-	[OP_GETDEVICEINFO]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_GETDEVICELIST]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_LAYOUTCOMMIT]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_LAYOUTGET]		= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_LAYOUTRETURN]	= (nfsd4_dec)nfsd4_decode_notsupp,
+	[OP_GETDEVICEINFO]	= nfsd4_decode_notsupp,
+	[OP_GETDEVICELIST]	= nfsd4_decode_notsupp,
+	[OP_LAYOUTCOMMIT]	= nfsd4_decode_notsupp,
+	[OP_LAYOUTGET]		= nfsd4_decode_notsupp,
+	[OP_LAYOUTRETURN]	= nfsd4_decode_notsupp,
 #endif
-	[OP_SECINFO_NO_NAME]	= (nfsd4_dec)nfsd4_decode_secinfo_no_name,
-	[OP_SEQUENCE]		= (nfsd4_dec)nfsd4_decode_sequence,
-	[OP_SET_SSV]		= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_TEST_STATEID]	= (nfsd4_dec)nfsd4_decode_test_stateid,
-	[OP_WANT_DELEGATION]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_DESTROY_CLIENTID]	= (nfsd4_dec)nfsd4_decode_destroy_clientid,
-	[OP_RECLAIM_COMPLETE]	= (nfsd4_dec)nfsd4_decode_reclaim_complete,
+	[OP_SECINFO_NO_NAME]	= nfsd4_decode_secinfo_no_name,
+	[OP_SEQUENCE]		= nfsd4_decode_sequence,
+	[OP_SET_SSV]		= nfsd4_decode_notsupp,
+	[OP_TEST_STATEID]	= nfsd4_decode_test_stateid,
+	[OP_WANT_DELEGATION]	= nfsd4_decode_notsupp,
+	[OP_DESTROY_CLIENTID]	= nfsd4_decode_destroy_clientid,
+	[OP_RECLAIM_COMPLETE]	= nfsd4_decode_reclaim_complete,
 
 	/* new operations for NFSv4.2 */
-	[OP_ALLOCATE]		= (nfsd4_dec)nfsd4_decode_fallocate,
-	[OP_COPY]		= (nfsd4_dec)nfsd4_decode_copy,
-	[OP_COPY_NOTIFY]	= (nfsd4_dec)nfsd4_decode_copy_notify,
-	[OP_DEALLOCATE]		= (nfsd4_dec)nfsd4_decode_fallocate,
-	[OP_IO_ADVISE]		= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_LAYOUTERROR]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_LAYOUTSTATS]	= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_OFFLOAD_CANCEL]	= (nfsd4_dec)nfsd4_decode_offload_status,
-	[OP_OFFLOAD_STATUS]	= (nfsd4_dec)nfsd4_decode_offload_status,
-	[OP_READ_PLUS]		= (nfsd4_dec)nfsd4_decode_read,
-	[OP_SEEK]		= (nfsd4_dec)nfsd4_decode_seek,
-	[OP_WRITE_SAME]		= (nfsd4_dec)nfsd4_decode_notsupp,
-	[OP_CLONE]		= (nfsd4_dec)nfsd4_decode_clone,
+	[OP_ALLOCATE]		= nfsd4_decode_fallocate,
+	[OP_COPY]		= nfsd4_decode_copy,
+	[OP_COPY_NOTIFY]	= nfsd4_decode_copy_notify,
+	[OP_DEALLOCATE]		= nfsd4_decode_fallocate,
+	[OP_IO_ADVISE]		= nfsd4_decode_notsupp,
+	[OP_LAYOUTERROR]	= nfsd4_decode_notsupp,
+	[OP_LAYOUTSTATS]	= nfsd4_decode_notsupp,
+	[OP_OFFLOAD_CANCEL]	= nfsd4_decode_offload_status,
+	[OP_OFFLOAD_STATUS]	= nfsd4_decode_offload_status,
+	[OP_READ_PLUS]		= nfsd4_decode_read,
+	[OP_SEEK]		= nfsd4_decode_seek,
+	[OP_WRITE_SAME]		= nfsd4_decode_notsupp,
+	[OP_CLONE]		= nfsd4_decode_clone,
 	/* RFC 8276 extended atributes operations */
-	[OP_GETXATTR]		= (nfsd4_dec)nfsd4_decode_getxattr,
-	[OP_SETXATTR]		= (nfsd4_dec)nfsd4_decode_setxattr,
-	[OP_LISTXATTRS]		= (nfsd4_dec)nfsd4_decode_listxattrs,
-	[OP_REMOVEXATTR]	= (nfsd4_dec)nfsd4_decode_removexattr,
+	[OP_GETXATTR]		= nfsd4_decode_getxattr,
+	[OP_SETXATTR]		= nfsd4_decode_setxattr,
+	[OP_LISTXATTRS]		= nfsd4_decode_listxattrs,
+	[OP_REMOVEXATTR]	= nfsd4_decode_removexattr,
 };
 
 static inline bool
@@ -3643,8 +3712,9 @@ nfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)
 }
 
 static __be32
-nfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_access *access)
+nfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, void *_access)
 {
+	struct nfsd4_access *access = _access;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -3656,8 +3726,9 @@ nfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_
 	return 0;
 }
 
-static __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_bind_conn_to_session *bcts)
+static __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr, void *_bcts)
 {
+	struct nfsd4_bind_conn_to_session *bcts = _bcts;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -3673,8 +3744,9 @@ static __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp,
 }
 
 static __be32
-nfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_close *close)
+nfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, void *_close)
 {
+	struct nfsd4_close *close = _close;
 	struct xdr_stream *xdr = resp->xdr;
 
 	return nfsd4_encode_stateid(xdr, &close->cl_stateid);
@@ -3682,8 +3754,9 @@ nfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_c
 
 
 static __be32
-nfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_commit *commit)
+nfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, void *_commit)
 {
+	struct nfsd4_commit *commit = _commit;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -3696,8 +3769,9 @@ nfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_
 }
 
 static __be32
-nfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_create *create)
+nfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, void *_create)
 {
+	struct nfsd4_create *create = _create;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -3710,8 +3784,9 @@ nfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_
 }
 
 static __be32
-nfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getattr *getattr)
+nfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, void *_getattr)
 {
+	struct nfsd4_getattr *getattr = _getattr;
 	struct svc_fh *fhp = getattr->ga_fhp;
 	struct xdr_stream *xdr = resp->xdr;
 
@@ -3720,8 +3795,9 @@ nfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4
 }
 
 static __be32
-nfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh **fhpp)
+nfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, void *_fhpp)
 {
+	struct svc_fh **fhpp = (struct svc_fh **)_fhpp;
 	struct xdr_stream *xdr = resp->xdr;
 	struct svc_fh *fhp = *fhpp;
 	unsigned int len;
@@ -3775,8 +3851,9 @@ nfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)
 }
 
 static __be32
-nfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)
+nfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, void *_lock)
 {
+	struct nfsd4_lock *lock = _lock;
 	struct xdr_stream *xdr = resp->xdr;
 
 	if (!nfserr)
@@ -3788,8 +3865,9 @@ nfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lo
 }
 
 static __be32
-nfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lockt *lockt)
+nfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, void *_lockt)
 {
+	struct nfsd4_lockt *lockt = _lockt;
 	struct xdr_stream *xdr = resp->xdr;
 
 	if (nfserr == nfserr_denied)
@@ -3798,8 +3876,9 @@ nfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_l
 }
 
 static __be32
-nfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_locku *locku)
+nfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, void *_locku)
 {
+	struct nfsd4_locku *locku = _locku;
 	struct xdr_stream *xdr = resp->xdr;
 
 	return nfsd4_encode_stateid(xdr, &locku->lu_stateid);
@@ -3807,8 +3886,9 @@ nfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_l
 
 
 static __be32
-nfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_link *link)
+nfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, void *_link)
 {
+	struct nfsd4_link *link = _link;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -3821,8 +3901,9 @@ nfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_li
 
 
 static __be32
-nfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open *open)
+nfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, void *_open)
 {
+	struct nfsd4_open *open = _open;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -3915,16 +3996,20 @@ nfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_op
 }
 
 static __be32
-nfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_confirm *oc)
+nfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr, void *_oc)
 {
+	struct nfsd4_open_confirm *oc = _oc;
+
 	struct xdr_stream *xdr = resp->xdr;
 
 	return nfsd4_encode_stateid(xdr, &oc->oc_resp_stateid);
 }
 
 static __be32
-nfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_downgrade *od)
+nfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr, void *_od)
 {
+	struct nfsd4_open_downgrade *od = _od;
+
 	struct xdr_stream *xdr = resp->xdr;
 
 	return nfsd4_encode_stateid(xdr, &od->od_stateid);
@@ -4023,8 +4108,9 @@ static __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,
 
 static __be32
 nfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,
-		  struct nfsd4_read *read)
+		  void *_read)
 {
+	struct nfsd4_read *read = _read;
 	bool splice_ok = test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags);
 	unsigned long maxcount;
 	struct xdr_stream *xdr = resp->xdr;
@@ -4065,8 +4151,9 @@ nfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,
 }
 
 static __be32
-nfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readlink *readlink)
+nfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, void *_readlink)
 {
+	struct nfsd4_readlink *readlink = _readlink;
 	__be32 *p, *maxcount_p, zero = xdr_zero;
 	struct xdr_stream *xdr = resp->xdr;
 	int length_offset = xdr->buf->len;
@@ -4110,8 +4197,9 @@ nfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd
 }
 
 static __be32
-nfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readdir *readdir)
+nfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, void *_readdir)
 {
+	struct nfsd4_readdir *readdir = _readdir;
 	int maxcount;
 	int bytes_left;
 	loff_t offset;
@@ -4201,8 +4289,9 @@ nfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4
 }
 
 static __be32
-nfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_remove *remove)
+nfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, void *_remove)
 {
+	struct nfsd4_remove *remove = _remove;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4214,8 +4303,9 @@ nfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_
 }
 
 static __be32
-nfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_rename *rename)
+nfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, void *_rename)
 {
+	struct nfsd4_rename *rename = _rename;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4228,8 +4318,9 @@ nfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_
 }
 
 static __be32
-nfsd4_do_encode_secinfo(struct xdr_stream *xdr, struct svc_export *exp)
+nfsd4_do_encode_secinfo(struct xdr_stream *xdr, void *_exp)
 {
+	struct svc_export *exp = _exp;
 	u32 i, nflavs, supported;
 	struct exp_flavor_info *flavs;
 	struct exp_flavor_info def_flavs[2];
@@ -4297,8 +4388,9 @@ nfsd4_do_encode_secinfo(struct xdr_stream *xdr, struct svc_export *exp)
 
 static __be32
 nfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,
-		     struct nfsd4_secinfo *secinfo)
+		     void *_secinfo)
 {
+	struct nfsd4_secinfo *secinfo = _secinfo;
 	struct xdr_stream *xdr = resp->xdr;
 
 	return nfsd4_do_encode_secinfo(xdr, secinfo->si_exp);
@@ -4306,8 +4398,9 @@ nfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,
-		     struct nfsd4_secinfo_no_name *secinfo)
+		     void *_secinfo)
 {
+	struct nfsd4_secinfo_no_name *secinfo = _secinfo;
 	struct xdr_stream *xdr = resp->xdr;
 
 	return nfsd4_do_encode_secinfo(xdr, secinfo->sin_exp);
@@ -4318,8 +4411,9 @@ nfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,
  * regardless of the error status.
  */
 static __be32
-nfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setattr *setattr)
+nfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, void *_setattr)
 {
+	struct nfsd4_setattr *setattr = _setattr;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4342,8 +4436,9 @@ nfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4
 }
 
 static __be32
-nfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setclientid *scd)
+nfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, void *_scd)
 {
+	struct nfsd4_setclientid *scd = _scd;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4366,8 +4461,9 @@ nfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct n
 }
 
 static __be32
-nfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_write *write)
+nfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, void *_write)
 {
+	struct nfsd4_write *write = _write;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4383,8 +4479,9 @@ nfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_w
 
 static __be32
 nfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,
-			 struct nfsd4_exchange_id *exid)
+			 void *_exid)
 {
+	struct nfsd4_exchange_id *exid = _exid;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 	char *major_id;
@@ -4461,8 +4558,9 @@ nfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,
-			    struct nfsd4_create_session *sess)
+			    void *_sess)
 {
+	struct nfsd4_create_session *sess = _sess;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4514,8 +4612,9 @@ nfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,
-		      struct nfsd4_sequence *seq)
+		      void *_seq)
 {
+	struct nfsd4_sequence *seq = _seq;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4537,8 +4636,9 @@ nfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,
-			  struct nfsd4_test_stateid *test_stateid)
+			  void *_test_stateid)
 {
+	struct nfsd4_test_stateid *test_stateid = _test_stateid;
 	struct xdr_stream *xdr = resp->xdr;
 	struct nfsd4_test_stateid_id *stateid, *next;
 	__be32 *p;
@@ -4558,8 +4658,9 @@ nfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,
 #ifdef CONFIG_NFSD_PNFS
 static __be32
 nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,
-		struct nfsd4_getdeviceinfo *gdev)
+		void *_gdev)
 {
+	struct nfsd4_getdeviceinfo *gdev = _gdev;
 	struct xdr_stream *xdr = resp->xdr;
 	const struct nfsd4_layout_ops *ops;
 	u32 starting_len = xdr->buf->len, needed_len;
@@ -4611,8 +4712,9 @@ nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,
-		struct nfsd4_layoutget *lgp)
+		void *_lgp)
 {
+	struct nfsd4_layoutget *lgp = _lgp;
 	struct xdr_stream *xdr = resp->xdr;
 	const struct nfsd4_layout_ops *ops;
 	__be32 *p;
@@ -4638,8 +4740,9 @@ nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,
-			  struct nfsd4_layoutcommit *lcp)
+			  void *_lcp)
 {
+	struct nfsd4_layoutcommit *lcp = _lcp;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4659,8 +4762,9 @@ nfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_layoutreturn(struct nfsd4_compoundres *resp, __be32 nfserr,
-		struct nfsd4_layoutreturn *lrp)
+		void *_lrp)
 {
+	struct nfsd4_layoutreturn *lrp = _lrp;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4744,9 +4848,9 @@ nfsd42_encode_nl4_server(struct nfsd4_compoundres *resp, struct nl4_server *ns)
 }
 
 static __be32
-nfsd4_encode_copy(struct nfsd4_compoundres *resp, __be32 nfserr,
-		  struct nfsd4_copy *copy)
+nfsd4_encode_copy(struct nfsd4_compoundres *resp, __be32 nfserr, void *_copy)
 {
+	struct nfsd4_copy *copy = _copy;
 	__be32 *p;
 
 	nfserr = nfsd42_encode_write_res(resp, &copy->cp_res,
@@ -4762,8 +4866,9 @@ nfsd4_encode_copy(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_offload_status(struct nfsd4_compoundres *resp, __be32 nfserr,
-			    struct nfsd4_offload_status *os)
+			    void *_os)
 {
+	struct nfsd4_offload_status *os = _os;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4855,8 +4960,9 @@ nfsd4_encode_read_plus_hole(struct nfsd4_compoundres *resp,
 
 static __be32
 nfsd4_encode_read_plus(struct nfsd4_compoundres *resp, __be32 nfserr,
-		       struct nfsd4_read *read)
+		       void *_read)
 {
+	struct nfsd4_read *read = _read;
 	unsigned long maxcount, count;
 	struct xdr_stream *xdr = resp->xdr;
 	struct file *file;
@@ -4925,8 +5031,9 @@ nfsd4_encode_read_plus(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_copy_notify(struct nfsd4_compoundres *resp, __be32 nfserr,
-			 struct nfsd4_copy_notify *cn)
+			 void *_cn)
 {
+	struct nfsd4_copy_notify *cn = _cn;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -4960,8 +5067,9 @@ nfsd4_encode_copy_notify(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_seek(struct nfsd4_compoundres *resp, __be32 nfserr,
-		  struct nfsd4_seek *seek)
+		  void *_seek)
 {
+	struct nfsd4_seek *seek= (struct nfsd4_seek *)_seek;
 	__be32 *p;
 
 	p = xdr_reserve_space(resp->xdr, 4 + 8);
@@ -5023,8 +5131,9 @@ nfsd4_vbuf_to_stream(struct xdr_stream *xdr, char *buf, u32 buflen)
 
 static __be32
 nfsd4_encode_getxattr(struct nfsd4_compoundres *resp, __be32 nfserr,
-		      struct nfsd4_getxattr *getxattr)
+		      void *_getxattr)
 {
+	struct nfsd4_getxattr *getxattr = _getxattr;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p, err;
 
@@ -5047,8 +5156,9 @@ nfsd4_encode_getxattr(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_setxattr(struct nfsd4_compoundres *resp, __be32 nfserr,
-		      struct nfsd4_setxattr *setxattr)
+		      void *_setxattr)
 {
+	struct nfsd4_setxattr *setxattr = _setxattr;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -5088,8 +5198,9 @@ nfsd4_listxattr_validate_cookie(struct nfsd4_listxattrs *listxattrs,
 
 static __be32
 nfsd4_encode_listxattrs(struct nfsd4_compoundres *resp, __be32 nfserr,
-			struct nfsd4_listxattrs *listxattrs)
+			void *_listxattrs)
 {
+	struct nfsd4_listxattrs *listxattrs = _listxattrs;
 	struct xdr_stream *xdr = resp->xdr;
 	u32 cookie_offset, count_offset, eof;
 	u32 left, xdrleft, slen, count;
@@ -5199,8 +5310,9 @@ nfsd4_encode_listxattrs(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 static __be32
 nfsd4_encode_removexattr(struct nfsd4_compoundres *resp, __be32 nfserr,
-			 struct nfsd4_removexattr *removexattr)
+			 void *_removexattr)
 {
+	struct nfsd4_removexattr *removexattr = _removexattr;
 	struct xdr_stream *xdr = resp->xdr;
 	__be32 *p;
 
@@ -5220,93 +5332,93 @@ typedef __be32(* nfsd4_enc)(struct nfsd4_compoundres *, __be32, void *);
  * done in the decoding phase.
  */
 static const nfsd4_enc nfsd4_enc_ops[] = {
-	[OP_ACCESS]		= (nfsd4_enc)nfsd4_encode_access,
-	[OP_CLOSE]		= (nfsd4_enc)nfsd4_encode_close,
-	[OP_COMMIT]		= (nfsd4_enc)nfsd4_encode_commit,
-	[OP_CREATE]		= (nfsd4_enc)nfsd4_encode_create,
-	[OP_DELEGPURGE]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_DELEGRETURN]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_GETATTR]		= (nfsd4_enc)nfsd4_encode_getattr,
-	[OP_GETFH]		= (nfsd4_enc)nfsd4_encode_getfh,
-	[OP_LINK]		= (nfsd4_enc)nfsd4_encode_link,
-	[OP_LOCK]		= (nfsd4_enc)nfsd4_encode_lock,
-	[OP_LOCKT]		= (nfsd4_enc)nfsd4_encode_lockt,
-	[OP_LOCKU]		= (nfsd4_enc)nfsd4_encode_locku,
-	[OP_LOOKUP]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_LOOKUPP]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_NVERIFY]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_OPEN]		= (nfsd4_enc)nfsd4_encode_open,
-	[OP_OPENATTR]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_OPEN_CONFIRM]	= (nfsd4_enc)nfsd4_encode_open_confirm,
-	[OP_OPEN_DOWNGRADE]	= (nfsd4_enc)nfsd4_encode_open_downgrade,
-	[OP_PUTFH]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_PUTPUBFH]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_PUTROOTFH]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_READ]		= (nfsd4_enc)nfsd4_encode_read,
-	[OP_READDIR]		= (nfsd4_enc)nfsd4_encode_readdir,
-	[OP_READLINK]		= (nfsd4_enc)nfsd4_encode_readlink,
-	[OP_REMOVE]		= (nfsd4_enc)nfsd4_encode_remove,
-	[OP_RENAME]		= (nfsd4_enc)nfsd4_encode_rename,
-	[OP_RENEW]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_RESTOREFH]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_SAVEFH]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_SECINFO]		= (nfsd4_enc)nfsd4_encode_secinfo,
-	[OP_SETATTR]		= (nfsd4_enc)nfsd4_encode_setattr,
-	[OP_SETCLIENTID]	= (nfsd4_enc)nfsd4_encode_setclientid,
-	[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,
-	[OP_VERIFY]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_WRITE]		= (nfsd4_enc)nfsd4_encode_write,
-	[OP_RELEASE_LOCKOWNER]	= (nfsd4_enc)nfsd4_encode_noop,
+	[OP_ACCESS]		= nfsd4_encode_access,
+	[OP_CLOSE]		= nfsd4_encode_close,
+	[OP_COMMIT]		= nfsd4_encode_commit,
+	[OP_CREATE]		= nfsd4_encode_create,
+	[OP_DELEGPURGE]		= nfsd4_encode_noop,
+	[OP_DELEGRETURN]	= nfsd4_encode_noop,
+	[OP_GETATTR]		= nfsd4_encode_getattr,
+	[OP_GETFH]		= nfsd4_encode_getfh,
+	[OP_LINK]		= nfsd4_encode_link,
+	[OP_LOCK]		= nfsd4_encode_lock,
+	[OP_LOCKT]		= nfsd4_encode_lockt,
+	[OP_LOCKU]		= nfsd4_encode_locku,
+	[OP_LOOKUP]		= nfsd4_encode_noop,
+	[OP_LOOKUPP]		= nfsd4_encode_noop,
+	[OP_NVERIFY]		= nfsd4_encode_noop,
+	[OP_OPEN]		= nfsd4_encode_open,
+	[OP_OPENATTR]		= nfsd4_encode_noop,
+	[OP_OPEN_CONFIRM]	= nfsd4_encode_open_confirm,
+	[OP_OPEN_DOWNGRADE]	= nfsd4_encode_open_downgrade,
+	[OP_PUTFH]		= nfsd4_encode_noop,
+	[OP_PUTPUBFH]		= nfsd4_encode_noop,
+	[OP_PUTROOTFH]		= nfsd4_encode_noop,
+	[OP_READ]		= nfsd4_encode_read,
+	[OP_READDIR]		= nfsd4_encode_readdir,
+	[OP_READLINK]		= nfsd4_encode_readlink,
+	[OP_REMOVE]		= nfsd4_encode_remove,
+	[OP_RENAME]		= nfsd4_encode_rename,
+	[OP_RENEW]		= nfsd4_encode_noop,
+	[OP_RESTOREFH]		= nfsd4_encode_noop,
+	[OP_SAVEFH]		= nfsd4_encode_noop,
+	[OP_SECINFO]		= nfsd4_encode_secinfo,
+	[OP_SETATTR]		= nfsd4_encode_setattr,
+	[OP_SETCLIENTID]	= nfsd4_encode_setclientid,
+	[OP_SETCLIENTID_CONFIRM] = nfsd4_encode_noop,
+	[OP_VERIFY]		= nfsd4_encode_noop,
+	[OP_WRITE]		= nfsd4_encode_write,
+	[OP_RELEASE_LOCKOWNER]	= nfsd4_encode_noop,
 
 	/* NFSv4.1 operations */
-	[OP_BACKCHANNEL_CTL]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,
-	[OP_EXCHANGE_ID]	= (nfsd4_enc)nfsd4_encode_exchange_id,
-	[OP_CREATE_SESSION]	= (nfsd4_enc)nfsd4_encode_create_session,
-	[OP_DESTROY_SESSION]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_FREE_STATEID]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_GET_DIR_DELEGATION]	= (nfsd4_enc)nfsd4_encode_noop,
+	[OP_BACKCHANNEL_CTL]	= nfsd4_encode_noop,
+	[OP_BIND_CONN_TO_SESSION] = nfsd4_encode_bind_conn_to_session,
+	[OP_EXCHANGE_ID]	= nfsd4_encode_exchange_id,
+	[OP_CREATE_SESSION]	= nfsd4_encode_create_session,
+	[OP_DESTROY_SESSION]	= nfsd4_encode_noop,
+	[OP_FREE_STATEID]	= nfsd4_encode_noop,
+	[OP_GET_DIR_DELEGATION]	= nfsd4_encode_noop,
 #ifdef CONFIG_NFSD_PNFS
-	[OP_GETDEVICEINFO]	= (nfsd4_enc)nfsd4_encode_getdeviceinfo,
-	[OP_GETDEVICELIST]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_LAYOUTCOMMIT]	= (nfsd4_enc)nfsd4_encode_layoutcommit,
-	[OP_LAYOUTGET]		= (nfsd4_enc)nfsd4_encode_layoutget,
-	[OP_LAYOUTRETURN]	= (nfsd4_enc)nfsd4_encode_layoutreturn,
+	[OP_GETDEVICEINFO]	= nfsd4_encode_getdeviceinfo,
+	[OP_GETDEVICELIST]	= nfsd4_encode_noop,
+	[OP_LAYOUTCOMMIT]	= nfsd4_encode_layoutcommit,
+	[OP_LAYOUTGET]		= nfsd4_encode_layoutget,
+	[OP_LAYOUTRETURN]	= nfsd4_encode_layoutreturn,
 #else
-	[OP_GETDEVICEINFO]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_GETDEVICELIST]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_LAYOUTCOMMIT]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_LAYOUTGET]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_LAYOUTRETURN]	= (nfsd4_enc)nfsd4_encode_noop,
+	[OP_GETDEVICEINFO]	= nfsd4_encode_noop,
+	[OP_GETDEVICELIST]	= nfsd4_encode_noop,
+	[OP_LAYOUTCOMMIT]	= nfsd4_encode_noop,
+	[OP_LAYOUTGET]		= nfsd4_encode_noop,
+	[OP_LAYOUTRETURN]	= nfsd4_encode_noop,
 #endif
-	[OP_SECINFO_NO_NAME]	= (nfsd4_enc)nfsd4_encode_secinfo_no_name,
-	[OP_SEQUENCE]		= (nfsd4_enc)nfsd4_encode_sequence,
-	[OP_SET_SSV]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_TEST_STATEID]	= (nfsd4_enc)nfsd4_encode_test_stateid,
-	[OP_WANT_DELEGATION]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_DESTROY_CLIENTID]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_RECLAIM_COMPLETE]	= (nfsd4_enc)nfsd4_encode_noop,
+	[OP_SECINFO_NO_NAME]	= nfsd4_encode_secinfo_no_name,
+	[OP_SEQUENCE]		= nfsd4_encode_sequence,
+	[OP_SET_SSV]		= nfsd4_encode_noop,
+	[OP_TEST_STATEID]	= nfsd4_encode_test_stateid,
+	[OP_WANT_DELEGATION]	= nfsd4_encode_noop,
+	[OP_DESTROY_CLIENTID]	= nfsd4_encode_noop,
+	[OP_RECLAIM_COMPLETE]	= nfsd4_encode_noop,
 
 	/* NFSv4.2 operations */
-	[OP_ALLOCATE]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_COPY]		= (nfsd4_enc)nfsd4_encode_copy,
-	[OP_COPY_NOTIFY]	= (nfsd4_enc)nfsd4_encode_copy_notify,
-	[OP_DEALLOCATE]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_IO_ADVISE]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_LAYOUTERROR]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_LAYOUTSTATS]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_OFFLOAD_CANCEL]	= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_OFFLOAD_STATUS]	= (nfsd4_enc)nfsd4_encode_offload_status,
-	[OP_READ_PLUS]		= (nfsd4_enc)nfsd4_encode_read_plus,
-	[OP_SEEK]		= (nfsd4_enc)nfsd4_encode_seek,
-	[OP_WRITE_SAME]		= (nfsd4_enc)nfsd4_encode_noop,
-	[OP_CLONE]		= (nfsd4_enc)nfsd4_encode_noop,
+	[OP_ALLOCATE]		= nfsd4_encode_noop,
+	[OP_COPY]		= nfsd4_encode_copy,
+	[OP_COPY_NOTIFY]	= nfsd4_encode_copy_notify,
+	[OP_DEALLOCATE]		= nfsd4_encode_noop,
+	[OP_IO_ADVISE]		= nfsd4_encode_noop,
+	[OP_LAYOUTERROR]	= nfsd4_encode_noop,
+	[OP_LAYOUTSTATS]	= nfsd4_encode_noop,
+	[OP_OFFLOAD_CANCEL]	= nfsd4_encode_noop,
+	[OP_OFFLOAD_STATUS]	= nfsd4_encode_offload_status,
+	[OP_READ_PLUS]		= nfsd4_encode_read_plus,
+	[OP_SEEK]		= nfsd4_encode_seek,
+	[OP_WRITE_SAME]		= nfsd4_encode_noop,
+	[OP_CLONE]		= nfsd4_encode_noop,
 
 	/* RFC 8276 extended atributes operations */
-	[OP_GETXATTR]		= (nfsd4_enc)nfsd4_encode_getxattr,
-	[OP_SETXATTR]		= (nfsd4_enc)nfsd4_encode_setxattr,
-	[OP_LISTXATTRS]		= (nfsd4_enc)nfsd4_encode_listxattrs,
-	[OP_REMOVEXATTR]	= (nfsd4_enc)nfsd4_encode_removexattr,
+	[OP_GETXATTR]		= nfsd4_encode_getxattr,
+	[OP_SETXATTR]		= nfsd4_encode_setxattr,
+	[OP_LISTXATTRS]		= nfsd4_encode_listxattrs,
+	[OP_REMOVEXATTR]	= nfsd4_encode_removexattr,
 };
 
 /*
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index eb0466236..cf9cc73d0 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -319,6 +319,10 @@ struct ftrace_likely_data {
 			 __scalar_type_to_expr_cases(long long),	\
 			 default: (x)))
 
+#define __type_is_unsigned(t) \
+	(__same_type((t)0, 0UL) || __same_type((t)0, 0U) || \
+	__same_type((t)0, (unsigned short)0) || __same_type((t)0, (unsigned char)0))
+
 /* Is this type a native word size -- useful for atomic operations */
 #define __native_word(t) \
 	(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \
diff --git a/include/linux/moduleparam.h b/include/linux/moduleparam.h
index 962cd41a2..b50341126 100644
--- a/include/linux/moduleparam.h
+++ b/include/linux/moduleparam.h
@@ -354,7 +354,7 @@ static inline void kernel_param_unlock(struct module *mod)
  * @len is usually just sizeof(string).
  */
 #define module_param_string(name, string, len, perm)			\
-	static const struct kparam_string __param_string_##name		\
+	static const struct kparam_string __param_string_##name __used	\
 		= { len, string };					\
 	__module_param_call(MODULE_PARAM_PREFIX, name,			\
 			    &param_ops_string,				\
@@ -513,7 +513,7 @@ extern int param_set_bint(const char *val, const struct kernel_param *kp);
  */
 #define module_param_array_named(name, array, type, nump, perm)		\
 	param_check_##type(name, &(array)[0]);				\
-	static const struct kparam_array __param_arr_##name		\
+	static const struct kparam_array __param_arr_##name __used	\
 	= { .max = ARRAY_SIZE(array), .num = nump,                      \
 	    .ops = &param_ops_##type,					\
 	    .elemsize = sizeof(array[0]), .elem = array };		\
diff --git a/include/linux/pci.h b/include/linux/pci.h
index eccaf1abe..1a8b4d7b7 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -194,7 +194,7 @@ static inline const char *pci_power_name(pci_power_t state)
  */
 typedef unsigned int __bitwise pci_channel_state_t;
 
-enum {
+enum pci_channel_state {
 	/* I/O channel is in normal state */
 	pci_channel_io_normal = (__force pci_channel_state_t) 1,
 
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index a34b0f9a9..6f9d5599d 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -121,7 +121,14 @@ enum landlock_rule_type;
 #define __TYPE_IS_L(t)	(__TYPE_AS(t, 0L))
 #define __TYPE_IS_UL(t)	(__TYPE_AS(t, 0UL))
 #define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))
-#define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a
+#define __SC_TYPE(t) __typeof__(                               \
+       __builtin_choose_expr(                                  \
+               sizeof(t) > sizeof(int),                        \
+               (t) 0,                                          \
+               __builtin_choose_expr(__type_is_unsigned(t), 0UL, 0L)   \
+       ))
+#define __SC_LONG(t, a)        __SC_TYPE(t) a
+#define __SC_WRAP(t, a)        (__SC_TYPE(t)) a
 #define __SC_CAST(t, a)	(__force t) a
 #define __SC_ARGS(t, a)	a
 #define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) && sizeof(t) > sizeof(long))
@@ -239,18 +246,19 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
 	__diag_push();							\
 	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
 		      "Type aliasing is used to sanitize syscall arguments");\
-	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\
-		__attribute__((alias(__stringify(__se_sys##name))));	\
 	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));	\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\
+	static inline asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))    \
 	{								\
 		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\
 		__MAP(x,__SC_TEST,__VA_ARGS__);				\
 		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\
 		return ret;						\
 	}								\
+	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \
+	{                                                               \
+		return __se_sys##name(__MAP(x,__SC_WRAP,__VA_ARGS__));  \
+	}                                                               \
 	__diag_pop();							\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
 #endif /* __SYSCALL_DEFINEx */
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 647067236..9f98c3994 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -1049,6 +1049,10 @@ void bpf_jit_binary_free(struct bpf_binary_header *hdr)
 	bpf_jit_uncharge_modmem(size);
 }
 
+#ifdef CONFIG_PAX_RAP
+extern long __rap_hash___bpf_prog_run;
+#endif
+
 /* Allocate jit binary from bpf_prog_pack allocator.
  * Since the allocated memory is RO+X, the JIT engine cannot write directly
  * to the memory. To solve this problem, a RW buffer is also allocated at
@@ -1095,11 +1099,24 @@ bpf_jit_binary_pack_alloc(unsigned int proglen, u8 **image_ptr,
 
 	hole = min_t(unsigned int, size - (proglen + sizeof(*ro_header)),
 		     BPF_PROG_CHUNK_SIZE - sizeof(*ro_header));
+#ifdef CONFIG_PAX_RAP
+	hole -= 6;
+#endif
 	start = prandom_u32_max(hole) & ~(alignment - 1);
+#ifdef CONFIG_PAX_RAP
+	start += 6;
+#endif
 
 	*image_ptr = &ro_header->image[start];
 	*rw_image = &(*rw_header)->image[start];
 
+#ifdef CONFIG_PAX_RAP
+#ifdef CONFIG_RELOCATABLE
+	*(int *)(*rw_image - 6) = 0x456bce13;
+#else
+	*(int *)(*rw_image - 6) = (int)&__rap_hash___bpf_prog_run;
+#endif
+#endif
 	return ro_header;
 }
 
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 8f2b9d8b9..df64a06ee 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -1112,8 +1112,9 @@ static void __perf_mux_hrtimer_init(struct perf_cpu_context *cpuctx, int cpu)
 	timer->function = perf_mux_hrtimer_handler;
 }
 
-static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)
+static int perf_mux_hrtimer_restart(void *_cpuctx)
 {
+	struct perf_cpu_context *cpuctx = _cpuctx;
 	struct hrtimer *timer = &cpuctx->hrtimer;
 	struct pmu *pmu = cpuctx->ctx.pmu;
 	unsigned long flags;
diff --git a/kernel/module/main.c b/kernel/module/main.c
index 7a376e26d..d4e152c71 100644
--- a/kernel/module/main.c
+++ b/kernel/module/main.c
@@ -1959,8 +1959,15 @@ static int setup_load_info(struct load_info *info, int flags)
 static int check_modinfo(struct module *mod, struct load_info *info, int flags)
 {
 	const char *modmagic = get_modinfo(info, "vermagic");
+	const char *license = get_modinfo(info, "license");
 	int err;
 
+#if defined(CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_OR) || defined(CONFIG_PAX_RAP)
+	if (!license || !license_is_gpl_compatible(license)) {
+		pr_err("%s: module is not compatible with the KERNEXEC 'or' method and RAP\n", mod->name);
+		return -ENOEXEC;
+	}
+#endif
 	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
 		modmagic = NULL;
 
@@ -1995,7 +2002,7 @@ static int check_modinfo(struct module *mod, struct load_info *info, int flags)
 		return err;
 
 	/* Set up license info based on the info section */
-	set_license(mod, get_modinfo(info, "license"));
+	set_license(mod, license);
 
 	if (get_modinfo(info, "test")) {
 		if (!test_taint(TAINT_TEST))
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 55d13980e..fe421c269 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4881,7 +4881,7 @@ static void do_balance_callbacks(struct rq *rq, struct balance_callback *head)
 	lockdep_assert_rq_held(rq);
 
 	while (head) {
-		func = (void (*)(struct rq *))head->func;
+		func = head->func;
 		next = head->next;
 		head->next = NULL;
 		head = next;
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 06e5f6faa..a33f77509 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -868,7 +868,8 @@ void br_del_frame(struct net_bridge *br, struct br_frame_type *ft);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
 {
-	return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	//return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	return br_get_rx_handler(dev) == rcu_dereference(dev->rx_handler);
 }
 
 static inline bool br_rx_handler_check_rtnl(const struct net_device *dev)
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index 20eede37d..e5a5fc5cb 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -389,7 +389,6 @@ ip_set_comment_free(struct ip_set *set, void *ptr)
 	rcu_assign_pointer(comment->c, NULL);
 }
 
-typedef void (*destroyer)(struct ip_set *, void *);
 /* ipset data extension types, in size order */
 
 const struct ip_set_ext_type ip_set_extensions[] = {
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index e4deaf5fa..7acd78f9d 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -22,6 +22,14 @@ export DISABLE_STRUCTLEAK_PLUGIN
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)		\
 		+= -DSTRUCTLEAK_PLUGIN
 
+gcc-plugin-$(CONFIG_PAX_RAP)                           += rap_plugin.so
+gcc-plugin-cflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN -fplugin-arg-rap_plugin-check=call -fplugin-arg-rap_plugin-hash=abs-finish
+# gcc-plugin-cflags-$(CONFIG_PAX_RAP)                  += -fplugin-arg-rap_plugin-report=func,fptr,abs
+ifdef CONFIG_PAX_RAP
+  RAP_PLUGIN_ABS_CFLAGS                                := -fplugin-arg-rap_plugin-hash=abs-finish
+endif
+gcc-plugin-aflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STACKLEAK)	+= stackleak_plugin.so
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STACKLEAK)		\
 		+= -DSTACKLEAK_PLUGIN
@@ -47,8 +55,12 @@ export DISABLE_ARM_SSP_PER_TASK_PLUGIN
 GCC_PLUGINS_CFLAGS := $(strip $(addprefix -fplugin=$(objtree)/scripts/gcc-plugins/, $(gcc-plugin-y)) $(gcc-plugin-cflags-y))
 export GCC_PLUGINS_CFLAGS
 
+GCC_PLUGINS_AFLAGS := $(gcc-plugin-aflags-y)
+export RAP_PLUGIN_ABS_CFLAGS GCC_PLUGINS_AFLAGS
+
 # Add the flags to the build!
 KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
 
 # Some plugins are enabled outside of this Makefile, but they still need to
 # be included in GCC_PLUGIN so they can get built.
diff --git a/scripts/gcc-plugins/Makefile b/scripts/gcc-plugins/Makefile
index 320afd3cf..6246b5bdf 100644
--- a/scripts/gcc-plugins/Makefile
+++ b/scripts/gcc-plugins/Makefile
@@ -36,11 +36,13 @@ plugin_cxxflags	= -Wp,-MMD,$(depfile) $(KBUILD_HOSTCXXFLAGS) -fPIC \
 
 plugin_ldflags	= -shared
 
+rap_plugin-objs := $(patsubst $(srctree)/$(src)/rap_plugin/%.c,rap_plugin/%.o,$(wildcard $(srctree)/$(src)/rap_plugin/*.c))
+
 plugin-single	:= $(foreach m, $(GCC_PLUGIN), $(if $($(m:%.so=%-objs)),,$(m)))
 plugin-multi	:= $(filter-out $(plugin-single), $(GCC_PLUGIN))
 plugin-objs	:= $(sort $(foreach m, $(plugin-multi), $($(m:%.so=%-objs))))
-
 targets += $(plugin-single) $(plugin-multi) $(plugin-objs)
+
 clean-files += *.so
 
 plugin-single	:= $(addprefix $(obj)/, $(plugin-single))
diff --git a/scripts/gcc-plugins/rap_plugin/rap.h b/scripts/gcc-plugins/rap_plugin/rap.h
new file mode 100644
index 000000000..dbaafeed7
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap.h
@@ -0,0 +1,38 @@
+#ifndef RAP_H_INCLUDED
+#define RAP_H_INCLUDED
+
+#include "gcc-common.h"
+
+#define RAP_HASH_START_PADDING_SIZE  3
+#define RAP_HASH_END_PADDING_SIZE  2
+typedef struct {
+	int hash; // will be sign extended to long in reality
+} rap_hash_t;
+
+typedef struct {
+	unsigned int qual_const:1;
+	unsigned int qual_volatile:1;
+} rap_hash_flags_t;
+extern rap_hash_flags_t imprecise_rap_hash_flags;
+
+extern bool report_fptr_hash;
+
+extern GTY(()) tree rap_hash_type_node;
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+void rap_calculate_func_hashes(void *event_data, void *data);
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node);
+const_tree type_name(const_tree type);
+tree create_new_var(tree type, const char *name);
+
+gimple barrier(tree var, bool full);
+
+#if BUILDING_GCC_VERSION >= 4009
+opt_pass *make_rap_fptr_pass(void);
+#else
+struct opt_pass *make_rap_fptr_pass(void);
+#endif
+
+#endif
diff --git a/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
new file mode 100644
index 000000000..511076ab2
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+bool report_fptr_hash;
+
+static bool rap_fptr_gate(void)
+{
+#ifdef TARGET_64BIT
+	tree section;
+
+	if (!TARGET_64BIT || ix86_cmodel != CM_KERNEL)
+		return true;
+
+	section = lookup_attribute("section", DECL_ATTRIBUTES(current_function_decl));
+	if (!section || !TREE_VALUE(section))
+		return true;
+
+	section = TREE_VALUE(TREE_VALUE(section));
+	return strncmp(TREE_STRING_POINTER(section), ".vsyscall_", 10);
+#else
+#error unsupported target
+#endif
+}
+
+static tree build_rap_hash(gimple call_stmt, tree fntype)
+{
+	rap_hash_t hash;
+
+	hash = rap_hash_function_type(fntype, imprecise_rap_hash_flags);
+	if (report_fptr_hash)
+		inform(gimple_location(call_stmt), "fptr rap_hash: %x", hash.hash);
+	return build_int_cst_type(rap_hash_type_node, hash.hash);
+}
+
+// check the function hash of the target of the fptr
+static basic_block rap_instrument_fptr(gimple_stmt_iterator *gsi)
+{
+	gimple assign_hash, check_hash, call_stmt, stmt;
+	location_t loc;
+	tree computed_hash, target_hash, fptr, fntype;
+#if BUILDING_GCC_VERSION == 4005
+	tree fptr2;
+#endif
+	basic_block cond_bb, join_bb, true_bb;
+	edge e;
+	const HOST_WIDE_INT rap_hash_offset = sizeof(rap_hash_t) + 2;
+
+	call_stmt = gsi_stmt(*gsi);
+	loc = gimple_location(call_stmt);
+	fptr = gimple_call_fn(call_stmt);
+	fntype = TREE_TYPE(TREE_TYPE(fptr));
+
+	if (TREE_CODE(fntype) == FUNCTION_TYPE) {
+		computed_hash = build_rap_hash(call_stmt, fntype);
+	} else {
+		debug_tree(fntype);
+		gcc_unreachable();
+	}
+
+	// target_hash = ((s64*)fptr)[-rap_hash_offset]
+	target_hash = create_tmp_var(rap_hash_type_node, "rap_hash");
+	add_referenced_var(target_hash);
+	target_hash = make_ssa_name(target_hash, NULL);
+#if BUILDING_GCC_VERSION == 4005
+	fptr2 = create_tmp_var(ptr_type_node, "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, build2(POINTER_PLUS_EXPR, ptr_type_node, fptr, build_int_cst_type(sizetype, -rap_hash_offset)));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	fptr2 = create_tmp_var(build_pointer_type(rap_hash_type_node), "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, fold_convert(build_pointer_type(TREE_TYPE(target_hash)), fptr));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	assign_hash = gimple_build_assign(target_hash, build1(INDIRECT_REF, rap_hash_type_node, fptr));
+#else
+	assign_hash = gimple_build_assign(target_hash, build2(MEM_REF, integer_type_node, fptr, build_int_cst_type(build_pointer_type(rap_hash_type_node), -rap_hash_offset)));
+#endif
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(target_hash) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_NEW_STMT);
+	update_stmt(assign_hash);
+
+	// compare target_hash against computed function hash
+	// bail out on mismatch
+	check_hash = gimple_build_cond(NE_EXPR, target_hash, computed_hash, NULL_TREE, NULL_TREE);
+	gimple_set_location(check_hash, loc);
+	gsi_insert_after(gsi, check_hash, GSI_NEW_STMT);
+
+	cond_bb = gimple_bb(gsi_stmt(*gsi));
+	gcc_assert(!gsi_end_p(*gsi));
+	gcc_assert(check_hash == gsi_stmt(*gsi));
+
+	e = split_block(cond_bb, gsi_stmt(*gsi));
+	cond_bb = e->src;
+	join_bb = e->dest;
+	e->flags = EDGE_FALSE_VALUE;
+#if BUILDING_GCC_VERSION < 8000
+	e->probability = REG_BR_PROB_BASE;
+#else
+	e->probability = profile_probability::always ();
+#endif
+
+	true_bb = create_empty_bb(EXIT_BLOCK_PTR_FOR_FN(cfun)->prev_bb);
+	make_edge(cond_bb, true_bb, EDGE_TRUE_VALUE | EDGE_PRESERVE);
+
+	gcc_assert(dom_info_available_p(CDI_DOMINATORS));
+	set_immediate_dominator(CDI_DOMINATORS, true_bb, cond_bb);
+	set_immediate_dominator(CDI_DOMINATORS, join_bb, cond_bb);
+
+	gcc_assert(cond_bb->loop_father == join_bb->loop_father);
+	add_bb_to_loop(true_bb, cond_bb->loop_father);
+
+	*gsi = gsi_start_bb(true_bb);
+
+	// this fake dependency is to prevent PRE from merging this BB with others of the same kind
+	stmt = barrier(fptr, false);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	stmt = gimple_build_call(builtin_decl_implicit(BUILT_IN_TRAP), 0);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	return join_bb;
+}
+
+// find all language level function pointer dereferences and verify the target function
+static unsigned int rap_fptr_execute(void)
+{
+	basic_block bb;
+
+	loop_optimizer_init(LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);
+	gcc_assert(current_loops);
+
+	calculate_dominance_info(CDI_DOMINATORS);
+	calculate_dominance_info(CDI_POST_DOMINATORS);
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			// gimple match: h_1 = get_fptr (); D.2709_3 = h_1 (x_2(D));
+			tree fptr, fntype;
+			gimple call_stmt;
+
+			// is it a call ...
+			call_stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(call_stmt))
+				continue;
+
+			fptr = gimple_call_fn(call_stmt);
+			if (!fptr)
+				continue;
+
+			switch (TREE_CODE(fptr)) {
+			default:
+				debug_gimple_stmt(call_stmt);
+				debug_tree(fptr);
+				debug_tree(TREE_TYPE(fptr));
+				gcc_unreachable();
+
+			case ADDR_EXPR:
+				continue;
+
+			case SSA_NAME:
+				if (SSA_NAME_VAR(fptr) == NULL_TREE)
+					break;
+
+				switch (TREE_CODE(SSA_NAME_VAR(fptr))) {
+				default:
+					debug_gimple_stmt(call_stmt);
+					debug_tree(fptr);
+					gcc_unreachable();
+
+				case VAR_DECL:
+				case PARM_DECL:
+					break;
+				}
+				break;
+
+			case INTEGER_CST:
+			case OBJ_TYPE_REF:
+				break;
+			}
+
+			// ... through a function pointer
+			fntype = TREE_TYPE(fptr);
+			if (TREE_CODE(fntype) != POINTER_TYPE)
+				continue;
+
+			fntype = TREE_TYPE(fntype);
+			gcc_assert(TREE_CODE(fntype) == FUNCTION_TYPE || TREE_CODE(fntype) == METHOD_TYPE);
+
+			bb = rap_instrument_fptr(&gsi);
+			gsi = gsi_start_bb(bb);
+		}
+	}
+
+	free_dominance_info(CDI_DOMINATORS);
+	free_dominance_info(CDI_POST_DOMINATORS);
+	loop_optimizer_finalize();
+
+	return 0;
+}
+
+#define PASS_NAME rap_fptr
+#define TODO_FLAGS_FINISH TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa | TODO_cleanup_cfg | TODO_rebuild_cgraph_edges | TODO_verify_flow
+#include "gcc-generate-gimple-pass.h"
diff --git a/scripts/gcc-plugins/rap_plugin/rap_hash.c b/scripts/gcc-plugins/rap_plugin/rap_hash.c
new file mode 100644
index 000000000..420fcbdbf
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_hash.c
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+static rap_hash_t *rap_imprecise_hashes;
+static int rap_cgraph_max_uid;
+
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8]);
+
+static const unsigned char rap_hash_tree_code[MAX_TREE_CODES] = {
+	[0] = 0,
+	[1] = 0,
+	[2] = 0,
+	[3] = 0,
+	[4] = 0,
+	[OFFSET_TYPE] = 10,
+	[ENUMERAL_TYPE] = 20,
+	[BOOLEAN_TYPE] = 30,
+	[INTEGER_TYPE] = 40,
+	[REAL_TYPE] = 50,
+	[POINTER_TYPE] = 60,
+	[REFERENCE_TYPE] = 70,
+#if BUILDING_GCC_VERSION >= 4006
+	[NULLPTR_TYPE] = 80,
+#endif
+	[FIXED_POINT_TYPE] = 0,
+	[COMPLEX_TYPE] = 100,
+	[VECTOR_TYPE] = 110,
+	[ARRAY_TYPE] = 120,
+	[RECORD_TYPE] = 130,
+	[UNION_TYPE] = 140,
+	[QUAL_UNION_TYPE] = 0,
+	[VOID_TYPE] = 160,
+#if BUILDING_GCC_VERSION >= 5000 && BUILDING_GCC_VERSION < 9000
+	[POINTER_BOUNDS_TYPE] = 170,
+#endif
+	[FUNCTION_TYPE] = 180,
+	[METHOD_TYPE] = 0,
+	[LANG_TYPE] = 0,
+};
+
+static void rap_fold_hash(unsigned char *out, const unsigned char *in, unsigned long long inlen)
+{
+	static const unsigned char rap_sip_key[16] = {
+		'P', 'a', 'X', ' ', 'T', 'e', 'a', 'm',
+		'R', 'A', 'P', ' ', 'H', 'A', 'S', 'H',
+	};
+
+	siphash24fold(out, in, inlen, rap_sip_key);
+}
+
+// compute the final hash value in the range [1,INT_MAX]
+// the % and +1 trick leaves the value 0 available for marking non-indirectly callable functions
+// and INT_MIN (0x80000000) for longjmp targets (sign extended)
+// return places will use the (sign extended) range [INT_MIN+1,-1] ([0x8000001,0xffffffff])
+static rap_hash_t rap_extract_hash(const unsigned char sip_hash[8])
+{
+	rap_hash_t hash;
+	unsigned long long dividend, divisor;
+
+	memcpy(&dividend, sip_hash, sizeof dividend);
+//	divisor = 1ULL << (sizeof hash * 8 - 1);
+//	divisor |= divisor - 1;
+	divisor = 0x7fffffffUL;
+	hash.hash = dividend % divisor + 1;
+	return hash;
+}
+
+static void rap_hash_type_name(const_tree type, unsigned char sip_hash[8])
+{
+	const_tree name = type_name(TYPE_MAIN_VARIANT(type));
+
+	// handle typedefs of anonymous structs/unions
+	if (name == NULL_TREE)
+		name = type_name(type);
+
+	if (name == NULL_TREE)
+		return;
+
+	gcc_assert(TREE_CODE(name) == IDENTIFIER_NODE);
+	rap_fold_hash(sip_hash, (const unsigned char *)IDENTIFIER_POINTER(name), IDENTIFIER_LENGTH(name));
+}
+
+static void rap_hash_type_precision(const_tree type, unsigned char sip_hash[8])
+{
+	unsigned HOST_WIDE_INT size;
+
+	gcc_assert(TYPE_PRECISION(type));
+
+	size = TYPE_PRECISION(type);
+	rap_fold_hash(sip_hash, (const unsigned char *)&size, sizeof size);
+}
+
+const_tree type_name(const_tree type)
+{
+	const_tree name;
+
+	name = TYPE_NAME(type);
+	if (!name)
+		return NULL_TREE;
+
+	switch (TREE_CODE(name)) {
+	case IDENTIFIER_NODE:
+		return name;
+
+	case TYPE_DECL:
+		gcc_assert(DECL_NAME(name));
+		return DECL_NAME(name);
+
+	default:
+		gcc_unreachable();
+	}
+}
+
+__attribute__((weak)) tree c_global_trees[CTI_MAX];
+
+// the core computation of the rap hash
+// the first piece is a (hopefully) compiler independent encondig of the type, derived from the gcc tree code
+// the second piece is type specific information, such as the size, qualifiers, (recursively) referenced types, etc
+static void rap_hash_tree(const_tree type, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	enum tree_code code;
+	unsigned int attrs;
+
+	code = TREE_CODE(type);
+	attrs = rap_hash_tree_code[code];
+	if (!attrs) {
+		fprintf(stderr, "unhandled tree_code %s %d\n", get_tree_code_name(code), code);
+		debug_tree(type);
+		gcc_unreachable();
+	}
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+
+	enum {
+	// attrs layout for
+		// - all types:
+		RAP_HASH_VOLATILE		= 1U << 31,
+		RAP_HASH_NOT_VOLATILE		= 1U << 30,
+		RAP_HASH_CONST			= 1U << 29,
+		RAP_HASH_NOT_CONST		= 1U << 28,
+
+		// - pointer types:
+		RAP_HASH_RESTRICT		= 1U << 27,
+		RAP_HASH_NOT_RESTRICT		= 1U << 26,
+
+		// - C integer types:
+		RAP_HASH_UNSIGNED		= 1U << 25,
+		RAP_HASH_SIGNED			= 1U << 24,
+
+		RAP_HASH_UNQUALIFIED_CHAR	= 1U << 23,
+		RAP_HASH_CHAR			= 1U << 22,
+		RAP_HASH_SHORT			= 1U << 21,
+		RAP_HASH_INT			= 1U << 20,
+		RAP_HASH_LONG			= 1U << 19,
+		RAP_HASH_LONG_LONG		= 1U << 18,
+		RAP_HASH_WCHAR			= 1U << 17,
+		RAP_HASH_CHAR16			= 1U << 16,
+		RAP_HASH_CHAR32			= 1U << 15,
+
+		// - C float types
+		RAP_HASH_FLOAT			= 1U << 14,
+		RAP_HASH_DOUBLE			= 1U << 13,
+		RAP_HASH_LONG_DOUBLE		= 1U << 12,
+		RAP_HASH_DFLOAT32		= 1U << 11,
+		RAP_HASH_DFLOAT64		= 1U << 10,
+		RAP_HASH_DFLOAT128		= 1U << 9,
+	};
+
+	attrs = 0;
+	if (flags.qual_volatile)
+		attrs |= TYPE_VOLATILE(type) ? RAP_HASH_VOLATILE : RAP_HASH_NOT_VOLATILE;
+	if (flags.qual_const)
+		attrs |= TYPE_READONLY(type) ? RAP_HASH_CONST : RAP_HASH_NOT_CONST;
+
+	switch (code) {
+	default:
+		debug_tree(type);
+		gcc_unreachable();
+		break;
+
+	case VOID_TYPE:
+		break;
+
+	case OFFSET_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_tree(TYPE_OFFSET_BASETYPE(type), flags, sip_hash);
+		break;
+
+	case FUNCTION_TYPE:
+		rap_hash_function(type, flags, sip_hash);
+		break;
+
+	case RECORD_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case UNION_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case POINTER_TYPE:
+	case REFERENCE_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case VECTOR_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_type_precision(TREE_TYPE(type), sip_hash);
+		break;
+
+	case ARRAY_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case REAL_TYPE: {
+		const_tree main_variant = TYPE_MAIN_VARIANT(type);
+
+		switch (TYPE_PRECISION(main_variant)) {
+		default:
+			debug_tree(type);
+			debug_tree(TYPE_MAIN_VARIANT(type));
+			gcc_unreachable();
+
+		case 32:
+//			attrs |= RAP_HASH_FLOAT;
+			break;
+
+		case 64:
+//			attrs |= RAP_HASH_DOUBLE;
+			break;
+
+		case 80:
+		case 128:
+			attrs |= RAP_HASH_LONG_DOUBLE;
+			break;
+		}
+		rap_hash_type_precision(main_variant, sip_hash);
+		break;
+	}
+
+	case ENUMERAL_TYPE:
+		rap_hash_type_name(type, sip_hash);
+	case BOOLEAN_TYPE:
+		rap_hash_type_precision(type, sip_hash);
+		break;
+
+	case INTEGER_TYPE: {
+		attrs |= TYPE_UNSIGNED(type) ? RAP_HASH_UNSIGNED : RAP_HASH_SIGNED;
+		rap_hash_type_precision(type, sip_hash);
+		break;
+	}
+	}
+
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+}
+
+static const_tree rap_dequal_argtype(const_tree argtype)
+{
+	// since gcc/tree.c:free_lang_data_in_type removes const/volatile from the top level param decl
+	// we have to simulate it here as this can be called earlier from the frontend as well
+	if (TYPE_READONLY(argtype) || TYPE_VOLATILE(argtype)) {
+		int quals;
+
+		quals = TYPE_QUALS(argtype) & ~TYPE_QUAL_CONST & ~TYPE_QUAL_VOLATILE;
+		argtype = build_qualified_type(CONST_CAST_TREE(argtype), quals);
+	}
+
+	return argtype;
+}
+
+// main function to compute the rap hash for function types
+// while virtual class methods are always replaced with their ancestor,
+// callers can decide whether to fully utilize that information via flags.method_ancestor
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	function_args_iterator args_iter;
+	const_tree arg;
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fntype);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		// 1. hash the result
+		rap_hash_tree(TREE_TYPE(fntype), flags, sip_hash);
+
+		// 2. hash the function parameters
+		FOREACH_FUNCTION_ARGS(fntype, arg, args_iter) {
+			const_tree argtype = arg;
+
+			argtype = rap_dequal_argtype(argtype);
+			rap_hash_tree(argtype, flags, sip_hash);
+		}
+		break;
+	}
+}
+
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags)
+{
+	unsigned char sip_hash[8] = { };
+	rap_hash_t hash;
+
+	rap_hash_function(fntype, flags, sip_hash);
+	hash = rap_extract_hash(sip_hash);
+
+	gcc_assert(hash.hash);
+	return hash;
+}
+
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags)
+{
+	tree fntype;
+
+	gcc_assert(TREE_CODE(fndecl) == FUNCTION_DECL);
+	fntype = TREE_TYPE(fndecl);
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fndecl);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		return rap_hash_function_type(fntype, flags);
+	}
+}
+
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node)
+{
+	rap_hash_t hash;
+	tree fndecl;
+	int uid;
+
+	gcc_assert(rap_imprecise_hashes);
+
+	hash.hash = 0;
+#if BUILDING_GCC_VERSION < 9003
+	uid = node->uid;
+#else
+	uid = node->get_uid();
+#endif
+	if (uid < rap_cgraph_max_uid)
+		hash = rap_imprecise_hashes[uid];
+
+	if (hash.hash)
+		return hash;
+
+	fndecl = NODE_DECL(node);
+	if (TREE_CODE(TREE_TYPE(fndecl)) == FUNCTION_TYPE)
+		return rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	debug_cgraph_node(node);
+	debug_tree(fndecl);
+	error("indirect call to function %qD with a reserved hash value", fndecl);
+	return hash;
+}
+
+void rap_calculate_func_hashes(void *event_data __unused, void *data __unused)
+{
+	cgraph_node_ptr node;
+	int uid;
+
+	gcc_assert(!rap_imprecise_hashes);
+
+	rap_imprecise_hashes = (rap_hash_t *)xcalloc(cgraph_max_uid, sizeof(*rap_imprecise_hashes));
+	rap_cgraph_max_uid = cgraph_max_uid;
+
+	FOR_EACH_FUNCTION(node) {
+		const_tree fndecl;
+
+#if BUILDING_GCC_VERSION < 9003
+		uid = node->uid;
+#else
+		uid = node->get_uid();
+#endif
+		gcc_assert(uid < rap_cgraph_max_uid);
+
+#if BUILDING_GCC_VERSION < 10000
+		if (node->global.inlined_to)
+#else
+		if (node->inlined_to)
+#endif
+			continue;
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+
+		rap_imprecise_hashes[uid] = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+		gcc_assert(rap_imprecise_hashes[uid].hash);
+	}
+}
diff --git a/scripts/gcc-plugins/rap_plugin/rap_plugin.c b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
new file mode 100644
index 000000000..963960c56
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
@@ -0,0 +1,553 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ *
+ * Usage:
+ * $ # for 4.5/4.6/C based 4.7
+ * $ gcc -I`gcc -print-file-name=plugin`/include -I`gcc -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ # for C++ based 4.7/4.8+
+ * $ g++ -I`g++ -print-file-name=plugin`/include -I`g++ -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ gcc -fplugin=./rap_plugin.so -fplugin-arg-rap_plugin-check=call test.c -O2
+ */
+
+#include "rap.h"
+
+__visible int plugin_is_GPL_compatible;
+
+static struct plugin_info rap_plugin_info = {
+	.version	= "201604272100",
+	.help		= "check=call\tenable the corresponding features\n"
+			  "hash=abs,abs-finish,const,volatile\n"
+			  "report=func,fptr,abs\n"
+};
+
+rap_hash_flags_t imprecise_rap_hash_flags = {
+	.qual_const	= 1,
+	.qual_volatile	= 1,
+};
+
+tree rap_hash_type_node;
+
+static bool report_func_hash, report_abs_hash;
+
+// create the equivalent of
+// asm volatile("" : : : "memory");
+// or
+// asm("" : "+rm"(var));
+// or
+// asm("" : : "rm"(var));
+gimple barrier(tree var, bool full)
+{
+	gimple stmt;
+	gasm *asm_stmt;
+#if BUILDING_GCC_VERSION <= 4007
+	VEC(tree, gc) *inputs = NULL;
+	VEC(tree, gc) *outputs = NULL;
+	VEC(tree, gc) *clobbers = NULL;
+#else
+	vec<tree, va_gc> *inputs = NULL;
+	vec<tree, va_gc> *outputs = NULL;
+	vec<tree, va_gc> *clobbers = NULL;
+#endif
+
+	if (!var && full) {
+		tree clobber;
+
+		clobber = build_tree_list(NULL_TREE, build_string(7, "memory"));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, clobbers, clobber);
+#else
+		vec_safe_push(clobbers, clobber);
+#endif
+	} else if (full) {
+		tree input, output;
+
+		input = build_tree_list(NULL_TREE, build_string(2, "0"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+
+		output = build_tree_list(NULL_TREE, build_string(4, "=rm"));
+		gcc_assert(SSA_NAME_VAR(var));
+		var = make_ssa_name(SSA_NAME_VAR(var), NULL);
+		output = chainon(NULL_TREE, build_tree_list(output, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, outputs, output);
+#else
+		vec_safe_push(outputs, output);
+#endif
+	} else {
+		tree input;
+
+		input = build_tree_list(NULL_TREE, build_string(3, "rm"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+	}
+
+	stmt = gimple_build_asm_vec("", inputs, outputs, clobbers, NULL);
+	asm_stmt = as_a_gasm(stmt);
+	if (!var && full)
+		gimple_asm_set_volatile(asm_stmt, true);
+	else if (full)
+		SSA_NAME_DEF_STMT(var) = stmt;
+	return stmt;
+}
+
+static const struct gcc_debug_hooks *old_debug_hooks;
+static struct gcc_debug_hooks rap_debug_hooks;
+
+static bool __rap_cgraph_indirectly_callable(cgraph_node_ptr node, void *data)
+{
+#if BUILDING_GCC_VERSION >= 4008
+	if (NODE_SYMBOL(node)->externally_visible)
+#else
+	if (node->local.externally_visible)
+#endif
+		return true;
+
+	if (NODE_SYMBOL(node)->address_taken)
+		return true;
+
+	return false;
+}
+
+static bool rap_cgraph_indirectly_callable(cgraph_node_ptr node)
+{
+	return cgraph_for_node_and_aliases(node, __rap_cgraph_indirectly_callable, NULL, true);
+}
+
+static void rap_hash_align(tree decl)
+{
+	const unsigned HOST_WIDE_INT rap_hash_offset = TARGET_64BIT ? 2 * sizeof(rap_hash_t) : sizeof(rap_hash_t);
+	unsigned HOST_WIDE_INT skip;
+
+#if BUILDING_GCC_VERSION < 9003
+	skip = 1ULL << align_functions_log;
+#else
+	skip = 1ULL <<  align_functions.levels[0].log;
+#endif
+	if (DECL_USER_ALIGN(decl))
+		return;
+
+	if (!optimize_function_for_speed_p(cfun)) {
+		ASM_OUTPUT_ASCII(asm_out_file, "\xb8", 1);
+		return;
+	}
+
+	if (skip <= rap_hash_offset)
+		return;
+
+#ifdef TARGET_64BIT
+	{
+		char padding[RAP_HASH_START_PADDING_SIZE];
+
+		// this byte sequence helps disassemblers not trip up on the following rap hash
+		memset(padding, 0xcc, sizeof padding - 1);
+		padding[sizeof padding - 1] = 0xb8;
+		ASM_OUTPUT_ASCII(asm_out_file, padding, sizeof padding);
+	}
+#else
+	ASM_OUTPUT_SKIP(asm_out_file, skip - rap_hash_offset);
+#endif
+}
+
+static void rap_begin_function(tree decl)
+{
+	cgraph_node_ptr node;
+	rap_hash_t imprecise_rap_hash;
+	char *name = NULL;
+	char end_padding[RAP_HASH_END_PADDING_SIZE];
+
+	memset(end_padding, 0xcc, sizeof end_padding);
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	// chain to previous callback
+	if (old_debug_hooks && old_debug_hooks->begin_function)
+		old_debug_hooks->begin_function(decl);
+
+	// don't compute hash for functions called only directly
+	node = cgraph_get_node(decl);
+	gcc_assert(node);
+	if (!rap_cgraph_indirectly_callable(node)) {
+		imprecise_rap_hash.hash = 0;
+		return;
+	} else {
+		imprecise_rap_hash = rap_hash_function_node_imprecise(node);
+	}
+
+	gcc_assert(asprintf(&name, "__cfi_%s", IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl))) != -1);
+	if (TREE_PUBLIC(decl)) {
+		if (lookup_attribute("weak", DECL_ATTRIBUTES(decl)))
+			fprintf(asm_out_file, "\t.weak\t%s\n", name);
+		else
+			fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	}
+
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "function");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+
+	// align the rap hash if necessary
+	rap_hash_align(decl);
+
+	if (report_func_hash)
+		inform(DECL_SOURCE_LOCATION(decl), "func rap_hash: %x %s", imprecise_rap_hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+	fprintf(asm_out_file, "\t.long %#x\t%s __rap_hash_%s\n", imprecise_rap_hash.hash, ASM_COMMENT_START, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+	ASM_OUTPUT_ASCII(asm_out_file, end_padding, sizeof end_padding);
+	fprintf(asm_out_file, "\t.size\t%s, .-%s\n", name, name);
+}
+
+static void rap_start_unit_common(void *gcc_data __unused, void *user_data __unused)
+{
+	rap_hash_type_node = long_integer_type_node;
+
+	if (debug_hooks)
+		rap_debug_hooks = *debug_hooks;
+	rap_debug_hooks.begin_function = rap_begin_function;
+	old_debug_hooks = debug_hooks;
+	debug_hooks = &rap_debug_hooks;
+}
+
+/*
+   emit an absolute symbol for each function that may be referenced through the plt
+     - all externs
+     - non-static functions
+       - use visibility instead?
+
+   .globl __rap_hash_func
+   .offset 0xhash_for_func
+   .type __rap_hash_func, @object
+   __rap_hash_func:
+   .previous
+*/
+static void rap_finish_unit(void *gcc_data __unused, void *user_data __unused)
+{
+	cgraph_node_ptr node;
+	rap_hash_t hash;
+
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	hash.hash = 0;
+	FOR_EACH_FUNCTION(node) {
+		tree fndecl;
+		const char *asmname;
+		char *name = NULL;
+
+		if (cgraph_function_body_availability(node) >= AVAIL_INTERPOSABLE) {
+			if (node->thunk || node->alias)
+				continue;
+			if (!rap_cgraph_indirectly_callable(node))
+				continue;
+		}
+
+#if BUILDING_GCC_VERSION >= 4007
+		gcc_assert(cgraph_function_or_thunk_node(node, NULL) == node);
+#endif
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+		if (DECL_IS_UNDECLARED_BUILTIN(fndecl) && DECL_BUILT_IN_CLASS(fndecl) == BUILT_IN_NORMAL)
+			continue;
+
+		if (!TREE_PUBLIC(fndecl))
+			continue;
+
+		if (DECL_ARTIFICIAL(fndecl))
+			continue;
+
+		if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+			continue;
+
+		gcc_assert(DECL_ASSEMBLER_NAME(fndecl));
+		asmname = IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl));
+		if (strchr(asmname, '.'))
+			continue;
+
+		if (asmname[0] == '*')
+			asmname++;
+
+		gcc_assert(asmname[0]);
+		gcc_assert(asprintf(&name, "__rap_hash_%s", asmname) != -1);
+
+		hash = rap_hash_function_node_imprecise(node);
+		if (report_abs_hash)
+			inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl)));
+
+		fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+		ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+		ASM_OUTPUT_LABEL(asm_out_file, name);
+		free(name);
+	}
+
+	if (hash.hash)
+		fprintf(asm_out_file, "\t.previous\n");
+}
+
+#if BUILDING_GCC_VERSION >= 4007
+// emit the rap hash as an absolute symbol for all functions seen in the frontend
+// this is necessary as later unreferenced nodes will be removed yet we'd like to emit as many hashes as possible
+static void rap_finish_decl(void *event_data, void *data __unused)
+{
+	tree fndecl = (tree)event_data;
+	rap_hash_t hash;
+	const char *asmname;
+	char *name = NULL;
+
+	if (fndecl == error_mark_node)
+		return;
+
+	if (TREE_CODE(fndecl) != FUNCTION_DECL)
+		return;
+
+	if (!TREE_PUBLIC(fndecl))
+		return;
+
+	if (DECL_ARTIFICIAL(fndecl))
+		return;
+
+	if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+		return;
+
+	asmname = DECL_NAME_POINTER(fndecl);
+	gcc_assert(asmname[0]);
+
+	if (strchr(asmname, '.'))
+		return;
+
+	gcc_assert(asprintf(&name, "__rap_hash_%s", asmname) != -1);
+
+	hash = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	if (report_abs_hash)
+		inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, asmname);
+
+	fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	if (TARGET_64BIT)
+		fprintf(asm_out_file, "\t.offset %#lx\n", (long)hash.hash);
+	else
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+	free(name);
+
+	fprintf(asm_out_file, "\t.previous\n");
+}
+#endif
+
+static bool rap_unignore_gate(void)
+{
+	if (!DECL_IGNORED_P(current_function_decl))
+		return false;
+
+	inform(DECL_SOURCE_LOCATION(current_function_decl), "DECL_IGNORED fixed");
+
+	DECL_IGNORED_P(current_function_decl) = 0;
+	return false;
+}
+
+#define PASS_NAME rap_unignore
+#define NO_EXECUTE
+#define TODO_FLAGS_FINISH TODO_dump_func
+#include "gcc-generate-rtl-pass.h"
+
+static bool rap_version_check(struct plugin_gcc_version *gcc_version, struct plugin_gcc_version *plugin_version)
+{
+	if (!gcc_version || !plugin_version)
+		return false;
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (strncmp(gcc_version->basever, plugin_version->basever, 4))
+#else
+	if (strcmp(gcc_version->basever, plugin_version->basever))
+#endif
+		return false;
+	if (strcmp(gcc_version->datestamp, plugin_version->datestamp))
+		return false;
+	if (strcmp(gcc_version->devphase, plugin_version->devphase))
+		return false;
+	if (strcmp(gcc_version->revision, plugin_version->revision))
+		return false;
+//	if (strcmp(gcc_version->configuration_arguments, plugin_version->configuration_arguments))
+//		return false;
+	return true;
+}
+
+EXPORTED_CONST struct ggc_root_tab gt_ggc_r_gt_rap[] = {
+	{
+		.base = &rap_hash_type_node,
+		.nelt = 1,
+		.stride = sizeof(rap_hash_type_node),
+		.cb = &gt_ggc_mx_tree_node,
+		.pchw = &gt_pch_nx_tree_node
+	},
+	LAST_GGC_ROOT_TAB
+};
+
+static void
+handle_type_cast (void *gcc_data, void *user_data)
+{
+  (void) user_data;
+  tree *t = (tree *) gcc_data;
+  tree type = t[0];
+  tree otype = t[1];
+
+  if (TREE_CODE (type) == POINTER_TYPE
+      && TREE_CODE (otype) == POINTER_TYPE
+      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE
+      && TREE_CODE (TREE_TYPE (otype)) == FUNCTION_TYPE
+//      && type != TYPE_MAIN_VARIANT (otype)
+      && TYPE_CANONICAL (TREE_TYPE (type)) != TYPE_CANONICAL (TREE_TYPE (otype)))
+        error (G_("cast from function type %qT "
+                  "to non-matching type %qT"), otype, type);
+
+}
+
+__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	int i;
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	bool enable_call = false;
+	bool enable_abs = false, enable_abs_finish = false;
+
+	struct register_pass_info rap_fptr_pass_info;
+	struct register_pass_info rap_unignore_pass_info;
+
+	rap_fptr_pass_info.pass						= make_rap_fptr_pass();
+	rap_fptr_pass_info.reference_pass_name				= "nrv";
+	rap_fptr_pass_info.ref_pass_instance_number			= 1;
+	rap_fptr_pass_info.pos_op 					= PASS_POS_INSERT_AFTER;
+
+	rap_unignore_pass_info.pass					= make_rap_unignore_pass();
+	rap_unignore_pass_info.reference_pass_name			= "final";
+	rap_unignore_pass_info.ref_pass_instance_number			= 1;
+	rap_unignore_pass_info.pos_op 					= PASS_POS_INSERT_BEFORE;
+
+	if (!rap_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (flag_ipa_icf_functions) {
+//		warning_at(UNKNOWN_LOCATION, 0, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+//		inform(UNKNOWN_LOCATION, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+		flag_ipa_icf_functions = 0;
+	}
+#endif
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "disable"))
+			continue;
+
+		if (!strcmp(argv[i].key, "check")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "call"))
+					enable_call = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "hash")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "abs"))
+					enable_abs = enable_abs_finish = true;
+				else if (!strcmp(value, "abs-finish"))
+					enable_abs_finish = true;
+//				else if (!strcmp(value, "const"))
+//					imprecise_rap_hash_flags.qual_const = 1;
+//				else if (!strcmp(value, "volatile"))
+//					imprecise_rap_hash_flags.qual_volatile = 1;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "report")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "func"))
+					report_func_hash = true;
+				else if (!strcmp(value, "fptr"))
+					report_fptr_hash = true;
+				else if (!strcmp(value, "abs"))
+					report_abs_hash = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &rap_plugin_info);
+
+	if (enable_call) {
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_fptr_pass_info);
+	}
+
+	if (enable_call || enable_abs_finish) {
+#if BUILDING_GCC_VERSION >= 4007
+		if (enable_abs)
+			register_callback(plugin_name, PLUGIN_FINISH_DECL, rap_finish_decl, NULL);
+#else
+#warning TODO
+#endif
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_unignore_pass_info);
+		register_callback(plugin_name, PLUGIN_REGISTER_GGC_ROOTS, NULL, (void *)&gt_ggc_r_gt_rap);
+		register_callback(plugin_name, PLUGIN_START_UNIT, rap_start_unit_common, NULL);
+		if (enable_abs_finish)
+			register_callback(plugin_name, PLUGIN_FINISH_UNIT, rap_finish_unit, NULL);
+		register_callback(plugin_name, PLUGIN_ALL_IPA_PASSES_START, rap_calculate_func_hashes, NULL);
+		register_callback (plugin_name, PLUGIN_TYPE_CAST, handle_type_cast, NULL);
+	}
+	return 0;
+}
diff --git a/scripts/gcc-plugins/rap_plugin/sip.c b/scripts/gcc-plugins/rap_plugin/sip.c
new file mode 100644
index 000000000..65bc1cdea
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/sip.c
@@ -0,0 +1,96 @@
+// SipHash-2-4 adapted by the PaX Team from the public domain version written by
+//   Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
+//   Daniel J. Bernstein <djb@cr.yp.to>
+
+#include <stdint.h>
+
+#define ROTL(x, b) (u64)(((x) << (b)) | ((x) >> (64 - (b))))
+
+#define U32TO8_LE(p, v)						\
+	(p)[0] = (u8)((v)      ); (p)[1] = (u8)((v) >>  8);	\
+	(p)[2] = (u8)((v) >> 16); (p)[3] = (u8)((v) >> 24);
+
+#define U64TO8_LE(p, v)				\
+	U32TO8_LE((p),     (u32)((v)      ));	\
+	U32TO8_LE((p) + 4, (u32)((v) >> 32));
+
+#define U8TO64_LE(p)	(	\
+	((u64)((p)[0])      ) |	\
+	((u64)((p)[1]) <<  8) |	\
+	((u64)((p)[2]) << 16) |	\
+	((u64)((p)[3]) << 24) |	\
+	((u64)((p)[4]) << 32) |	\
+	((u64)((p)[5]) << 40) |	\
+	((u64)((p)[6]) << 48) |	\
+	((u64)((p)[7]) << 56))
+
+#define SIPROUND							\
+do {									\
+	v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; v0 = ROTL(v0, 32);	\
+	v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2;				\
+	v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0;				\
+	v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; v2 = ROTL(v2, 32);	\
+} while(0)
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint8_t u8;
+
+/* SipHash-2-4 with previous output folding, a poor man's streaming interface */
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k)
+{
+	u64 k0 = U8TO64_LE(k);
+	u64 k1 = U8TO64_LE(k + 8);
+	/* "somepseudorandomlygeneratedbytes" */
+	u64 v0 = 0x736f6d6570736575ULL ^ k0;
+	u64 v1 = 0x646f72616e646f6dULL ^ k1;
+	u64 v2 = 0x6c7967656e657261ULL ^ k0;
+	u64 v3 = 0x7465646279746573ULL ^ k1;
+	u64 b, m;
+	const u8 * const end = in + inlen - (inlen % sizeof(u64));
+	const int left = inlen & 7;
+	b = ((u64)inlen) << 56;
+
+	// fold in the previous output
+	m = U8TO64_LE(out);
+	v3 ^= m;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= m;
+
+	// consume full input blocks
+	for (; in != end; in += 8) {
+		m = U8TO64_LE(in);
+		v3 ^= m;
+		SIPROUND;
+		SIPROUND;
+		v0 ^= m;
+	}
+
+	// consume the last potentially partial block
+	switch (left) {
+	case 7: b |= ((u64)in[6]) << 48;
+	case 6: b |= ((u64)in[5]) << 40;
+	case 5: b |= ((u64)in[4]) << 32;
+	case 4: b |= ((u64)in[3]) << 24;
+	case 3: b |= ((u64)in[2]) << 16;
+	case 2: b |= ((u64)in[1]) <<  8;
+	case 1: b |= ((u64)in[0]); break;
+	case 0: break;
+	}
+
+	// finalize
+	v3 ^= b;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= b;
+	v2 ^= 0xff;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	b = v0 ^ v1 ^ v2 ^ v3;
+	U64TO8_LE(out, b);
+}
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e6be7fc26..f917a868e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1875,15 +1875,9 @@ static void check_exports(struct module *mod)
 		const char *basename;
 		exp = find_symbol(s->name);
 		if (!exp) {
-			if (!s->weak && nr_unresolved++ < MAX_UNRESOLVED_REPORTS)
-				modpost_log(warn_unresolved ? LOG_WARN : LOG_ERROR,
-					    "\"%s\" [%s.ko] undefined!\n",
-					    s->name, mod->name);
 			continue;
 		}
 		if (exp->module == mod) {
-			error("\"%s\" [%s.ko] was exported without definition\n",
-			      s->name, mod->name);
 			continue;
 		}
 
diff --git a/security/Kconfig b/security/Kconfig
index fb75f9203..453c8e039 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -94,6 +94,26 @@ config PAX_XATTR_PAX_FLAGS
 	  will run with PaX enabled on them by default.
 
 endif
+
+config PAX_RAP
+	bool "Prevent code reuse attacks"
+	depends on X86_64 && GCC_PLUGINS
+	select CFI_CLANG
+	help
+	  By saying Y here the kernel will check indirect control transfers
+	  in order to detect and prevent attacks that try to hijack control
+	  flow by overwriting code pointers.
+
+	  If you have an amd64 processor that does not support SMEP then you
+	  must also enable a KERNEXEC code pointer instrumentation method
+	  (see PAX_KERNEXEC_PLUGIN).
+
+	  Note that binary modules cannot be instrumented by this approach.
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+
 endif
 
 source "security/keys/Kconfig"
-- 
2.19.0

