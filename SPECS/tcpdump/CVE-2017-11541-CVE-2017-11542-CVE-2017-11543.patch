diff -dupr a/print-pim.c b/print-pim.c
--- a/print-pim.c	2017-07-22 16:33:48.000000000 -0700
+++ b/print-pim.c	2017-09-07 18:41:56.300698716 -0700
@@ -306,6 +306,7 @@ pimv1_print(netdissect_options *ndo,
 			pimv1_join_prune_print(ndo, &bp[8], len - 8);
 		break;
 	}
+	ND_TCHECK(bp[4]);
 	if ((bp[4] >> 4) != 1)
 		ND_PRINT((ndo, " [v%d]", bp[4] >> 4));
 	return;
diff -dupr a/print-sl.c b/print-sl.c
--- a/print-sl.c	2017-07-22 16:33:48.000000000 -0700
+++ b/print-sl.c	2017-09-07 19:09:07.290395738 -0700
@@ -131,8 +131,21 @@ sliplink_print(netdissect_options *ndo,
 	u_int hlen;
 
 	dir = p[SLX_DIR];
-	ND_PRINT((ndo, dir == SLIPDIR_IN ? "I " : "O "));
-
+	switch (dir) {
+ 
+ 	case SLIPDIR_IN:
+ 		ND_PRINT((ndo, "I "));
+ 		break;
+ 
+ 	case SLIPDIR_OUT:
+ 		ND_PRINT((ndo, "O "));
+ 		break;
+ 
+ 	default:
+ 		ND_PRINT((ndo, "Invalid direction %d ", dir));
+ 		dir = -1;
+ 		break;
+ 	}
 	if (ndo->ndo_nflag) {
 		/* XXX just dump the header */
 		register int i;
@@ -155,13 +168,21 @@ sliplink_print(netdissect_options *ndo,
 		 * has restored the IP header copy to IPPROTO_TCP.
 		 */
 		lastconn = ((const struct ip *)&p[SLX_CHDR])->ip_p;
+		ND_PRINT((ndo, "utcp %d: ", lastconn));
+ 		if (dir == -1) {
+ 			/* Direction is bogus, don't use it */
+ 			return;
+ 		}
 		hlen = IP_HL(ip);
 		hlen += TH_OFF((const struct tcphdr *)&((const int *)ip)[hlen]);
 		lastlen[dir][lastconn] = length - (hlen << 2);
-		ND_PRINT((ndo, "utcp %d: ", lastconn));
 		break;
 
 	default:
+		if (dir == -1) {
+ 			/* Direction is bogus, don't use it */
+ 			return;
+ 		}
 		if (p[SLX_CHDR] & TYPE_COMPRESSED_TCP) {
 			compressed_sl_print(ndo, &p[SLX_CHDR], ip,
 			    length, dir);
diff -dupr a/util-print.c b/util-print.c
--- a/util-print.c	2017-07-22 16:33:49.000000000 -0700
+++ b/util-print.c	2017-09-07 18:46:44.086850015 -0700
@@ -902,7 +902,7 @@ safeputs(netdissect_options *ndo,
 {
 	u_int idx = 0;
 
-	while (*s && idx < maxlen) {
+	while (idx < maxlen && *s) {
 		safeputchar(ndo, *s);
 		idx++;
 		s++;
