From 1b69bb032250b91c90ff30520c1d527cf0cfbcce Mon Sep 17 00:00:00 2001
From: Mark Wielaard <mark@klomp.org>
Date: Sat, 8 Feb 2025 21:44:56 +0100
Subject: [PATCH] libelf, readelf: Use validate_str also to check dynamic
 symstr data

When dynsym/str was read through eu-readelf --dynamic by readelf
process_symtab the string data was not validated, possibly printing
unallocated memory past the end of the symstr data. Fix this by
turning the elf_strptr validate_str function into a generic
lib/system.h helper function and use it in readelf to validate the
strings before use.

	* libelf/elf_strptr.c (validate_str): Remove to...
	* lib/system.h (validate_str): ... here. Make inline, simplify
	check and document.
	* src/readelf.c (process_symtab): Use validate_str on symstr_data.

https://sourceware.org/bugzilla/show_bug.cgi?id=32654

Signed-off-by: Mark Wielaard <mark@klomp.org>
---
 lib/system.h        | 27 +++++++++++++++++++++++++++
 libelf/elf_strptr.c | 18 ------------------
 2 files changed, 27 insertions(+), 18 deletions(-)

diff --git a/lib/system.h b/lib/system.h
index 1c914efc..8712cec7 100644
--- a/lib/system.h
+++ b/lib/system.h
@@ -33,6 +33,7 @@
 #include <config.h>
 
 #include <errno.h>
+#include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
@@ -116,6 +117,32 @@ startswith (const char *str, const char *prefix)
   return strncmp (str, prefix, strlen (prefix)) == 0;
 }
 
+/* Return TRUE if STR[FROM] is a valid string with a zero terminator
+   at or before STR[TO - 1].  Note FROM is an index into the STR
+   array, while TO is the maximum size of the STR array.  This
+   function returns FALSE when TO is zero or FROM >= TO.  */
+static inline bool
+validate_str (const char *str, size_t from, size_t to)
+{
+#if HAVE_DECL_MEMRCHR
+  // Check end first, which is likely a zero terminator,
+  // to prevent function call
+  return (to > 0
+	  && (str[to - 1] == '\0'
+	      || (to > from
+		  && memrchr (&str[from], '\0', to - from - 1) != NULL)));
+#else
+  do {
+    if (to <= from)
+      return false;
+
+    to--;
+  } while (str[to]);
+
+  return true;
+#endif
+}
+
 /* A special gettext function we use if the strings are too short.  */
 #define sgettext(Str) \
   ({ const char *__res = strrchr (_(Str), '|');			      \
diff --git a/libelf/elf_strptr.c b/libelf/elf_strptr.c
index 79a24d25..c5a94f82 100644
--- a/libelf/elf_strptr.c
+++ b/libelf/elf_strptr.c
@@ -53,24 +53,6 @@ get_zdata (Elf_Scn *strscn)
   return zdata;
 }
 
-static bool validate_str (const char *str, size_t from, size_t to)
-{
-#if HAVE_DECL_MEMRCHR
-  // Check end first, which is likely a zero terminator, to prevent function call
-  return ((to > 0 && str[to - 1]  == '\0')
-	  || (to - from > 0 && memrchr (&str[from], '\0', to - from - 1) != NULL));
-#else
-  do {
-    if (to <= from)
-      return false;
-
-    to--;
-  } while (str[to]);
-
-  return true;
-#endif
-}
-
 char *
 elf_strptr (Elf *elf, size_t idx, size_t offset)
 {
-- 
2.43.0

